'Copyright (c) 2007-2010 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[globalize debug_parse nil]

[defmetro parse_format [:rest exps]
  `[if debug_parse
       [terminal_format standard-terminal @exps]]]



'dictionary frame parsing commands'

[deftypefunk english_dictionary execute parse_sequence_as_verb_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a verb word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_verbs [get this definitions_by_type `verb_word first_word]]]
	[let [[second_word [if [cdr sequence] [second sequence]]]]
	  [let [[first_and_second_word_verbs [if [cdr sequence] [get this definitions_by_type `verb_word [list first_word second_word]]]]]
	    [let [[verbs [append first_word_verbs first_and_second_word_verbs]]]
	      [mapc [funk [verb]
			  [parse_format '\n    found a verb: ' [get verb symbols]]
			  [let [[new_parse_tree [get parse_tree new_copy]]
				[new_verb_word  [get verb new_copy]]
				[rest_sequence  [if [is-type `symbol [get verb symbols]]
						    [cdr sequence]
						  [cddr sequence]]]]
			    [have new_parse_tree add_next new_verb_word]
			    [= parses [cons [frame parse_tree    new_parse_tree
						   verb_word     new_verb_word
						   rest_sequence rest_sequence]
					    parses]]]]
		    verbs]]]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_auxiliary_be_verbs [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as auxiliary be verbs.']
    [let [[verb_parses [have this parse_sequence_as_verb_word sequence parse_tree]]]
      [mapc [funk [verb_parse]
		  [let [[verb_parse_tree    [have verb_parse lookup `parse_tree]]
			[verb_word          [have verb_parse lookup `verb_word]]
			[verb_rest_sequence [have verb_parse lookup `rest_sequence]]]
		    [if [get verb_word be]
			[prog [parse_format '\n  found be auxiliary verb parse: ' verb_parse]
			      [set verb_word auxiliary t]
			      [= parses [cons verb_parse parses]]
			      ]]]]
	    verb_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_verb_group [sequence parse_tree]
  [let [[parses nil]]
    [let [[verb_group [get parse_tree containing_type `verb_group]]]
      [let [[verb_group_parse_tree [get parse_tree new_copy]]]
	[parse_format '\n  parsing ' sequence ' as a verb_group.']
	[if [get verb_group_parse_tree containing_type_property `verb_group `imperative]
	    [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group.']
		  [let [[first_word [first sequence]]]
		    [let [[first_word_verbs [get this definitions_by_type `verb_word first_word]]]
		      [mapc [funk [first_word_verb]
				  [if [get first_word_verb Do]
				      [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as a form of "do".']
					    ]
				    [prog [if [get first_word_verb infinitive]
					      [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as an infinitive verb.']
						    [let [[new_parse_tree [get verb_group_parse_tree new_copy]]
							  [new_verb_word  [get first_word_verb new_copy]]]
						      [set new_verb_word Main t]
						      [have new_parse_tree add_next new_verb_word]
						      [= parses [cons [frame verb_word     new_verb_word
									     parse_tree    new_parse_tree
									     rest_sequence [cdr sequence]]
								      parses]]
						      ]]
					    [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as not an infinitive verb.']
						  ]]]]]
			    first_word_verbs]]]]
	  [prog [parse_format '\n  parsing ' sequence ' as not an imperative verb_group.']
		[let [[auxiliary_be_verbs_parses [have this parse_sequence_as_auxiliary_be_verbs sequence verb_group_parse_tree]]]
		  [mapc [funk [auxiliary_be_verbs_parse]
			      [let [[auxiliary_be_verbs_parse_tree    [have auxiliary_be_verbs_parse lookup `parse_tree]]
				    [auxiliary_be_verbs_rest_sequence [have auxiliary_be_verbs_parse lookup `rest_sequence]]]
				[if [not [get auxiliary_be_verbs_parse_tree containing_type_property `verb_group `not_only_auxiliary]]
				    [prog [= parses [cons [frame parse_tree    auxiliary_be_verbs_parse_tree
								 rest_sequence auxiliary_be_verbs_rest_sequence]
							  parses]]]]
				[if [and [     get auxiliary_be_verbs_parse_tree containing_type_property `verb_group `not_only_auxiliary]
					 [not [get auxiliary_be_verbs_parse_tree containing_type_property `verb_group `auxiliary]]]
				    [let [[verb_parses [have this parse_sequence_as_verb_word auxiliary_be_verbs_rest_sequence auxiliary_be_verbs_parse_tree]]]
				      [mapc [funk [verb_parse]
						  [let [[verb_parse_tree    [have verb_parse lookup `parse_tree]]
							[verb_rest_sequence [have verb_parse lookup `rest_sequence]]
							[verb_word          [have verb_parse lookup `verb_word]]]
						    [if [or [get verb_word en]
							    [get verb_word ing]]
							[prog [parse_format '\n  verb_word satisfies en or ing conjugation: ' verb_word]
							      [set verb_word Main t]
							      [if [get verb_word en]
								  [prog [parse_format '\n  verb_word is en following a be verb, so marking verb_group as passive.']
									[set verb_parse_tree containing_type_property `verb_group `passive t]]]
							      [= parses [cons [frame parse_tree    verb_parse_tree
										     rest_sequence verb_rest_sequence]
									      parses]]]]]]
					    verb_parses]]]]]
			auxiliary_be_verbs_parses]]
		]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_preposition_group [sequence parse_tree]
  [parse_format '\n  parsing ' sequence ' as a preposition_group.']
  ]

[deftypefunk english_dictionary execute parse_sequence_as_bound_clause [sequence parse_tree]
  [parse_format '\n  parsing ' sequence ' as a bound clause.']
  ]

[deftypefunk english_dictionary execute parse_sequence_as_particle_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a particle word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_particles [get this definitions_by_type `particle_word first_word]]]
	[mapc [funk [first_word_particle]
		    [parse_format '\n    found first word to be a particle: ' first_word]
		    [let [[new_parse_tree    [get parse_tree          new_copy]]
			  [new_particle_word [get first_word_particle new_copy]]]
		      [have new_parse_tree add_next new_particle_word]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     particle_word new_particle_word]
				      parses]]]]
	      first_word_particles]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_determiner_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a determiner word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_determiners [get this definitions_by_type `determiner_word first_word]]]
	[let [[second_word [if [cdr sequence] [second sequence]]]]
	  [let [[first_and_second_word_determiners [if [cdr sequence] [get this definitions_by_type `determiner_word [list first_word second_word]]]]]
	    [let [[determiners [append first_word_determiners first_and_second_word_determiners]]]
	      [mapc [funk [determiner]
			  [parse_format '\n    found a determiner: ' [get determiner symbols]]
			  [let [[new_parse_tree      [get parse_tree new_copy]]
				[new_determiner_word [get determiner new_copy]]
				[rest_sequence       [if [is-type `symbol [get determiner symbols]]
							 [cdr sequence]
						       [cddr sequence]]]]
			    [have new_parse_tree add_next new_determiner_word]
			    [= parses [cons [frame parse_tree      new_parse_tree
						   determiner_word new_determiner_word
						   rest_sequence   rest_sequence]
					    parses]]]]
		    determiners]]]]]]
    parses]]

[deftypefunk determiner_word execute transfer_relevant_features_to_noun_group [noun_group]
  [set noun_group definite   [get this definite]]
  [set noun_group indefinite [get this indefinite]]
  [set noun_group quantifier [get this quantifier]]
  [set noun_group singular   [get this singular]]
  [set noun_group plural     [get this plural]]
  [set noun_group mass       [get this mass]]
  [set noun_group determiner t]]

[deftypefunk english_dictionary execute parse_sequence_as_adjective_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an adjective word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_adjectives [get this definitions_by_type `adjective_word first_word]]]
	[mapc [funk [first_word_adjective]
		    [parse_format '\n    found first word to be an adjective: ' first_word]
		    [let [[new_parse_tree     [get parse_tree           new_copy]]
			  [new_adjective_word [get first_word_adjective new_copy]]]
		      [have new_parse_tree add_next new_adjective_word]
		      [= parses [cons [frame parse_tree     new_parse_tree
					     adjective_word new_adjective_word
					     rest_sequence  [cdr sequence]]
				      parses]]]]
	      first_word_adjectives]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_adjective_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[adjective_parses [have this parse_sequence_as_adjective_word sequence parse_tree]]]
      [mapc [funk [adjective_parse]
		  [let [[adjective_parse_tree [have adjective_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful adjective_word parse: ' adjective_parse]
		    [= parses [cons adjective_parse parses]]
		    [let [[adjective_words_parses [have this parse_sequence_as_adjective_words [cdr sequence] adjective_parse_tree]]]
		      [mapc [funk [adjective_words_parse]
				  [= parses [cons adjective_words_parse parses]]]
			    adjective_words_parses]]]]
	    adjective_parses]]
    parses]]


[deftypefunk english_dictionary execute parse_sequence_as_classifier_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a classifier word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_classifiers [get this definitions_by_type `classifier_word first_word]]]
	[mapc [funk [first_word_classifier]
		    [parse_format '\n    found first word to be a classifier: ' first_word]
		    [let [[new_parse_tree      [get parse_tree            new_copy]]
			  [new_classifier_word [get first_word_classifier new_copy]]]
		      [have new_parse_tree add_next new_classifier_word]
		      [= parses [cons [frame parse_tree      new_parse_tree
					     classifier_word new_classifier_word
					     rest_sequence   [cdr sequence]]
				      parses]]]]
	      first_word_classifiers]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_classifier_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[classifier_parses [have this parse_sequence_as_classifier_word sequence parse_tree]]]
      [mapc [funk [classifier_parse]
		  [let [[classifier_parse_tree [have classifier_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful classifier_word parse: ' classifier_parse]
		    [= parses [cons classifier_parse parses]]
		    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words [cdr sequence] classifier_parse_tree]]]
		      [mapc [funk [classifier_words_parse]
				  [= parses [cons classifier_words_parse parses]]]
			    classifier_words_parses]]]]
	    classifier_parses]]
    parses]]


[deftypefunk english_dictionary execute parse_sequence_as_noun_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an noun word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_nouns [get this definitions_by_type `noun_word first_word]]]
	[mapc [funk [first_word_noun]
		    [parse_format '\n    found first word to be an noun: ' first_word]
		    [let [[new_parse_tree [get parse_tree      new_copy]]
			  [new_noun_word  [get first_word_noun new_copy]]]
		      [have new_parse_tree add_next new_noun_word]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     noun_word     new_noun_word
					     rest_sequence [cdr sequence]]
				      parses]]]]
	      first_word_nouns]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_number_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a number word.']
    [let [[first_word [car sequence]]]
      [let [[number_definitions [get this definitions_by_type `number_word first_word]]]
	[mapc [funk [number_definition]
		    [parse_format '\n    found first word to be a number: ' first_word]
		    [let [[new_parse_tree [get parse_tree new_copy]]]
		      [have new_parse_tree add_next number_definition]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     rest_sequence [cdr sequence]
					     number_word   [get number_definition new_copy]]
				      parses]]]]
	      number_definitions]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_ordinal_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an ordinal word.']
    [let [[first_word [car sequence]]]
      [let [[ordinal_definitions [get this definitions_by_type `ordinal_word first_word]]]
	[mapc [funk [ordinal_definition]
		    [parse_format '\n    found first word to be an ordinal: ' first_word]
		    [let [[new_parse_tree [get parse_tree new_copy]]]
		      [have new_parse_tree add_next ordinal_definition]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     rest_sequence [cdr sequence]
					     ordinal_word  [get ordinal_definition new_copy]]
				      parses]]]]
	      ordinal_definitions]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_question_adjunct_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a question_adjunct word.']
    [let [[first_word [car sequence]]]
      [let [[question_adjunct_definitions [get this definitions_by_type `question_adjunct_word first_word]]]
	[mapc [funk [question_adjunct_definition]
		    [parse_format '\n    found first word to be a question_adjunct: ' first_word]
		    [let [[new_parse_tree [get parse_tree new_copy]]]
		      [have new_parse_tree add_next question_adjunct_definition]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     rest_sequence [cdr sequence]
					     question_adjunct_word   [get question_adjunct_definition new_copy]]
				      parses]]]]
	      question_adjunct_definitions]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_qualifiers [sequence parse_tree]
  [let [[parses nil]]
    'prep'
    'relative word (which)'
    'past participle (supported by)'
    'ing verb'
    'comparative adjective (bigger than)'
    'as (as big as)'
    'RSO clause'
    [parse_format '\n  qualifiers are not implemented.']
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_noun [sequence parse_tree noun_group]
  [let [[parses nil]]
    [if [not [null sequence]]
	[let [[qualifiers_parses [have this parse_sequence_as_qualifiers sequence parse_tree]]]
	  [mapc [funk [qualifiers_parse]
		      [= parses [cons qualifiers_parse parses]]]
		qualifiers_parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_classifiers [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[noun_parses [have this parse_sequence_as_noun_word sequence parse_tree]]]
      [mapc [funk [noun_parse]
		  [let [[noun_parse_tree [have noun_parse lookup `parse_tree]]
			[noun_word       [have noun_parse lookup `noun_word]]
			[rest_sequence   [have noun_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_classifiers noun_word parse: ' noun_parse]
		    [if [or [and [get noun_group singular] [get noun_word singular]]
			    [and [get noun_group plural]   [get noun_word plural]]
			    [and [get noun_group mass]     [get noun_word mass]]]
			[prog [parse_format '\n      noun group-after_classifiers noun_word agrees with singular, plural, mass qualities of noun_group.']
			      [= parses [cons noun_parse parses]]
			      [let [[after_noun_parses [have this parse_sequence_as_noun_group-after_noun rest_sequence noun_parse_tree noun_group]]]
				[mapc [funk [after_noun_parse]
					    [= parses [cons after_noun_parse parses]]]
				      after_noun_parses]]]
		      [prog [parse_format '\n      noun group-after_classifiers noun_word does not agree with singular, plural, mass qualities of noun_group.']
			    ]]]]
	    noun_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_adjectives [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words sequence parse_tree]]]
      [mapc [funk [classifier_words_parse]
		  [let [[classifier_words_parse_tree    [have classifier_words_parse lookup `parse_tree]]
			[classifier_words_rest_sequence [have classifier_words_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_adjectives found successful classifier_words parse: ' classifier_words_parse]
		    [let [[after_classifiers_parses [have this parse_sequence_as_noun_group-after_classifiers classifier_words_rest_sequence classifier_words_parse_tree noun_group]]]
		      [parse_format '\n      noun group-after_determiner after_classifiers (1) parses: ' after_classifiers_parses]
		      [= parses [append after_classifiers_parses parses]]]]]
	    classifier_words_parses]]
    [let [[after_classifiers_parses [have this parse_sequence_as_noun_group-after_classifiers sequence parse_tree noun_group]]]
      [parse_format '\n      noun group-after_determiner after_classifiers (2) parses: ' after_classifiers_parses]
      [= parses [append after_classifiers_parses parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_number [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[adjective_words_parses [have this parse_sequence_as_adjective_words sequence parse_tree]]]
      [mapc [funk [adjective_words_parse]
		  [let [[adjective_words_parse_tree    [have adjective_words_parse lookup `parse_tree]]
			[adjective_words_rest_sequence [have adjective_words_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_determiner found successful adjective_words parse: ' adjective_words_parse]
		    [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives adjective_words_rest_sequence adjective_words_parse_tree noun_group]]]
		      [parse_format '\n      noun group-after_determiner after_adjectives (1) parses: ' after_adjectives_parses]
		      [= parses [append after_adjectives_parses parses]]]]]
	    adjective_words_parses]]
    'finally, we try interpretting without any adjectives.'
    [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives sequence parse_tree noun_group]]]
      [parse_format '\n      noun group-after_determiner after_adjectives (2) parses: ' after_adjectives_parses]
      [= parses [append after_adjectives_parses parses]]]
    parses]]



[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_ordinal [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[number_parses [have this parse_sequence_as_number_word sequence parse_tree]]]
      [mapc [funk [number_parse]
		  [let [[number_parse_tree    [have number_parse lookup `parse_tree]]
			[number_word          [have number_parse lookup `number_word]]
			[number_rest_sequence [have number_parse lookup `rest_sequence]]]
		    [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number number_rest_sequence number_parse_tree noun_group]]]
		      [parse_format '\n      noun group-after_ordinal after_number (1) parses: ' after_number_parses]
		      [= parses [append after_number_parses parses]]]]]
	    number_parses]]
    [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number sequence parse_tree noun_group]]]
      [parse_format '\n      noun group-after_ordinal after_number (2) parses: ' after_number_parses]
      [= parses [append after_number_parses parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_determiner [sequence parse_tree noun_group]
  [let [[parses nil]]
    [if [get noun_group definite]
	[prog [parse_format '\n    our noun group is definite: ' noun_group]
	      'because our noun group is definite, we must look for an ordinal and a number.'
	      [let [[ordinal_parses [have this parse_sequence_as_ordinal_word sequence parse_tree]]]
		[mapc [funk [ordinal_parse]
			    [let [[ordinal_parse_tree    [have ordinal_parse lookup `parse_tree]]
				  [ordinal_rest_sequence [have ordinal_parse lookup `rest_sequence]]]
			      [let [[after_ordinal_parses [have this parse_sequence_as_noun_group-after_ordinal ordinal_rest_sequence ordinal_parse_tree noun_group]]]
				[parse_format '\n      noun group-after_determiner after_ordinal parses: ' after_number_parses]
				[= parses [append after_ordinal_parses parses]]]]]
		      ordinal_parses]]
	      [let [[after_ordinal_parses [have this parse_sequence_as_noun_group-after_ordinal sequence parse_tree noun_group]]]
		[= parses [append after_ordinal_parses parses]]]]
      [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number sequence parse_tree noun_group]]]
	[parse_format '\n      noun group-after_determiner after_number parses: ' after_number_parses]
	[= parses [append after_number_parses parses]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group [sequence parse_tree]
  [let [[parses nil]]
    [let [[noun_group [get parse_tree containing_type `noun_group]]]
      [let [[noun_group_parse_tree [get parse_tree new_copy]]]
	[parse_format '\n  parsing ' sequence ' as a noun_group.']
	[let [[first_word [first sequence]]]
	  [let [[determiner_parses [have this parse_sequence_as_determiner_word sequence noun_group_parse_tree]]]
	    [mapc [funk [determiner_parse]
			[let [[determiner_parse_tree    [have determiner_parse lookup `parse_tree]]
			      [determiner_word          [have determiner_parse lookup `determiner_word]]
			      [determiner_rest_sequence [have determiner_parse lookup `rest_sequence]]]
			  [if [eq [get noun_group question] [get determiner_word question]]
			      [prog [parse_format '\n    found successful determiner_word parse: ' determiner_parse]
				    [let [[new_noun_group [get noun_group new_copy]]]
				      [have determiner_word transfer_relevant_features_to_noun_group new_noun_group]
				      [let [[after_determiner_parses [have this parse_sequence_as_noun_group-after_determiner determiner_rest_sequence determiner_parse_tree new_noun_group]]]
					[parse_format '\n      noun group after_determiner parses: ' after_determiner_parses]
					[= parses [append after_determiner_parses parses]]]]]
			    [prog [parse_format '\n    found unsuccessful determiner_word agreement with noun_group question attribute.']
				  ]]]]
		  determiner_parses]]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-main_after_transitive_verb_group [sequence parse_tree]
  [let [[parses nil]]
    [let [[first_word [first sequence]]]
      [let [[pronoun_definitions [get this definitions_by_type `pronoun_word first_word]]]
	[mapc [funk [pronoun_definition]
		    [parse_format '\n  found pronoun to be in dictionary: ' first_word]
		    [if [get pronoun_definition relative_clause]
			[prog [parse_format '\n  found pronoun to be relative: ' first_word]
			      ]]]
	      pronoun_definitions]]
      [let [[noun_group_initial_parse_tree [get parse_tree new_copy]]
	    [noun_group            [new noun_group]]]
	[set noun_group object     t]
	[set noun_group object_one t]
	[have noun_group_initial_parse_tree add_child_to_type `clause noun_group]
	[let [[noun_group_parses [have this parse_sequence_as_noun_group sequence noun_group_initial_parse_tree]]]
	  [mapc [funk [noun_group_parse]
		      [let [[noun_group_parse_tree [have noun_group_parse lookup `parse_tree]]]
			[let [[new_parse_tree [get noun_group_parse_tree new_copy]]]
			  [set new_parse_tree containing_type_property `clause `transitive t]
			  [have new_parse_tree pop_to_type `clause]
			  [= parses [cons [frame parse_tree new_parse_tree]
					  parses]]]]]
		noun_group_parses]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_preposition_group [sequence parse_tree preposition_group]
  [if [get preposition_group question]
      [prog [parse_format '\n    parsing ' sequence ' as question preposition group.']
	    ]
    [prog [parse_format '\n    parsing ' sequence ' as non-question preposition group.']
	  ]]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-main_question [sequence parse_tree]
  [let [[parses nil]]
    [let [[question_parse_tree [get parse_tree new_copy]]]
      [set question_parse_tree containing_type_property `clause `question t]
      [let [[question_adjunct_parses [have this parse_sequence_as_question_adjunct_word sequence question_parse_tree]]]
	[mapc [funk [question_adjunct_parse]
		    [let [[question_adjunct_parse_tree    [have question_adjunct_parse lookup `parse_tree]]
			  [question_adjunct_rest_sequence [have question_adjunct_parse lookup `rest_sequence]]]
		      [parse_format '\n    found successful question_adjunct_word parse: ' question_adjunct_parse]
		      
		      ]]
	      question_adjunct_parses]]
      [let [[preposition_group [new preposition_group]]]
	[set preposition_group question t]
	[let [[preposition_group_parses [have this parse_sequence_as_preposition_group sequence question_parse_tree preposition_group]]]
	  [mapc [funk [preposition_group_parse]
		      [let [[preposition_group_parse_tree    [have preposition_group_parse lookup `parse_tree]]
			    [preposition_group_rest_sequence [have preposition_group_parse lookup `rest_sequence]]]
			[parse_format '\n    found successful question preposition_group parse: ' preposition_group_parse]
			
			]]
		preposition_group_parses]]]
      [let [[noun_group_initial_parse_tree [get question_parse_tree new_copy]]
	    [noun_group                    [new noun_group]]]
	[set noun_group question t]
	[have noun_group_initial_parse_tree add_child_to_type `clause noun_group]
	[let [[noun_group_parses [have this parse_sequence_as_noun_group sequence noun_group_initial_parse_tree]]]
	  [mapc [funk [noun_group_parse]
		      [let [[noun_group_parse_tree    [have noun_group_parse lookup `parse_tree]]
			    [noun_group_rest_sequence [have noun_group_parse lookup `rest_sequence]]]
			[parse_format '\n    found successful question noun_group parse: ' noun_group_parse]
			[have noun_group_parse_tree pop_to_type `clause]
			[let [[verb_group_parse_tree [get noun_group_parse_tree new_copy]]
			      [verb_group            [new verb_group]]]
			  [set verb_group not_only_auxiliary t]
			  [have verb_group_parse_tree add_child_to_type `clause verb_group]
			  [let [[verb_group_parses [have this parse_sequence_as_verb_group noun_group_rest_sequence verb_group_parse_tree]]]
			    [mapc [funk [verb_group_parse]
					[let [[verb_group_parse_tree    [have verb_group_parse lookup `parse_tree]]
					      [verb_group_rest_sequence [have verb_group_parse lookup `rest_sequence]]
					      [verb_group_verb_group    [have verb_group_parse lookup `verb_group]]]
					  [have verb_group_parse_tree pop_to_type `clause]
					  [parse_format '\n      found successful question verb_group parse: ' verb_group_parse]
					  [if [null verb_group_rest_sequence]
					      [= parses [cons verb_group_parse parses]]
					    [prog [parse_format '\n        handling rest of question clause not implemented.']
						  ]]]]
				  verb_group_parses]]]]]
		noun_group_parses]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-main_with_verb_first [sequence parse_tree]
  [let [[parses nil]]
    [let [[verb_group_initial_parse_tree [get parse_tree new_copy]]
	  [verb_group                    [new verb_group]]]
      [set verb_group imperative t]
      [have verb_group_initial_parse_tree add_child_to_type `clause verb_group]
      [let [[verb_group_parses [have this parse_sequence_as_verb_group sequence verb_group_initial_parse_tree]]]
	[mapc [funk [verb_group_parse]
		    [let [[verb_group_parse_tree    [have verb_group_parse lookup `parse_tree]]
			  [verb_group_rest_sequence [have verb_group_parse lookup `rest_sequence]]
			  [verb_word                [have verb_group_parse lookup `verb_word]]]
		      [parse_format '\n    found successful verb_group parse: ' verb_group_parse]
		      [let [[new_parse_tree [get verb_group_parse_tree new_copy]]]
			[set new_parse_tree containing_type_property `clause `imperative t]
			[if [get verb_word takes_particle]
			    [prog [parse_format '\n  verb_word takes particle.']
				  [let [[second_word [second sequence]]]
				    [let [[second_word_particles [get this type_var_value `particle_word second_word nil]]]
				      [mapc [funk [second_word_particle]
						  [parse_format '\n    found second word to be particle: ' second_word]
						  [let [[combination [append [let [[first_words [get verb_word symbols]]]
									       [if [not [or [is-type `cons first_words] [is-type `list first_words]]]
										   [cons first_words nil]
										 first_words]]
									     [cons second_word nil]]]]
						    [let [[combination_definitions [get this definitions_by_type `combination_group combination]]]
						      [mapc [funk [combination_definition]
								  [parse_format '\n      found combination to be in dictionary: ' combination]
								  [let [[particle_parses [have this parse_sequence_as_particle_word verb_group_rest_sequence new_parse_tree]]]
								    [mapc [funk [particle_parse]
										[let [[particle_parse_tree [have particle_parse lookup `parse_tree]]]
										  [parse_format '\n      found successful particle parse: ' particle_parse]
										  [let [[new_parse_tree [get particle_parse_tree new_copy]]]
										    [set new_parse_tree containing_type_property `clause `particle t]
										    [have new_parse_tree pop_to_type `clause]
										    'check all transitivity features.  (we only have transitive for combinations so far)'
										    [if [get combination_definition transitive]
											[prog [parse_format '\n      combination is transitive: ' combination]
											      'check if this verb accepts PSNG clauses as an object (we do not have this feature yet).'
											      'otherwise object must be NG or WHPS clause.'
											      [let [[after_transitive_verb_parses [have this parse_sequence_as_clause-main_after_transitive_verb_group [cddr sequence] new_parse_tree]]]
												[= parses [append after_transitive_verb_parses parses]]]]
										      [prog [parse_format '\n      combination is not transitive: ' combination]
											    
											    ]]]]]
									  particle_parses]]]
							    combination_definitions]]]]
					    second_word_particles]]]]
			  [prog [parse_format '\n  verb_word does not take particle.']
				[if [get verb_word transitive]
				    [prog [parse_format '\n  verb_word is transitive.']
					  [let [[after_transitive_verb_parses [have this parse_sequence_as_clause-main_after_transitive_verb_group verb_group_rest_sequence new_parse_tree]]]
					    [= parses [append after_transitive_verb_parses parses]]]]
				  [prog [parse_format '\n  verb_word is not transitive.']
					
					]]]]]]]
	      verb_group_parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause [sequence parse_tree clause]
  [let [[parses nil]]
    [let [[clause_parse_tree [get parse_tree new_copy]]]
      [have clause_parse_tree add_next [get clause new_copy]]
      [let [[question_parses [have this parse_sequence_as_clause-main_question sequence clause_parse_tree]]]
	[= parses [append question_parses parses]]]
      [let [[first_word [first sequence]]]
	[let [[first_word_adverbs [get this definitions_by_type `adverb_word first_word]]]
	  [mapc [funk [first_word_adverb]
		      [parse_format '\n  ' first_word ' is an adverb_word.']
		      'assume major clause begins with a single word modifier'
		      ]
		first_word_adverbs]]
	[let [[first_word_prepositions [get this definitions_by_type `preposition_word first_word]]]
	  [mapc [funk [first_word_preposition]
		      [parse_format '\n  ' first_word ' is a preposition_word.']
		      [have this parse_sequence_as_preposition_group sequence clause_parse_tree]]
		first_word_prepositions]]
	[let [[first_word_binders [get this definitions_by_type `binder_word first_word]]]
	  [mapc [funk [first_word_binder]
		      [parse_format '\n  ' first_word ' is a binder_word.']
		      [have this parse_sequence_as_bound_clause sequence clause_parse_tree]]
		first_word_binders]]
	[let [[verb_first_parses [have this parse_sequence_as_clause-main_with_verb_first sequence clause_parse_tree]]]
	  [= parses [append verb_first_parses parses]]]]]
    parses]]


'test funks'

[defunk english_language-test_parse [sequence]
  [let [[test_parses [have english_dictionary parse_sequence_as_clause sequence [new parse_tree] [new clause]]]]
    [mapc [funk [test_parse]
		[terminal_format standard-terminal   '\nenglish_language-test parse: ' test_parse]
		[let [[test_parse_tree [have test_parse lookup `parse_tree]]]
		  [terminal_format standard-terminal '\n                 serialized: ' [have test_parse_tree serialize]]
		  [have [get test_parse_tree as-graph] gview]]]
	  test_parses]]
  nil]


[defunk english_language-test []
  [english_language-test_parse `[pick up a big red butter knife]]]


