'Copyright (c) 2007-2010 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'parse_tree_node'

[deframe parse_tree_node [frame] [parse_object parent_node previous_node next_node first_child_node last_child_node]]

[deftypefunk parse_tree_node get last_node []
  [let [[node this]]
    [if next_node
	[get next_node last_node]
      [if last_child_node
	  [get last_child_node last_node]
	this]]]]

[deftypefunk parse_tree_node execute map_nodes [funk]
  [apply funk [cons this nil]]
  [let [[iter first_child_node]]
    [while iter
      [apply funk [cons iter node]]
      [= iter [get iter next_node]]]]]

[deftypefunk parse_tree_node execute insert_after [node]
  [let [[old-next_node next_node]]
    [= next_node node]
    [if old-next_node
	[set old-next_node previous_node this]
      [if parent_node
	  [set parent_node last_child_node node]]]]]

[deftypefunk parse_tree_node execute add_last [node]
  [let [[last_node [get this last_node]]]
    [have last_node insert_after node]]]

'parse_tree'

[deframe parse_tree [frame] [root_node]]

[deftypefunk parse_tree execute map_nodes [funk]
  [if root_node
      [have root_node map_nodes funk]]]

[deftypefunk parse_tree get new_copy []
  [if [null root_node]
      [new parse_tree]
    [let [[node_hash [new ptypehash]]]
      [have this map_nodes [funk [node]
				 [have node_hash add node [new parse_tree_node]]]]
      [have this map_nodes [funk [node]
				 [let [[new_node [have node_hash lookup node]]]
				   [set new_node parse_object     [get node parse_object]]
				   [set new_node parent_node      [let [[parent_node      [get node parent_node]]]      [if parent_node      [have node_hash lookup parent_node]]]]
				   [set new_node previous_node    [let [[previous_node    [get node previous_node]]]    [if previous_node    [have node_hash lookup previous_node]]]]
				   [set new_node next_node        [let [[next_node        [get node next_node]]]        [if next_node        [have node_hash lookup next_node]]]]
				   [set new_node first_child_node [let [[first_child_node [get node first_child_node]]] [if first_child_node [have node_hash lookup first_child_node]]]]
				   [set new_node last_child_node  [let [[last_child_node  [get node last_child_node]]]  [if last_child_node  [have node_hash lookup last_child_node]]]]]]]
      [let [[new_parse_tree [new parse_tree]]]
	[set new_parse_tree root_node [have node_hash lookup root_node]]
	new_parse_tree]]]]

[deftypefunk parse_tree execute add_last [parse_object]
  [let [[node [new parse_tree_node]]]
    [set node parse_object parse_object]
    [if [null root_node]
	[= root_node node]
      [have root_node add_last node]]]]


'dictionary_frame'

[deframe dictionary_frame [frame] [[symbols_hash [hash]]]]

[deftypefunk dictionary_frame get symbols_as_key [symbols]
  [if [is-type `symbol symbols]
      symbols
    [let [[symbols-as-conslist [cond [[is-type `cons   symbols] symbols]
				     [[is-type `list   symbols] [get symbols cons_cells]]
				     [t                         [error bug_type  `invalid_symbol_or_symbol_list_when_adding_word_to_dictionary_frame
								       word_type type
								       symbols   symbols]]]]]
      [let [[value [have symbols_hash lookup symbols-as-conslist]]]
	[if value
	    value
	  [prog [have symbols_hash add symbols-as-conslist symbols-as-conslist]
		symbols-as-conslist]]]]]]

[deftypefunk dictionary_frame execute add_word [type symbol features]
  [let [[word [object_type-new type]]] 
    [have word add `symbols [get this symbols_as_key symbol]]
    [mapc [funk [feature]
		[if [not [get word contains feature]]
		    [error bug_type  `invalid_feature_when_adding_word_to_dictionary_frame
			   word_type type
			   feature   feature]
		  [have word add feature t]]]
	  features]
    [have this add_type_var_value type symbol [cons word [get this type_var_value type symbol nil]]]]]

[defmetro dictionary-add_word [this type symbol features]
  `[have ,this add_word [quote ,type] [quote ,symbol] [conslist @[mapcar [funk [feature] `[quote ,feature]] features]]]]

[deftypefunk dictionary_frame get definitions_by_type [type symbol]
  [get this type_var_value type [get this symbols_as_key symbol] nil]]

[deftypefunk dictionary_frame get definitions [symbol]
  [let [[definitions nil]]
    [mapc [funk [type]
		[= definitions [append definitions [get this definitions_by_type type symbol]]]]
	  [get [get this type_ptypehash] keys]]
    definitions]]



[deftypefunk dictionary_frame execute parse_sequence_as_verb_group [sequence parse_tree verb_group]
  [let [[parses nil]]
    [terminal_format standard-terminal '\n  parsing ' sequence ' as a verb_group.']
    [if [get verb_group imperative]
	[prog [terminal_format standard-terminal '\n  parsing ' sequence ' as an imperative verb_group.']
	      [let [[first_word [first sequence]]]
		[let [[first_word_verbs [get this type_var_value `verb_word first_word nil]]]
		  [mapc [funk [first_word_verb]
			      [if [get first_word_verb Do]
				  [prog [terminal_format standard-terminal '\n  parsing ' sequence ' as an imperative verb_group with first word as a form of "do".']
					]
				[prog [if [get first_word_verb infinitive]
					  [prog [terminal_format standard-terminal '\n  parsing ' sequence ' as an imperative verb_group with first word as an infinitive verb.']
						[let [[new_parse_tree [get parse_tree new_copy]]
						      [new_verb_word  [get first_word_verb new_copy]]]
						  [set new_verb_word Main t]
						  [have new_parse_tree add_last new_verb_word]
						  [= parses [cons [frame verb_word  new_verb_word
									 verb_group [get verb_group new_copy]
									 parse_tree new_parse_tree]
								  parses]]
						  ]]
					]]]]
			first_word_verbs]]]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_preposition_group [sequence parse_tree]
  [terminal_format standard-terminal '\n  parsing ' sequence ' as a preposition_group.']
  ]

[deftypefunk dictionary_frame execute parse_sequence_as_bound_clause [sequence parse_tree]
  [terminal_format standard-terminal '\n  parsing ' sequence ' as a bound clause.']
  ]

[deftypefunk dictionary_frame execute parse_sequence_as_particle_word [sequence parse_tree]
  [let [[parses nil]]
    [terminal_format standard-terminal '\n  parsing ' sequence ' as a particle word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_particles [get this type_var_value `particle_word first_word nil]]]
	[mapc [funk [first_word_particle]
		    [terminal_format standard-terminal '\n    found first word to be particle: ' first_word]
		    [let [[new_parse_tree    [get parse_tree          new_copy]]
			  [new_particle_word [get first_word_particle new_copy]]]
		      [have new_parse_tree add_last new_particle_word]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     particle_word new_particle_word]
				      parses]]]]
	      first_word_particles]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group [sequence parse_tree noun_group]
  [terminal_format standard-terminal '\n  parsing ' sequence ' as a noun_group.']
  ]


[deftypefunk dictionary_frame execute parse_sequence_as_main_clause [sequence parse_tree clause]
  [let [[first_word [first sequence]]]
    [let [[first_word_adverbs [get this type_var_value `adverb_word first_word nil]]]
      [if first_word_adverbs
	  [mapc [funk [first_word_adverb]
		      [terminal_format standard-terminal '\n  ' first_word ' is an adverb_word.']
		      'assume major clause begins with a single word modifier'
		      ]
		first_word_adverbs]]]
    [let [[first_word_prepositions [get this type_var_value `preposition_word first_word nil]]]
      [if first_word_prepositions
	  [mapc [funk [first_word_preposition]
		      [terminal_format standard-terminal '\n  ' first_word ' is a preposition_word.']
		      [have this parse_sequence_as_preposition_group sequence parse_tree]]
		first_word_prepositions]]]
    [let [[first_word_binders [get this type_var_value `binder_word first_word nil]]]
      [if first_word_binders
	  [mapc [funk [first_word_binder]
		      [terminal_format standard-terminal '\n  ' first_word ' is a binder_word.']
		      [have this parse_sequence_as_bound_clause sequence parse_tree]]
		first_word_binders]]]
    [let [[first_word_verbs   [get this type_var_value `verb_word   first_word nil]]]
      [if first_word_verbs
	  [mapc [funk [first_word_verb]
		      [terminal_format standard-terminal '\n  ' first_word ' is a verb_word.']
		      [let [[verb_group [new verb_group]]]
			[set verb_group imperative t]
			[let [[parses [have this parse_sequence_as_verb_group sequence parse_tree verb_group]]]
			  [mapc [funk [parse]
				      [terminal_format standard-terminal '\n    found successful verb_group parse: ' parse]
				      [let [[new_clause [get clause new_copy]]]
					[set new_clause imperative t]
					[let [[verb_word [have parse lookup `verb_word]]]
					  [if [get verb_word takes_particle]
					      [prog [terminal_format standard-terminal '\n  verb_word takes particle.']
						    [let [[second_word [second sequence]]]
						      [let [[second_word_particles [get this type_var_value `particle_word second_word nil]]]
							[mapc [funk [second_word_particle]
								    [terminal_format standard-terminal '\n    found second word to be particle: ' second_word]
								    [let [[combination [list first_word second_word]]]
								      [let [[combination_definitions [get this definitions_by_type `combination_group combination]]]
									[mapc [funk [combination_definition]
										    [terminal_format standard-terminal '\n      found combination to be in dictionary: ' combination]
										    [let [[particle_parses [have this parse_sequence_as_particle_word [cdr sequence] [have parse lookup `parse_tree]]]]
										      [mapc [funk [particle_parse]
												  [terminal_format standard-terminal '\n      found successful particle parse: ' particle_parse]
												  [let [[new_clause [get clause new_copy]]]
												    [set new_clause particle t]
												    'check all transitivity features.  (we only have transitive for combinations so far)'
												    [if [get combination_definition transitive]
													[prog [terminal_format standard-terminal '\n      combination is transitive: ' combination]
													      'check if this verb accepts PSNG clauses as an object (we do not have this feature yet).'
													      'otherwise object must be NG or WHPS clause.'
													      [let [[third_word [third sequence]]]
														[let [[pronoun_definitions [get this definitions_by_type `pronoun_word third_word]]]
														  [mapc [funk [pronoun_definition]
															      [terminal_format standard-terminal '\n  found pronoun to be in dictionary: ' third_word]
															      [if [get pronoun_definition relative_clause]
																  [prog [terminal_format standard-terminal '\n  found pronoun to be relative: ' third_word]
																	]]]
															pronoun_definitions]]
														[let [[noun_group_parses [have this parse_sequence_as_noun_group [cddr sequence] [have particle_parse lookup `parse_tree] [new noun_group]]]]
														  
														  ]]]
												      [prog [terminal_format standard-terminal '\n      combination is not transitive: ' combination]
													    
													    ]]]]
											    particle_parses]]]
									      combination_definitions]]]]
							      second_word_particles]]]]
					    [prog [terminal_format standard-terminal '\n  verb_word does not take particle.']
						  ]]]]]
				parses]]]]
		first_word_verbs]]]
    ]]


'english_dictionary'

[deframe english_dictionary [dictionary_frame] []
  [new []
       [construct dictionary_frame]
       
       [dictionary-add_word this verb_word pick [takes_particle infinitive transitive]]
       
       [dictionary-add_word this particle_word up []]
       
       [dictionary-add_word this combination_group [pick up] [transitive]]
       
       [dictionary-add_word this determiner_word a [indefinite singular]]
       
       [dictionary-add_word this determiner_word the [plural singular definite]]
       
       [dictionary-add_word this noun_word knife [singular]]
       
       [dictionary-add_word this preposition_word before []]
       
       [dictionary-add_word this verb_word cut [present]]
       
       [dictionary-add_word this verb_word cutting [present ing]]
       
       [dictionary-add_word this noun_word bread [mass]]
       
       [dictionary-add_word this proper_noun_word Lauren [singular]]
       
       [dictionary-add_word this proper_noun_word Ralph [singular]]
       
       [dictionary-add_word this verb_word saw [past infinitive]]
       ]]


[defunk english_language-test []
  [have english_dictionary parse_sequence_as_main_clause `[pick up the knife] [new parse_tree] [new clause]]]


`[globalize example_major_clauses `[[pick up the knife]
				    [pick up the knife before cutting the bread]
				    [Lauren picked up the knife]
				    [Ralph saw Lauren cut the bread]]]

`[print 'hi']



[terminal_format standard-terminal '\nDefining global ' `english_dictionary ' variable!']

[globalize english_dictionary [new english_dictionary]]

