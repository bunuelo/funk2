'Copyright (c) 2007-2010 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[globalize debug_parse nil]

[defmetro parse_format [:rest exps]
  `[if debug_parse
       [terminal_format standard-terminal @exps]]]

'parse_tree_node'

[deframe parse_tree_node [frame] [parse_object parent_node previous_node next_node first_child_node last_child_node]]

[deftypefunk parse_tree_node get last_node []
  [if next_node
      [get next_node last_node]
    [if last_child_node
	[get last_child_node last_node]
      this]]]

[deftypefunk parse_tree_node execute map_nodes_forward [funk]
  [apply funk [cons this nil]]
  [if next_node
      [have next_node map_nodes_forward funk]]
  [if first_child_node
      [have first_child_node map_nodes_forward funk]]]

[deftypefunk parse_tree_node execute map_nodes_backward [funk]
  [if last_child_node
      [have last_child_node map_nodes_backward funk]]
  [if next_node
      [have next_node map_nodes_backward funk]]
  [apply funk [cons this nil]]]

[deftypefunk parse_tree_node execute map_nodes [funk]
  [have this map_nodes_forward funk]]

[deftypefunk parse_tree_node execute insert_after [node]
  [let [[old-next_node next_node]]
    [= next_node node]
    [if old-next_node
	[set old-next_node previous_node this]
      [if parent_node
	  [set parent_node last_child_node node]]]]]

[deftypefunk parse_tree_node execute add_last [node]
  [let [[last_node [get this last_node]]]
    [have last_node insert_after node]]]

[deftypefunk parse_tree_node execute serialize []
  [let [[seq nil]]
    [have this map_nodes_backward [funk [node]
					[= seq [cons [get node parse_object] seq]]]]
    seq]]

'parse_tree'

[deframe parse_tree [frame] [root_node]]

[deftypefunk parse_tree execute map_nodes [funk]
  [if root_node
      [have root_node map_nodes funk]]]

[deftypefunk parse_tree get new_copy []
  [if [null root_node]
      [new parse_tree]
    [let [[node_hash [new ptypehash]]]
      [have this map_nodes [funk [node]
				 [have node_hash add node [new parse_tree_node]]]]
      [have this map_nodes [funk [node]
				 [let [[new_node [have node_hash lookup node]]]
				   [set new_node parse_object     [get node parse_object]]
				   [set new_node parent_node      [let [[parent_node      [get node parent_node]]]      [if parent_node      [have node_hash lookup parent_node]]]]
				   [set new_node previous_node    [let [[previous_node    [get node previous_node]]]    [if previous_node    [have node_hash lookup previous_node]]]]
				   [set new_node next_node        [let [[next_node        [get node next_node]]]        [if next_node        [have node_hash lookup next_node]]]]
				   [set new_node first_child_node [let [[first_child_node [get node first_child_node]]] [if first_child_node [have node_hash lookup first_child_node]]]]
				   [set new_node last_child_node  [let [[last_child_node  [get node last_child_node]]]  [if last_child_node  [have node_hash lookup last_child_node]]]]]]]
      [let [[new_parse_tree [new parse_tree]]]
	[set new_parse_tree root_node [have node_hash lookup root_node]]
	new_parse_tree]]]]

[deftypefunk parse_tree execute add_last [parse_object]
  [let [[node [new parse_tree_node]]]
    [set node parse_object parse_object]
    [if [null root_node]
	[= root_node node]
      [have root_node add_last node]]]]

[deftypefunk parse_tree execute serialize []
  [if root_node
      [have root_node serialize]]]

'dictionary_frame'

[deframe dictionary_frame [frame] [[symbols_hash [hash]]]]

[deftypefunk dictionary_frame get symbols_as_key [symbols]
  [if [or [is-type `symbol  symbols]
	  [is-type `integer symbols]
	  [is-type `float   symbols]
	  [is-type `double  symbols]]
      symbols
    [let [[symbols-as-conslist [cond [[is-type `cons    symbols] symbols]
				     [[is-type `list    symbols] [get symbols cons_cells]]
				     [t                          [error bug_type  `invalid_symbol_or_symbol_list_when_adding_word_to_dictionary_frame
									word_type type
									symbols   symbols]]]]]
      [let [[value [have symbols_hash lookup symbols-as-conslist]]]
	[if value
	    value
	  [prog [have symbols_hash add symbols-as-conslist symbols-as-conslist]
		symbols-as-conslist]]]]]]

[deftypefunk dictionary_frame execute add_word [type symbol features]
  [let [[word [object_type-new type]]] 
    [have word add `symbols [get this symbols_as_key symbol]]
    [mapc [funk [feature]
		[if [not [get word contains feature]]
		    [error bug_type  `invalid_feature_when_adding_word_to_dictionary_frame
			   word_type type
			   feature   feature]
		  [have word add feature t]]]
	  features]
    [have this add_type_var_value type symbol [cons word [get this type_var_value type symbol nil]]]]]

[defmetro dictionary-add_word [this type symbol features]
  `[have ,this add_word [quote ,type] [quote ,symbol] [conslist @[mapcar [funk [feature] `[quote ,feature]] features]]]]

[deftypefunk dictionary_frame get definitions_by_type [type symbol]
  [let [[definitions nil]]
    [let [[key [get this symbols_as_key symbol]]]
      [= definitions [append [get this type_var_value type key nil] definitions]]
      [if [and [eq type `number_word]
	       [or [is-type `integer key]
		   [is-type `float   key]
		   [is-type `double  key]]]
	  [if [== key 1]
	      [let [[number_word [new number_word]]]
		[set number_word symbols  key]
		[set number_word singular t]
		[= definitions [cons number_word definitions]]]
	    [let [[number_word [new number_word]]]
	      [set number_word symbols key]
	      [set number_word plural  t]
	      [= definitions [cons number_word definitions]]]]]]
    definitions]]

[deftypefunk dictionary_frame get definitions [symbol]
  [let [[definitions nil]]
    [mapc [funk [type]
		[= definitions [append definitions [get this definitions_by_type type symbol]]]]
	  [get [get this type_ptypehash] keys]]
    definitions]]


[deftypefunk dictionary_frame execute parse_sequence_as_auxiliary_be_verbs [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\nauxiliary be verbs not implemented.']
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_verb_group [sequence parse_tree verb_group]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a verb_group.']
    [if [get verb_group imperative]
	[prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group.']
	      [let [[first_word [first sequence]]]
		[let [[first_word_verbs [get this definitions_by_type `verb_word first_word]]]
		  [mapc [funk [first_word_verb]
			      [if [get first_word_verb Do]
				  [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as a form of "do".']
					]
				[prog [if [get first_word_verb infinitive]
					  [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as an infinitive verb.']
						[let [[new_parse_tree [get parse_tree new_copy]]
						      [new_verb_word  [get first_word_verb new_copy]]]
						  [set new_verb_word Main t]
						  [have new_parse_tree add_last new_verb_word]
						  [= parses [cons [frame verb_word     new_verb_word
									 verb_group    [get verb_group new_copy]
									 parse_tree    new_parse_tree
									 rest_sequence [cdr sequence]]
								  parses]]
						  ]]
					[prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as not an infinitive verb.']
					      ]]]]]
			first_word_verbs]]]]
      [prog [parse_format '\n  parsing ' sequence ' as not an imperative verb_group.']
	    [let [[auxiliary_be_verbs_parses [have this parse_sequence_as_auxiliary_be_verbs sequence parse_tree]]]
	      [mapc [funk [auxiliary_be_verbs_parse]
			  [let [[auxiliary_be_verbs_parse_tree    [have auxiliary_be_verbs_parse lookup `parse_tree]]
				[auxiliary_be_verbs_rest_sequence [have auxiliary_be_verbs_parse lookup `rest_sequence]]]
			    [let [[new_verb_group [get verb_group new_copy]]]
			      [set new_verb_group be        t]
			      [set new_verb_group auxiliary t]
			      [= parses [cons [frame parse_tree    auxiliary_be_verbs_parse_tree
						     rest_sequence auxiliary_be_verbs_rest_sequence
						     verb_group    new_verb_group]
					      parses]]]]]
		    auxiliary_be_verbs_parses]]
	    ]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_preposition_group [sequence parse_tree]
  [parse_format '\n  parsing ' sequence ' as a preposition_group.']
  ]

[deftypefunk dictionary_frame execute parse_sequence_as_bound_clause [sequence parse_tree]
  [parse_format '\n  parsing ' sequence ' as a bound clause.']
  ]

[deftypefunk dictionary_frame execute parse_sequence_as_particle_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a particle word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_particles [get this definitions_by_type `particle_word first_word]]]
	[mapc [funk [first_word_particle]
		    [parse_format '\n    found first word to be a particle: ' first_word]
		    [let [[new_parse_tree    [get parse_tree          new_copy]]
			  [new_particle_word [get first_word_particle new_copy]]]
		      [have new_parse_tree add_last new_particle_word]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     particle_word new_particle_word]
				      parses]]]]
	      first_word_particles]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_determiner_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a determiner word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_determiners [get this definitions_by_type `determiner_word first_word]]]
	[let [[second_word [if [cdr sequence] [second sequence]]]]
	  [let [[first_and_second_word_determiners [if [cdr sequence] [get this definitions_by_type `determiner_word [list first_word second_word]]]]]
	    [let [[determiners [append first_word_determiners first_and_second_word_determiners]]]
	      [mapc [funk [determiner]
			  [parse_format '\n    found a determiner: ' [get determiner symbols]]
			  [let [[new_parse_tree      [get parse_tree new_copy]]
				[new_determiner_word [get determiner new_copy]]
				[rest_sequence       [if [is-type `symbol [get determiner symbols]]
							 [cdr sequence]
						       [cddr sequence]]]]
			    [have new_parse_tree add_last new_determiner_word]
			    [= parses [cons [frame parse_tree      new_parse_tree
						   determiner_word new_determiner_word
						   rest_sequence   rest_sequence]
					    parses]]]]
		    determiners]]]]]]
    parses]]

[deftypefunk determiner_word execute transfer_relevant_features_to_noun_group [noun_group]
  [set noun_group definite   [get this definite]]
  [set noun_group indefinite [get this indefinite]]
  [set noun_group quantifier [get this quantifier]]
  [set noun_group singular   [get this singular]]
  [set noun_group plural     [get this plural]]
  [set noun_group mass       [get this mass]]
  [set noun_group determiner t]]

[deftypefunk dictionary_frame execute parse_sequence_as_adjective_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an adjective word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_adjectives [get this definitions_by_type `adjective_word first_word]]]
	[mapc [funk [first_word_adjective]
		    [parse_format '\n    found first word to be an adjective: ' first_word]
		    [let [[new_parse_tree     [get parse_tree           new_copy]]
			  [new_adjective_word [get first_word_adjective new_copy]]]
		      [have new_parse_tree add_last new_adjective_word]
		      [= parses [cons [frame parse_tree     new_parse_tree
					     adjective_word new_adjective_word
					     rest_sequence  [cdr sequence]]
				      parses]]]]
	      first_word_adjectives]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_adjective_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[adjective_parses [have this parse_sequence_as_adjective_word sequence parse_tree]]]
      [mapc [funk [adjective_parse]
		  [let [[adjective_parse_tree [have adjective_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful adjective_word parse: ' adjective_parse]
		    [= parses [cons adjective_parse parses]]
		    [let [[adjective_words_parses [have this parse_sequence_as_adjective_words [cdr sequence] adjective_parse_tree]]]
		      [mapc [funk [adjective_words_parse]
				  [= parses [cons adjective_words_parse parses]]]
			    adjective_words_parses]]]]
	    adjective_parses]]
    parses]]


[deftypefunk dictionary_frame execute parse_sequence_as_classifier_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a classifier word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_classifiers [get this definitions_by_type `classifier_word first_word]]]
	[mapc [funk [first_word_classifier]
		    [parse_format '\n    found first word to be a classifier: ' first_word]
		    [let [[new_parse_tree      [get parse_tree            new_copy]]
			  [new_classifier_word [get first_word_classifier new_copy]]]
		      [have new_parse_tree add_last new_classifier_word]
		      [= parses [cons [frame parse_tree      new_parse_tree
					     classifier_word new_classifier_word
					     rest_sequence   [cdr sequence]]
				      parses]]]]
	      first_word_classifiers]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_classifier_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[classifier_parses [have this parse_sequence_as_classifier_word sequence parse_tree]]]
      [mapc [funk [classifier_parse]
		  [let [[classifier_parse_tree [have classifier_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful classifier_word parse: ' classifier_parse]
		    [= parses [cons classifier_parse parses]]
		    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words [cdr sequence] classifier_parse_tree]]]
		      [mapc [funk [classifier_words_parse]
				  [= parses [cons classifier_words_parse parses]]]
			    classifier_words_parses]]]]
	    classifier_parses]]
    parses]]


[deftypefunk dictionary_frame execute parse_sequence_as_noun_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an noun word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_nouns [get this definitions_by_type `noun_word first_word]]]
	[mapc [funk [first_word_noun]
		    [parse_format '\n    found first word to be an noun: ' first_word]
		    [let [[new_parse_tree [get parse_tree      new_copy]]
			  [new_noun_word  [get first_word_noun new_copy]]]
		      [have new_parse_tree add_last new_noun_word]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     noun_word     new_noun_word
					     rest_sequence [cdr sequence]]
				      parses]]]]
	      first_word_nouns]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_number_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a number word.']
    [let [[first_word [car sequence]]]
      [let [[number_definitions [get this definitions_by_type `number_word first_word]]]
	[mapc [funk [number_definition]
		    [parse_format '\n    found first word to be a number: ' first_word]
		    [let [[new_parse_tree [get parse_tree new_copy]]]
		      [have new_parse_tree add_last number_definition]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     rest_sequence [cdr sequence]
					     number_word   [get number_definition new_copy]]
				      parses]]]]
	      number_definitions]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_ordinal_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an ordinal word.']
    [let [[first_word [car sequence]]]
      [let [[ordinal_definitions [get this definitions_by_type `ordinal_word first_word]]]
	[mapc [funk [ordinal_definition]
		    [parse_format '\n    found first word to be an ordinal: ' first_word]
		    [let [[new_parse_tree [get parse_tree new_copy]]]
		      [have new_parse_tree add_last ordinal_definition]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     rest_sequence [cdr sequence]
					     ordinal_word  [get ordinal_definition new_copy]]
				      parses]]]]
	      ordinal_definitions]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_question_adjunct_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a question_adjunct word.']
    [let [[first_word [car sequence]]]
      [let [[question_adjunct_definitions [get this definitions_by_type `question_adjunct_word first_word]]]
	[mapc [funk [question_adjunct_definition]
		    [parse_format '\n    found first word to be a question_adjunct: ' first_word]
		    [let [[new_parse_tree [get parse_tree new_copy]]]
		      [have new_parse_tree add_last question_adjunct_definition]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     rest_sequence [cdr sequence]
					     question_adjunct_word   [get question_adjunct_definition new_copy]]
				      parses]]]]
	      question_adjunct_definitions]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_qualifiers [sequence parse_tree]
  [let [[parses nil]]
    'prep'
    'relative word (which)'
    'past participle (supported by)'
    'ing verb'
    'comparative adjective (bigger than)'
    'as (as big as)'
    'RSO clause'
    [parse_format '\n  qualifiers are not implemented.']
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_noun [sequence parse_tree noun_group]
  [let [[parses nil]]
    [if [not [null sequence]]
	[let [[qualifiers_parses [have this parse_sequence_as_qualifiers sequence parse_tree]]]
	  [mapc [funk [qualifiers_parse]
		      [= parses [cons qualifiers_parse parses]]]
		qualifiers_parses]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_classifiers [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[noun_parses [have this parse_sequence_as_noun_word sequence parse_tree]]]
      [mapc [funk [noun_parse]
		  [let [[noun_parse_tree [have noun_parse lookup `parse_tree]]
			[noun_word       [have noun_parse lookup `noun_word]]
			[rest_sequence   [have noun_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_classifiers noun_word parse: ' noun_parse]
		    [if [or [and [get noun_group singular] [get noun_word singular]]
			    [and [get noun_group plural]   [get noun_word plural]]
			    [and [get noun_group mass]     [get noun_word mass]]]
			[prog [parse_format '\n      noun group-after_classifiers noun_word agrees with singular, plural, mass qualities of noun_group.']
			      [= parses [cons noun_parse parses]]
			      [let [[after_noun_parses [have this parse_sequence_as_noun_group-after_noun rest_sequence noun_parse_tree noun_group]]]
				[mapc [funk [after_noun_parse]
					    [= parses [cons after_noun_parse parses]]]
				      after_noun_parses]]]
		      [prog [parse_format '\n      noun group-after_classifiers noun_word does not agree with singular, plural, mass qualities of noun_group.']
			    ]]]]
	    noun_parses]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_adjectives [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words sequence parse_tree]]]
      [mapc [funk [classifier_words_parse]
		  [let [[classifier_words_parse_tree    [have classifier_words_parse lookup `parse_tree]]
			[classifier_words_rest_sequence [have classifier_words_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_adjectives found successful classifier_words parse: ' classifier_words_parse]
		    [let [[after_classifiers_parses [have this parse_sequence_as_noun_group-after_classifiers classifier_words_rest_sequence classifier_words_parse_tree noun_group]]]
		      [parse_format '\n      noun group-after_determiner after_classifiers (1) parses: ' after_classifiers_parses]
		      [= parses [append after_classifiers_parses parses]]]]]
	    classifier_words_parses]]
    [let [[after_classifiers_parses [have this parse_sequence_as_noun_group-after_classifiers sequence parse_tree noun_group]]]
      [parse_format '\n      noun group-after_determiner after_classifiers (2) parses: ' after_classifiers_parses]
      [= parses [append after_classifiers_parses parses]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_number [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[adjective_words_parses [have this parse_sequence_as_adjective_words sequence parse_tree]]]
      [mapc [funk [adjective_words_parse]
		  [let [[adjective_words_parse_tree    [have adjective_words_parse lookup `parse_tree]]
			[adjective_words_rest_sequence [have adjective_words_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_determiner found successful adjective_words parse: ' adjective_words_parse]
		    [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives adjective_words_rest_sequence adjective_words_parse_tree noun_group]]]
		      [parse_format '\n      noun group-after_determiner after_adjectives (1) parses: ' after_adjectives_parses]
		      [= parses [append after_adjectives_parses parses]]]]]
	    adjective_words_parses]]
    'finally, we try interpretting without any adjectives.'
    [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives sequence parse_tree noun_group]]]
      [parse_format '\n      noun group-after_determiner after_adjectives (2) parses: ' after_adjectives_parses]
      [= parses [append after_adjectives_parses parses]]]
    parses]]



[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_ordinal [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[number_parses [have this parse_sequence_as_number_word sequence parse_tree]]]
      [mapc [funk [number_parse]
		  [let [[number_parse_tree    [have number_parse lookup `parse_tree]]
			[number_word          [have number_parse lookup `number_word]]
			[number_rest_sequence [have number_parse lookup `rest_sequence]]]
		    [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number number_rest_sequence number_parse_tree noun_group]]]
		      [parse_format '\n      noun group-after_ordinal after_number (1) parses: ' after_number_parses]
		      [= parses [append after_number_parses parses]]]]]
	    number_parses]]
    [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number sequence parse_tree noun_group]]]
      [parse_format '\n      noun group-after_ordinal after_number (2) parses: ' after_number_parses]
      [= parses [append after_number_parses parses]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_determiner [sequence parse_tree noun_group]
  [let [[parses nil]]
    [if [get noun_group definite]
	[prog [parse_format '\n    our noun group is definite: ' noun_group]
	      'because our noun group is definite, we must look for an ordinal and a number.'
	      [let [[ordinal_parses [have this parse_sequence_as_ordinal_word sequence parse_tree]]]
		[mapc [funk [ordinal_parse]
			    [let [[ordinal_parse_tree    [have ordinal_parse lookup `parse_tree]]
				  [ordinal_rest_sequence [have ordinal_parse lookup `rest_sequence]]]
			      [let [[after_ordinal_parses [have this parse_sequence_as_noun_group-after_ordinal ordinal_rest_sequence ordinal_parse_tree noun_group]]]
				[parse_format '\n      noun group-after_determiner after_ordinal parses: ' after_number_parses]
				[= parses [append after_ordinal_parses parses]]]]]
		      ordinal_parses]]
	      [let [[after_ordinal_parses [have this parse_sequence_as_noun_group-after_ordinal sequence parse_tree noun_group]]]
		[= parses [append after_ordinal_parses parses]]]]
      [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number sequence parse_tree noun_group]]]
	[parse_format '\n      noun group-after_determiner after_number parses: ' after_number_parses]
	[= parses [append after_number_parses parses]]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group [sequence parse_tree noun_group]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a noun_group.']
    [let [[first_word [first sequence]]]
      [let [[determiner_parses [have this parse_sequence_as_determiner_word sequence parse_tree]]]
	[mapc [funk [determiner_parse]
		    [let [[determiner_parse_tree    [have determiner_parse lookup `parse_tree]]
			  [determiner_word          [have determiner_parse lookup `determiner_word]]
			  [determiner_rest_sequence [have determiner_parse lookup `rest_sequence]]]
		      [if [eq [get noun_group question] [get determiner_word question]]
			  [prog [parse_format '\n    found successful determiner_word parse: ' determiner_parse]
				[let [[new_noun_group [get noun_group new_copy]]]
				  [have determiner_word transfer_relevant_features_to_noun_group new_noun_group]
				  [let [[after_determiner_parses [have this parse_sequence_as_noun_group-after_determiner determiner_rest_sequence determiner_parse_tree new_noun_group]]]
				    [parse_format '\n      noun group after_determiner parses: ' after_determiner_parses]
				    [= parses [append after_determiner_parses parses]]]]]
			[prog [parse_format '\n    found unsuccessful determiner_word agreement with noun_group question attribute.']
			      ]]]]
	      determiner_parses]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_main_clause-after_transitive_verb_group [sequence parse_tree clause]
  [let [[parses nil]]
    [let [[first_word [first sequence]]]
      [let [[pronoun_definitions [get this definitions_by_type `pronoun_word first_word]]]
	[mapc [funk [pronoun_definition]
		    [parse_format '\n  found pronoun to be in dictionary: ' first_word]
		    [if [get pronoun_definition relative_clause]
			[prog [parse_format '\n  found pronoun to be relative: ' first_word]
			      ]]]
	      pronoun_definitions]]
      [let [[noun_group [new noun_group]]]
	[set noun_group object     t]
	[set noun_group object_one t]
	[let [[noun_group_parses [have this parse_sequence_as_noun_group sequence parse_tree noun_group]]]
	  [mapc [funk [noun_group_parse]
		      [let [[noun_group_parse_tree [have noun_group_parse lookup `parse_tree]]]
			[let [[new_clause [get clause new_copy]]]
			  [set new_clause transitive t]
			  [= parses [cons [frame parse_tree noun_group_parse_tree
						 clause     new_clause]
					  parses]]]]]
		noun_group_parses]]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_preposition_group [sequence parse_tree preposition_group]
  [if [get preposition_group question]
      [prog [parse_format '\n    parsing ' sequence ' as question preposition group.']
	    ]
    [prog [parse_format '\n    parsing ' sequence ' as non-question preposition group.']
	  ]]]

[deftypefunk dictionary_frame execute parse_sequence_as_main_question_clause [sequence parse_tree clause]
  [let [[parses nil]]
    [let [[new_clause [get clause new_copy]]]
      [set new_clause question t]
      [let [[question_adjunct_parses [have this parse_sequence_as_question_adjunct_word sequence parse_tree]]]
	[mapc [funk [question_adjunct_parse]
		    [let [[question_adjunct_parse_tree    [have question_adjunct_parse lookup `parse_tree]]
			  [question_adjunct_rest_sequence [have question_adjunct_parse lookup `rest_sequence]]]
		      [parse_format '\n    found successful question_adjunct_word parse: ' question_adjunct_parse]
		      
		      ]]
	      question_adjunct_parses]]
      [let [[preposition_group [new preposition_group]]]
	[set preposition_group question t]
	[let [[preposition_group_parses [have this parse_sequence_as_preposition_group sequence parse_tree preposition_group]]]
	  [mapc [funk [preposition_group_parse]
		      [let [[preposition_group_parse_tree    [have preposition_group_parse lookup `parse_tree]]
			    [preposition_group_rest_sequence [have preposition_group_parse lookup `rest_sequence]]]
			[parse_format '\n    found successful question preposition_group parse: ' preposition_group_parse]
			
			]]
		preposition_group_parses]]]
      [let [[noun_group [new noun_group]]]
	[set noun_group question t]
	[let [[noun_group_parses [have this parse_sequence_as_noun_group sequence parse_tree noun_group]]]
	  [mapc [funk [noun_group_parse]
		      [let [[noun_group_parse_tree    [have noun_group_parse lookup `parse_tree]]
			    [noun_group_rest_sequence [have noun_group_parse lookup `rest_sequence]]]
			[parse_format '\n    found successful question noun_group parse: ' noun_group_parse]
			[let [[verb_group [new verb_group]]]
			  [set verb_group not_only_auxiliary t]
			  [let [[verb_group_parses [have this parse_sequence_as_verb_group noun_group_rest_sequence noun_group_parse_tree verb_group]]]
			    [mapc [funk [verb_group_parse]
					[parse_format '\n      found successful question verb_group parse: ' verb_group_parse]
					
					]
				  verb_group_parses]]]]]
		noun_group_parses]]]
      ]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_main_clause [sequence parse_tree clause]
  [let [[parses nil]]
    [let [[question_parses [have this parse_sequence_as_main_question_clause sequence parse_tree clause]]]
      [= parses [append question_parses parses]]]
    [let [[first_word [first sequence]]]
      [let [[first_word_adverbs [get this definitions_by_type `adverb_word first_word]]]
	[if first_word_adverbs
	    [mapc [funk [first_word_adverb]
			[parse_format '\n  ' first_word ' is an adverb_word.']
			'assume major clause begins with a single word modifier'
			]
		  first_word_adverbs]]]
      [let [[first_word_prepositions [get this definitions_by_type `preposition_word first_word]]]
	[if first_word_prepositions
	    [mapc [funk [first_word_preposition]
			[parse_format '\n  ' first_word ' is a preposition_word.']
			[have this parse_sequence_as_preposition_group sequence parse_tree]]
		  first_word_prepositions]]]
      [let [[first_word_binders [get this definitions_by_type `binder_word first_word]]]
	[if first_word_binders
	    [mapc [funk [first_word_binder]
			[parse_format '\n  ' first_word ' is a binder_word.']
			[have this parse_sequence_as_bound_clause sequence parse_tree]]
		  first_word_binders]]]
      [let [[first_word_verbs [get this definitions_by_type `verb_word first_word]]]
	[if first_word_verbs
	    [mapc [funk [first_word_verb]
			[parse_format '\n  ' first_word ' is a verb_word.']
			[let [[verb_group [new verb_group]]]
			  [set verb_group imperative t]
			  [let [[verb_group_parses [have this parse_sequence_as_verb_group sequence parse_tree verb_group]]]
			    [mapc [funk [verb_group_parse]
					[let [[verb_group_parse_tree    [have verb_group_parse lookup `parse_tree]]
					      [verb_group_rest_sequence [have verb_group_parse lookup `rest_sequence]]]
					  [parse_format '\n    found successful verb_group parse: ' verb_group_parse]
					  [let [[new_clause [get clause new_copy]]]
					    [set new_clause imperative t]
					    [let [[verb_word [have verb_group_parse lookup `verb_word]]]
					      [if [get verb_word takes_particle]
						  [prog [parse_format '\n  verb_word takes particle.']
							[let [[second_word [second sequence]]]
							  [let [[second_word_particles [get this type_var_value `particle_word second_word nil]]]
							    [mapc [funk [second_word_particle]
									[parse_format '\n    found second word to be particle: ' second_word]
									[let [[combination [list first_word second_word]]]
									  [let [[combination_definitions [get this definitions_by_type `combination_group combination]]]
									    [mapc [funk [combination_definition]
											[parse_format '\n      found combination to be in dictionary: ' combination]
											[let [[particle_parses [have this parse_sequence_as_particle_word verb_group_rest_sequence verb_group_parse_tree]]]
											  [mapc [funk [particle_parse]
												      [let [[particle_parse_tree [have particle_parse lookup `parse_tree]]]
													[parse_format '\n      found successful particle parse: ' particle_parse]
													[let [[new_clause [get clause new_copy]]]
													  [set new_clause particle t]
													  'check all transitivity features.  (we only have transitive for combinations so far)'
													  [if [get combination_definition transitive]
													      [prog [parse_format '\n      combination is transitive: ' combination]
														    'check if this verb accepts PSNG clauses as an object (we do not have this feature yet).'
														    'otherwise object must be NG or WHPS clause.'
														    [let [[after_transitive_verb_parses [have this parse_sequence_as_main_clause-after_transitive_verb_group [cddr sequence] particle_parse_tree new_clause]]]
														      [= parses [append after_transitive_verb_parses parses]]]]
													    [prog [parse_format '\n      combination is not transitive: ' combination]
														  
														  ]]]]]
												particle_parses]]]
										  combination_definitions]]]]
								  second_word_particles]]]]
						[prog [parse_format '\n  verb_word does not take particle.']
						      [if [get verb_word transitive]
							  [prog [parse_format '\n  verb_word is transitive.']
								[let [[after_transitive_verb_parses [have this parse_sequence_as_main_clause-after_transitive_verb_group verb_group_rest_sequence verb_group_parse_tree new_clause]]]
								  [= parses [append after_transitive_verb_parses parses]]]]
							[prog [parse_format '\n  verb_word is not transitive.']
							      
							      ]]]]]]]]
				  verb_group_parses]]]]
		  first_word_verbs]]]]
    parses]]


'english_dictionary'

[deframe english_dictionary [dictionary_frame] []
  [new []
       [construct dictionary_frame]
       
       [dictionary-add_word this determiner_word a          [indefinite singular]]
       [dictionary-add_word this determiner_word the        [definite singular plural mass]]
       [dictionary-add_word this determiner_word some       [definite plural mass]]
       [dictionary-add_word this determiner_word all        [plural quantifier]]
       [dictionary-add_word this determiner_word any        [singular plural quantifier indefinite]]
       [dictionary-add_word this determiner_word both       [quantifier definite plural]] 'has special both-and form.'
       [dictionary-add_word this determiner_word which      [question singular plural]]
       [dictionary-add_word this determiner_word what       [question singular plural]]
       [dictionary-add_word this determiner_word [how many] [question plural]]
       
       [dictionary-add_word this noun_word knife         [singular]]
       [dictionary-add_word this noun_word knives        [plural]]
       [dictionary-add_word this noun_word bread         [mass]]
       [dictionary-add_word this noun_word butter        [mass]]
       [dictionary-add_word this noun_word refrigerator  [singular]]
       [dictionary-add_word this noun_word refrigerators [plural]]
       [dictionary-add_word this noun_word fridge        [singular]]
       [dictionary-add_word this noun_word fridges       [plural]]
       [dictionary-add_word this noun_word kitchen       [singular]]
       [dictionary-add_word this noun_word kitchens      [plural]]
       [dictionary-add_word this noun_word counter       [singular]]
       [dictionary-add_word this noun_word counters      [plural]]
       [dictionary-add_word this noun_word slice         [singular]]
       [dictionary-add_word this noun_word slices        [plural]]
       [dictionary-add_word this noun_word toast         [singular]]
       [dictionary-add_word this noun_word piece         [singular]]
       [dictionary-add_word this noun_word pieces        [plural]]
       [dictionary-add_word this noun_word loaf          [singular]]
       [dictionary-add_word this noun_word loaves        [plural]]
       
       [dictionary-add_word this classifier_word butter  []]
       [dictionary-add_word this classifier_word kitchen []]
       
       'these combinations are not currently used by the parser.'
       [dictionary-add_word this combination_group [butter knife]    []]
       [dictionary-add_word this combination_group [kitchen counter] []]
       
       [dictionary-add_word this proper_noun_word Lauren [singular]]
       [dictionary-add_word this proper_noun_word Ralph  [singular]]
       
       [dictionary-add_word this adjective_word big   []]
       [dictionary-add_word this adjective_word small []]
       [dictionary-add_word this adjective_word sharp []]
       [dictionary-add_word this adjective_word long  []]
       [dictionary-add_word this adjective_word short []]
       [dictionary-add_word this adjective_word red   []]
       [dictionary-add_word this adjective_word blue  []]
       [dictionary-add_word this adjective_word green []]
       
       [dictionary-add_word this preposition_word of     []]
       [dictionary-add_word this preposition_word before []]
       
       [dictionary-add_word this verb_word cut     [infinitive present transitive]]
       [dictionary-add_word this verb_word cutting [present ing]]
       [dictionary-add_word this verb_word pick    [infinitive takes_particle transitive]]
       [dictionary-add_word this verb_word saw     [infinitive past transitive]]
       [dictionary-add_word this verb_word walk    [infinitive present]]
       [dictionary-add_word this verb_word is      [be third_person_singular present infinitive]]
       [dictionary-add_word this verb_word are     [be plural present infinitive]]
       [dictionary-add_word this verb_word was     [be third_person_singular first_person_singular past infinitive]]
       [dictionary-add_word this verb_word were    [be plural past infinitive]]
       
       [dictionary-add_word this particle_word up []]
       
       'these combinations are used by the parser to recognize special particle accepting verbs.'
       [dictionary-add_word this combination_group [pick up] [transitive]]
       
       'all Funk2 number objects are recognized as number words, but ones listed here are the only ones recognized with English symbolic names.'
       [dictionary-add_word this number_word one   [singular]]
       [dictionary-add_word this number_word two   [plural]]
       [dictionary-add_word this number_word three [plural]]
       [dictionary-add_word this number_word four  [plural]]
       [dictionary-add_word this number_word five  [plural]]
       [dictionary-add_word this number_word six   [plural]]
       [dictionary-add_word this number_word seven [plural]]
       [dictionary-add_word this number_word eight [plural]]
       [dictionary-add_word this number_word nine  [plural]]
       [dictionary-add_word this number_word ten   [plural]]
       
       [dictionary-add_word this ordinal_word first   []]
       [dictionary-add_word this ordinal_word second  []]
       [dictionary-add_word this ordinal_word third   []]
       [dictionary-add_word this ordinal_word fourth  []]
       [dictionary-add_word this ordinal_word fifth   []]
       [dictionary-add_word this ordinal_word sixth   []]
       [dictionary-add_word this ordinal_word seventh []]
       [dictionary-add_word this ordinal_word eighth  []]
       [dictionary-add_word this ordinal_word ninth   []]
       [dictionary-add_word this ordinal_word tenth   []]
       
       [dictionary-add_word this question_adjunct_word how   []]
       [dictionary-add_word this question_adjunct_word when  []]
       [dictionary-add_word this question_adjunct_word where []]
       [dictionary-add_word this question_adjunct_word why   []]
       
       [dictionary-add_word this preposition_word above      []]
       [dictionary-add_word this preposition_word behind     []]
       [dictionary-add_word this preposition_word below      []]
       [dictionary-add_word this preposition_word beneath    []]
       [dictionary-add_word this preposition_word beside     []]
       [dictionary-add_word this preposition_word by         []]
       [dictionary-add_word this preposition_word from       []]
       [dictionary-add_word this preposition_word in         []]
       [dictionary-add_word this preposition_word inside     []]
       [dictionary-add_word this preposition_word into       []]
       [dictionary-add_word this preposition_word of         []]
       [dictionary-add_word this preposition_word on         []]
       [dictionary-add_word this preposition_word onto       []]
       [dictionary-add_word this preposition_word over       []]
       [dictionary-add_word this preposition_word to         []]
       [dictionary-add_word this preposition_word under      []]
       [dictionary-add_word this preposition_word underneath []]
       [dictionary-add_word this preposition_word with       []]
       
       [dictionary-add_word this combination_group [in back of]  [preposition]]
       [dictionary-add_word this combination_group [in front of] [preposition]]
       [dictionary-add_word this combination_group [inside of]   [preposition]]
       [dictionary-add_word this combination_group [on top of]   [preposition]]
       [dictionary-add_word this combination_group [out of]      [preposition]]
       
       ]]


[defunk english_language-test_parse [sequence]
  [let [[test_parses [have english_dictionary parse_sequence_as_main_clause sequence [new parse_tree] [new clause]]]]
    [mapc [funk [test_parse]
		[terminal_format standard-terminal   '\nenglish_language-test parse: ' test_parse]
		[let [[test_parse_tree [have test_parse lookup `parse_tree]]]
		  [terminal_format standard-terminal '\n                 serialized: ' [have test_parse_tree serialize]]]]
	  test_parses]
    nil]]


[defunk english_language-test []
  [english_language-test_parse `[pick up a big red butter knife]]]


`[globalize example_major_clauses `[[pick up the knife]
				    [pick up the knife before cutting the bread]
				    [Lauren picked up the knife]
				    [Ralph saw Lauren cut the bread]]]

`[print 'hi']



[terminal_format standard-terminal '\nDefining global ' `english_dictionary ' variable!']

[globalize english_dictionary [new english_dictionary]]

