'Copyright (c) 2007-2010 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[globalize debug_parse nil]

[defmetro parse_format [:rest exps]
  [if debug_parse
      `[terminal_format standard-terminal @exps]]]

'parse_tree_node'

[deframe parse_tree_node [frame] [parse_object parent_node previous_node next_node first_child_node last_child_node]]

[deftypefunk parse_tree_node get last_node []
  [if next_node
      [get next_node last_node]
    [if last_child_node
	[get last_child_node last_node]
      this]]]

[deftypefunk parse_tree_node execute map_nodes [funk]
  [apply funk [cons this nil]]
  [if next_node
      [have next_node map_nodes funk]]
  [if first_child_node
      [have first_child_node map_nodes funk]]]

[deftypefunk parse_tree_node execute insert_after [node]
  [let [[old-next_node next_node]]
    [= next_node node]
    [if old-next_node
	[set old-next_node previous_node this]
      [if parent_node
	  [set parent_node last_child_node node]]]]]

[deftypefunk parse_tree_node execute add_last [node]
  [let [[last_node [get this last_node]]]
    [have last_node insert_after node]]]

'parse_tree'

[deframe parse_tree [frame] [root_node]]

[deftypefunk parse_tree execute map_nodes [funk]
  [if root_node
      [have root_node map_nodes funk]]]

[deftypefunk parse_tree get new_copy []
  [if [null root_node]
      [new parse_tree]
    [let [[node_hash [new ptypehash]]]
      [have this map_nodes [funk [node]
				 [have node_hash add node [new parse_tree_node]]]]
      [have this map_nodes [funk [node]
				 [let [[new_node [have node_hash lookup node]]]
				   [set new_node parse_object     [get node parse_object]]
				   [set new_node parent_node      [let [[parent_node      [get node parent_node]]]      [if parent_node      [have node_hash lookup parent_node]]]]
				   [set new_node previous_node    [let [[previous_node    [get node previous_node]]]    [if previous_node    [have node_hash lookup previous_node]]]]
				   [set new_node next_node        [let [[next_node        [get node next_node]]]        [if next_node        [have node_hash lookup next_node]]]]
				   [set new_node first_child_node [let [[first_child_node [get node first_child_node]]] [if first_child_node [have node_hash lookup first_child_node]]]]
				   [set new_node last_child_node  [let [[last_child_node  [get node last_child_node]]]  [if last_child_node  [have node_hash lookup last_child_node]]]]]]]
      [let [[new_parse_tree [new parse_tree]]]
	[set new_parse_tree root_node [have node_hash lookup root_node]]
	new_parse_tree]]]]

[deftypefunk parse_tree execute add_last [parse_object]
  [let [[node [new parse_tree_node]]]
    [set node parse_object parse_object]
    [if [null root_node]
	[= root_node node]
      [have root_node add_last node]]]]


'dictionary_frame'

[deframe dictionary_frame [frame] [[symbols_hash [hash]]]]

[deftypefunk dictionary_frame get symbols_as_key [symbols]
  [if [is-type `symbol symbols]
      symbols
    [let [[symbols-as-conslist [cond [[is-type `cons   symbols] symbols]
				     [[is-type `list   symbols] [get symbols cons_cells]]
				     [t                         [error bug_type  `invalid_symbol_or_symbol_list_when_adding_word_to_dictionary_frame
								       word_type type
								       symbols   symbols]]]]]
      [let [[value [have symbols_hash lookup symbols-as-conslist]]]
	[if value
	    value
	  [prog [have symbols_hash add symbols-as-conslist symbols-as-conslist]
		symbols-as-conslist]]]]]]

[deftypefunk dictionary_frame execute add_word [type symbol features]
  [let [[word [object_type-new type]]] 
    [have word add `symbols [get this symbols_as_key symbol]]
    [mapc [funk [feature]
		[if [not [get word contains feature]]
		    [error bug_type  `invalid_feature_when_adding_word_to_dictionary_frame
			   word_type type
			   feature   feature]
		  [have word add feature t]]]
	  features]
    [have this add_type_var_value type symbol [cons word [get this type_var_value type symbol nil]]]]]

[defmetro dictionary-add_word [this type symbol features]
  `[have ,this add_word [quote ,type] [quote ,symbol] [conslist @[mapcar [funk [feature] `[quote ,feature]] features]]]]

[deftypefunk dictionary_frame get definitions_by_type [type symbol]
  [get this type_var_value type [get this symbols_as_key symbol] nil]]

[deftypefunk dictionary_frame get definitions [symbol]
  [let [[definitions nil]]
    [mapc [funk [type]
		[= definitions [append definitions [get this definitions_by_type type symbol]]]]
	  [get [get this type_ptypehash] keys]]
    definitions]]



[deftypefunk dictionary_frame execute parse_sequence_as_verb_group [sequence parse_tree verb_group]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a verb_group.']
    [if [get verb_group imperative]
	[prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group.']
	      [let [[first_word [first sequence]]]
		[let [[first_word_verbs [get this type_var_value `verb_word first_word nil]]]
		  [mapc [funk [first_word_verb]
			      [if [get first_word_verb Do]
				  [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as a form of "do".']
					]
				[prog [if [get first_word_verb infinitive]
					  [prog [parse_format '\n  parsing ' sequence ' as an imperative verb_group with first word as an infinitive verb.']
						[let [[new_parse_tree [get parse_tree new_copy]]
						      [new_verb_word  [get first_word_verb new_copy]]]
						  [set new_verb_word Main t]
						  [have new_parse_tree add_last new_verb_word]
						  [= parses [cons [frame verb_word  new_verb_word
									 verb_group [get verb_group new_copy]
									 parse_tree new_parse_tree]
								  parses]]
						  ]]
					]]]]
			first_word_verbs]]]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_preposition_group [sequence parse_tree]
  [parse_format '\n  parsing ' sequence ' as a preposition_group.']
  ]

[deftypefunk dictionary_frame execute parse_sequence_as_bound_clause [sequence parse_tree]
  [parse_format '\n  parsing ' sequence ' as a bound clause.']
  ]

[deftypefunk dictionary_frame execute parse_sequence_as_particle_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a particle word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_particles [get this type_var_value `particle_word first_word nil]]]
	[mapc [funk [first_word_particle]
		    [parse_format '\n    found first word to be a particle: ' first_word]
		    [let [[new_parse_tree    [get parse_tree          new_copy]]
			  [new_particle_word [get first_word_particle new_copy]]]
		      [have new_parse_tree add_last new_particle_word]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     particle_word new_particle_word]
				      parses]]]]
	      first_word_particles]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_determiner_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a determiner word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_determiners [get this type_var_value `determiner_word first_word nil]]]
	[mapc [funk [first_word_determiner]
		    [parse_format '\n    found first word to be a determiner: ' first_word]
		    [let [[new_parse_tree      [get parse_tree            new_copy]]
			  [new_determiner_word [get first_word_determiner new_copy]]]
		      [have new_parse_tree add_last new_determiner_word]
		      [= parses [cons [frame parse_tree      new_parse_tree
					     determiner_word new_determiner_word]
				      parses]]]]
	      first_word_determiners]]]
    parses]]

[deftypefunk determiner_word execute transfer_relevant_features_to_noun_group [noun_group]
  [set noun_group definite   [get this definite]]
  [set noun_group indefinite [get this indefinite]]
  [set noun_group quantifier [get this quantifier]]
  [set noun_group singular   [get this singular]]
  [set noun_group plural     [get this plural]]
  [set noun_group determiner t]]

[deftypefunk dictionary_frame execute parse_sequence_as_adjective_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an adjective word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_adjectives [get this type_var_value `adjective_word first_word nil]]]
	[mapc [funk [first_word_adjective]
		    [parse_format '\n    found first word to be an adjective: ' first_word]
		    [let [[new_parse_tree     [get parse_tree           new_copy]]
			  [new_adjective_word [get first_word_adjective new_copy]]]
		      [have new_parse_tree add_last new_adjective_word]
		      [= parses [cons [frame parse_tree     new_parse_tree
					     adjective_word new_adjective_word
					     rest_sequence  [cdr sequence]]
				      parses]]]]
	      first_word_adjectives]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_adjective_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[adjective_parses [have this parse_sequence_as_adjective_word sequence parse_tree]]]
      [mapc [funk [adjective_parse]
		  [let [[adjective_parse_tree [have adjective_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful adjective_word parse: ' adjective_parse]
		    [= parses [cons adjective_parse parses]]
		    [let [[adjective_words_parses [have this parse_sequence_as_adjective_words [cdr sequence] adjective_parse_tree]]]
		      [mapc [funk [adjective_words_parse]
				  [= parses [cons adjective_words_parse parses]]]
			    adjective_words_parses]]]]
	    adjective_parses]]
    parses]]


[deftypefunk dictionary_frame execute parse_sequence_as_classifier_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an classifier word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_classifiers [get this type_var_value `classifier_word first_word nil]]]
	[mapc [funk [first_word_classifier]
		    [parse_format '\n    found first word to be an classifier: ' first_word]
		    [let [[new_parse_tree      [get parse_tree            new_copy]]
			  [new_classifier_word [get first_word_classifier new_copy]]]
		      [have new_parse_tree add_last new_classifier_word]
		      [= parses [cons [frame parse_tree      new_parse_tree
					     classifier_word new_classifier_word
					     rest_sequence   [cdr sequence]]
				      parses]]]]
	      first_word_classifiers]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_classifier_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[classifier_parses [have this parse_sequence_as_classifier_word sequence parse_tree]]]
      [mapc [funk [classifier_parse]
		  [let [[classifier_parse_tree [have classifier_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful classifier_word parse: ' classifier_parse]
		    [= parses [cons classifier_parse parses]]
		    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words [cdr sequence] classifier_parse_tree]]]
		      [mapc [funk [classifier_words_parse]
				  [= parses [cons classifier_words_parse parses]]]
			    classifier_words_parses]]]]
	    classifier_parses]]
    parses]]


[deftypefunk dictionary_frame execute parse_sequence_as_noun_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an noun word.']
    [let [[first_word [first sequence]]]
      [let [[first_word_nouns [get this type_var_value `noun_word first_word nil]]]
	[mapc [funk [first_word_noun]
		    [parse_format '\n    found first word to be an noun: ' first_word]
		    [let [[new_parse_tree [get parse_tree      new_copy]]
			  [new_noun_word  [get first_word_noun new_copy]]]
		      [have new_parse_tree add_last new_noun_word]
		      [= parses [cons [frame parse_tree    new_parse_tree
					     noun_word     new_noun_word
					     rest_sequence [cdr sequence]]
				      parses]]]]
	      first_word_nouns]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_classifiers [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[noun_parses [have this parse_sequence_as_noun_word sequence parse_tree]]]
      [= parses [append noun_parses parses]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_adjectives [sequence parse_tree noun_group]
  [let [[parses nil]]
    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words sequence parse_tree]]]
      [mapc [funk [classifier_words_parse]
		  [let [[classifier_words_parse_tree    [have classifier_words_parse lookup `parse_tree]]
			[classifier_words_rest_sequence [have classifier_words_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group found successful classifier_words parse: ' classifier_words_parse]
		    [let [[after_classifiers_parses [have this parse_sequence_as_noun_group-after_classifiers classifier_words_rest_sequence classifier_words_parse_tree noun_group]]]
		      [= parses [append after_classifiers_parses parses]]]]]
	    classifier_words_parses]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group-after_determiner [sequence parse_tree noun_group]
  [let [[parses nil]]
    [if [get noun_group indefinite]
	[prog [parse_format '\n    our noun group is indefinite: ' noun_group]
	      'because our noun group is indefinite, we can skip looking for a number or an ordinal.'
	      [let [[adjective_words_parses [have this parse_sequence_as_adjective_words sequence parse_tree]]]
		[mapc [funk [adjective_words_parse]
			    [let [[adjective_words_parse_tree    [have adjective_words_parse lookup `parse_tree]]
				  [adjective_words_rest_sequence [have adjective_words_parse lookup `rest_sequence]]]
			      [parse_format '\n      noun group found successful after_determiner parse: ' adjective_words_parse]
			      [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives adjective_words_rest_sequence adjective_words_parse_tree noun_group]]]
				[= parses [append after_adjectives_parses parses]]]]]
		      adjective_words_parses]]
	      'finally, we try interpretting without any adjectives.'
	      [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives sequence parse_tree noun_group]]]
		[= parses [append after_adjectives_parses parses]]]]
      [prog [parse_format '\n    our noun group is not indefinite: ' noun_group]
	    'because our noun group is not indefinite, we must look for a number and an ordinal.'
	    
	    ]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_noun_group [sequence parse_tree noun_group]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a noun_group.']
    [let [[first_word [first sequence]]]
      [let [[determiner_definitions [get this definitions_by_type `determiner_word first_word]]]
	[if determiner_definitions
	    [prog [parse_format '\n    found first word to be a determiner: ' first_word]
		  [let [[determiner_parses [have this parse_sequence_as_determiner_word sequence parse_tree]]]
		    [mapc [funk [determiner_parse]
				[let [[determiner_parse_tree [have determiner_parse lookup `parse_tree]]
				      [determiner_word       [have determiner_parse lookup `determiner_word]]]
				  [parse_format '\n    found successful determiner_word parse: ' determiner_parse]
				  [let [[new_noun_group [get noun_group new_copy]]]
				    [have determiner_word transfer_relevant_features_to_noun_group new_noun_group]
				    [let [[after_determiner_parses [have this parse_sequence_as_noun_group-after_determiner [cdr sequence] determiner_parse_tree new_noun_group]]]
				      [= parses [append after_determiner_parses parses]]]]]]
			  determiner_parses]]]
	  [prog [parse_format '\n    found first word to not be a determiner: ' first_word]
		
		]]]]
    parses]]

[deftypefunk dictionary_frame execute parse_sequence_as_main_clause [sequence parse_tree clause]
  [let [[parses nil]]
    [let [[first_word [first sequence]]]
      [let [[first_word_adverbs [get this type_var_value `adverb_word first_word nil]]]
	[if first_word_adverbs
	    [mapc [funk [first_word_adverb]
			[parse_format '\n  ' first_word ' is an adverb_word.']
			'assume major clause begins with a single word modifier'
			]
		  first_word_adverbs]]]
      [let [[first_word_prepositions [get this type_var_value `preposition_word first_word nil]]]
	[if first_word_prepositions
	    [mapc [funk [first_word_preposition]
			[parse_format '\n  ' first_word ' is a preposition_word.']
			[have this parse_sequence_as_preposition_group sequence parse_tree]]
		  first_word_prepositions]]]
      [let [[first_word_binders [get this type_var_value `binder_word first_word nil]]]
	[if first_word_binders
	    [mapc [funk [first_word_binder]
			[parse_format '\n  ' first_word ' is a binder_word.']
			[have this parse_sequence_as_bound_clause sequence parse_tree]]
		  first_word_binders]]]
      [let [[first_word_verbs   [get this type_var_value `verb_word   first_word nil]]]
	[if first_word_verbs
	    [mapc [funk [first_word_verb]
			[parse_format '\n  ' first_word ' is a verb_word.']
			[let [[verb_group [new verb_group]]]
			  [set verb_group imperative t]
			  [let [[parses [have this parse_sequence_as_verb_group sequence parse_tree verb_group]]]
			    [mapc [funk [parse]
					[parse_format '\n    found successful verb_group parse: ' parse]
					[let [[new_clause [get clause new_copy]]]
					  [set new_clause imperative t]
					  [let [[verb_word [have parse lookup `verb_word]]]
					    [if [get verb_word takes_particle]
						[prog [parse_format '\n  verb_word takes particle.']
						      [let [[second_word [second sequence]]]
							[let [[second_word_particles [get this type_var_value `particle_word second_word nil]]]
							  [mapc [funk [second_word_particle]
								      [parse_format '\n    found second word to be particle: ' second_word]
								      [let [[combination [list first_word second_word]]]
									[let [[combination_definitions [get this definitions_by_type `combination_group combination]]]
									  [mapc [funk [combination_definition]
										      [parse_format '\n      found combination to be in dictionary: ' combination]
										      [let [[particle_parses [have this parse_sequence_as_particle_word [cdr sequence] [have parse lookup `parse_tree]]]]
											[mapc [funk [particle_parse]
												    [parse_format '\n      found successful particle parse: ' particle_parse]
												    [let [[new_clause [get clause new_copy]]]
												      [set new_clause particle t]
												      'check all transitivity features.  (we only have transitive for combinations so far)'
												      [if [get combination_definition transitive]
													  [prog [parse_format '\n      combination is transitive: ' combination]
														'check if this verb accepts PSNG clauses as an object (we do not have this feature yet).'
														'otherwise object must be NG or WHPS clause.'
														[let [[third_word [third sequence]]]
														  [let [[pronoun_definitions [get this definitions_by_type `pronoun_word third_word]]]
														    [mapc [funk [pronoun_definition]
																[parse_format '\n  found pronoun to be in dictionary: ' third_word]
																[if [get pronoun_definition relative_clause]
																    [prog [parse_format '\n  found pronoun to be relative: ' third_word]
																	  ]]]
															  pronoun_definitions]]
														  [let [[noun_group [new noun_group]]]
														    [set noun_group object     t]
														    [set noun_group object_one t]
														    [let [[noun_group_parses [have this parse_sequence_as_noun_group [cddr sequence] [have particle_parse lookup `parse_tree] noun_group]]]
														      [= parses [append noun_group_parses parses]]
														      ]]]]
													[prog [parse_format '\n      combination is not transitive: ' combination]
													      
													      ]]]]
											      particle_parses]]]
										combination_definitions]]]]
								second_word_particles]]]]
					      [prog [parse_format '\n  verb_word does not take particle.']
						    ]]]]]
				  parses]]]]
		  first_word_verbs]]]]
    parses]]


'english_dictionary'

[deframe english_dictionary [dictionary_frame] []
  [new []
       [construct dictionary_frame]
       
       [dictionary-add_word this verb_word pick [takes_particle infinitive transitive]]
       
       [dictionary-add_word this particle_word up []]
       
       [dictionary-add_word this combination_group [pick up] [transitive]]
       
       [dictionary-add_word this determiner_word a [indefinite singular]]
       
       [dictionary-add_word this determiner_word the [plural singular definite]]
       
       [dictionary-add_word this classifier_word butter []]
       
       [dictionary-add_word this noun_word butter [mass]]
       
       [dictionary-add_word this noun_word knife [singular]]
       
       [dictionary-add_word this combination_group [butter knife] []]
       
       [dictionary-add_word this adjective_word big []]
       
       [dictionary-add_word this adjective_word red []]
       
       [dictionary-add_word this preposition_word before []]
       
       [dictionary-add_word this verb_word cut [present]]
       
       [dictionary-add_word this verb_word cutting [present ing]]
       
       [dictionary-add_word this noun_word bread [mass]]
       
       [dictionary-add_word this proper_noun_word Lauren [singular]]
       
       [dictionary-add_word this proper_noun_word Ralph [singular]]
       
       [dictionary-add_word this verb_word saw [past infinitive]]
       ]]


[defunk english_language-test []
  [have english_dictionary parse_sequence_as_main_clause `[pick up a big red butter knife] [new parse_tree] [new clause]]]


`[globalize example_major_clauses `[[pick up the knife]
				    [pick up the knife before cutting the bread]
				    [Lauren picked up the knife]
				    [Ralph saw Lauren cut the bread]]]

`[print 'hi']



[terminal_format standard-terminal '\nDefining global ' `english_dictionary ' variable!']

[globalize english_dictionary [new english_dictionary]]

