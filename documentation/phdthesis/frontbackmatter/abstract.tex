%*******************************************************
% Abstract
%*******************************************************
%\renewcommand{\abstractname}{Abstract}
\pdfbookmark[1]{Abstract}{Abstract}
\begingroup
\let\clearpage\relax
\let\cleardoublepage\relax
\let\cleardoublepage\relax

\chapter*{Abstract}

A system built on a layered reflective cognitive architecture presents
many novel and difficult software engineering problems.  Some of these
problems can be ameliorated by erecting the system on a substrate that
implicitly supports tracing of results and behavior of the system to
the data and through the procedures that produced those results and
that behavior.  Good traces make the system accountable; it enables
the analysis of success and failure, and thus enhances the ability to
learn from mistakes.

I have constructed just such a substrate.  It provides for general
parallelism and concurrency, while supporting the automatic collection
of audit trails for all processes, including the processes that
analyze audit trails.  My system natively supports a Lisp-like
language.  In such a language, as in machine language, a program is
data that can be easily manipulated by a program.  This makes it
easier for a user or an automatic procedure to read, edit, and write
programs as they are debugged.

Here, I build and demonstrate an example of reflective problem solving
in a block building toy problem domain.  I then apply my approach to a
simulation of life in a rigidbody physical environment in order to
show scalability to non-trivial problem domains.  In my demonstration
multiple agents can learn from experience of success or failure or by
being explicitly taught by other agents, including the user.  In my
demonstration I show how procedurally traced memory can be used to
assign credit to those deliberative processes that are responsible for
the failure, facilitating learning how to better plan for these types
of problems in the future.

\endgroup

\vfill

