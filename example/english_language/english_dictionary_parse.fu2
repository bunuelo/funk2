'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[globalize debug_parse nil]

[defmetro parse_format [:rest exps]
  `[if debug_parse
       [terminal_format standard-terminal @exps]]]



'dictionary frame parsing commands'

[deftypefunk english_dictionary execute parse_sequence_as_preposition_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parse_sequence_as_preposition_word: parsing ' sequence ' as a preposition word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_prepositions [get this definitions_by_type `preposition_word first_word]]]
	    [let [[second_word [if [cdr sequence] [second sequence]]]]
	      [let [[first_and_second_word_prepositions [if [cdr sequence] [get this definitions_by_type `preposition_word [list first_word second_word]]]]]
		[let [[prepositions [append first_word_prepositions first_and_second_word_prepositions]]]
		  [mapc [funk [preposition]
			      [parse_format '\n    parse_sequence_as_preposition_word: found a preposition: ' [get preposition symbols]]
			      [let [[new_parse_tree       [get parse_tree new_copy]]
				    [new_preposition_word [get preposition new_copy]]
				    [rest_sequence  [if [is-type `symbol [get preposition symbols]]
							[cdr sequence]
						      [cddr sequence]]]]
				[have new_parse_tree add_child_to_type `preposition_group new_preposition_word]
				[= parses [cons [frame parse_tree       new_parse_tree
						       preposition_word new_preposition_word
						       rest_sequence    rest_sequence]
						parses]]]]
			prepositions]]]]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_verb_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parse_sequence_as_verb_word: parsing ' sequence ' as a verb word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_verbs [get this definitions_by_type `verb_word first_word]]]
	    [let [[second_word [if [cdr sequence] [second sequence]]]]
	      [let [[first_and_second_word_verbs [if [cdr sequence] [get this definitions_by_type `verb_word [list first_word second_word]]]]]
		[let [[verbs [append first_word_verbs first_and_second_word_verbs]]]
		  [mapc [funk [verb]
			      [parse_format '\n    parse_sequence_as_verb_word: found a verb: ' [get verb symbols]]
			      [let [[new_parse_tree [get parse_tree new_copy]]
				    [new_verb_word  [get verb new_copy]]
				    [rest_sequence  [if [is-type `symbol [get verb symbols]]
							[cdr sequence]
						      [cddr sequence]]]]
				[have new_parse_tree add_child_to_type `verb_group new_verb_word]
				[= parses [cons [frame parse_tree    new_parse_tree
						       verb_word     new_verb_word
						       rest_sequence rest_sequence]
						parses]]]]
			verbs]]]]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_infinitive_helper_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parse_sequence_as_infinitive_helper_word: parsing ' sequence ' as an infinitive_helper word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_infinitive_helpers [get this definitions_by_type `infinitive_helper_word first_word]]]
	    [let [[second_word [if [cdr sequence] [second sequence]]]]
	      [let [[first_and_second_word_infinitive_helpers [if [cdr sequence] [get this definitions_by_type `infinitive_helper_word [list first_word second_word]]]]]
		[let [[infinitive_helpers [append first_word_infinitive_helpers first_and_second_word_infinitive_helpers]]]
		  [mapc [funk [infinitive_helper]
			      [parse_format '\n    parse_sequence_as_infinitive_helper_word: found an infinitive_helper: ' [get infinitive_helper symbols]]
			      [let [[new_parse_tree             [get parse_tree new_copy]]
				    [new_infinitive_helper_word [get infinitive_helper new_copy]]
				    [rest_sequence              [if [is-type `symbol [get infinitive_helper symbols]]
								    [cdr sequence]
								  [cddr sequence]]]]
				[have new_parse_tree add_child_to_type `verb_group new_infinitive_helper_word]
				[= parses [cons [frame parse_tree             new_parse_tree
						       infinitive_helper_word new_infinitive_helper_word
						       rest_sequence          rest_sequence]
						parses]]]]
			infinitive_helpers]]]]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_pronoun_word [sequence parse_tree containing_type]
  [let [[parses nil]]
    [parse_format '\n  parse_sequence_as_pronoun_word: parsing ' sequence ' as a pronoun word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_pronouns [get this definitions_by_type `pronoun_word first_word]]]
	    [let [[second_word [if [cdr sequence] [second sequence]]]]
	      [let [[first_and_second_word_pronouns [if [cdr sequence] [get this definitions_by_type `pronoun_word [list first_word second_word]]]]]
		[let [[pronouns [append first_word_pronouns first_and_second_word_pronouns]]]
		  [mapc [funk [pronoun]
			      [parse_format '\n    parse_sequence_as_pronoun_word: found a pronoun: ' [get pronoun symbols]]
			      [let [[new_parse_tree   [get parse_tree new_copy]]
				    [new_pronoun_word [get pronoun new_copy]]
				    [rest_sequence    [if [is-type `symbol [get pronoun symbols]]
							  [cdr sequence]
							[cddr sequence]]]]
				[have new_parse_tree add_child_to_type containing_type new_pronoun_word]
				[= parses [cons [frame parse_tree    new_parse_tree
						       pronoun_word  new_pronoun_word
						       rest_sequence rest_sequence]
						parses]]]]
			pronouns]]]]]]]
    parses]]

[deftypefunk parse_tree execute transfer_plurality_features_of_verb_word_to_containing_verb_group [verb_word]
  [set this containing_type_property `verb_group `singular       [or [get verb_word first_person_singular] [get verb_word third_person_singular]]]
  [set this containing_type_property `verb_group `plural         [get verb_word plural]]
  [set this containing_type_property `verb_group `takes_particle [get verb_word takes_particle]]]


[deftypefunk english_dictionary execute parse_sequence_as_verb_group-auxiliary_be_verbs [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parse_sequence_as_verb_group-auxiliary_be_verbs: parsing ' sequence ' as auxiliary be verbs.']
    [let [[verb_parses [have this parse_sequence_as_verb_word sequence parse_tree]]]
      [mapc [funk [verb_parse]
		  [let [[verb_parse_tree    [have verb_parse lookup `parse_tree]]
			[verb_word          [have verb_parse lookup `verb_word]]
			[verb_rest_sequence [have verb_parse lookup `rest_sequence]]]
		    [let [[new_parse_tree [get verb_parse_tree new_copy]]]
		      [have new_parse_tree transfer_plurality_features_of_verb_word_to_containing_verb_group verb_word]
		      [if [get verb_word be]
			  [prog [parse_format '\n  parse_sequence_as_verb_group-auxiliary_be_verbs: found be auxiliary be verb parse: ' verb_parse]
				[set verb_word auxiliary t]
				[set new_parse_tree containing_type_property `verb_group `be t]
				[= parses [cons [frame parse_tree    new_parse_tree
						       rest_sequence verb_rest_sequence
						       verb_group    [get new_parse_tree containing_type `verb_group]]
						parses]]]]]]]
	    verb_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_verb_group-after_auxiliary_verbs [sequence parse_tree]
  [let [[parses nil]]
    [let [[verb_parses [have this parse_sequence_as_verb_word sequence parse_tree]]]
      [mapc [funk [verb_parse]
		  [let [[verb_parse_tree    [have verb_parse lookup `parse_tree]]
			[verb_rest_sequence [have verb_parse lookup `rest_sequence]]
			[verb_word          [have verb_parse lookup `verb_word]]]
		    [parse_format '\n  parse_sequence_as_verb_group-after_auxiliary_verbs: found verb word: ' [get verb_word symbols]]
		    'do not transfer tense here because tense comes from the first auxiliary verb (e.g. "are supported").'
		    [if [or [get verb_word en]
			    [get verb_word ing]]
			[prog [parse_format '\n  parse_sequence_as_verb_group-after_auxiliary_verbs: verb_word satisfies en or ing conjugation: ' verb_word]
			      [set verb_word Main t]
			      [if [get verb_parse_tree containing_type_property `verb_group `be]
				  [if [get verb_word en]
				      [prog [parse_format '\n  parse_sequence_as_verb_group-after_auxiliary_verbs: verb_word is en following a be verb, so marking verb_group as passive.']
					    [set verb_parse_tree containing_type_property `verb_group `passive t]]]]
			      [= parses [cons [frame parse_tree    verb_parse_tree
						     rest_sequence verb_rest_sequence
						     verb_group    [get verb_parse_tree containing_type `verb_group]]
					      parses]]]]]]
	    verb_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_verb_group [sequence parse_tree]
  [let [[parses nil]]
    [let [[verb_group [get parse_tree containing_type `verb_group]]]
      [let [[verb_group_parse_tree [get parse_tree new_copy]]]
	[parse_format '\n  parse_sequence_as_verb_group: parsing ' sequence ' as a verb_group.']
	[if [get verb_group_parse_tree containing_type_property `verb_group `imperative]
	    [prog [parse_format '\n  parse_sequence_as_verb_group: parsing ' sequence ' as an imperative verb_group.']
		  [let [[first_word [first sequence]]]
		    [let [[first_word_verbs [get this definitions_by_type `verb_word first_word]]]
		      [mapc [funk [first_word_verb]
				  [let [[verb_word_parse_tree [get verb_group_parse_tree new_copy]]]
				    [have verb_word_parse_tree transfer_plurality_features_of_verb_word_to_containing_verb_group first_word_verb]
				    [if [get first_word_verb Do]
					[prog [parse_format '\n  parse_sequence_as_verb_group: parsing ' sequence ' as an imperative verb_group with first word as a form of "do".']
					      ]
				      [prog [if [get first_word_verb infinitive]
						[prog [parse_format '\n  parse_sequence_as_verb_group: parsing ' sequence ' as an imperative verb_group with first word as an infinitive verb.']
						      [let [[new_parse_tree [get verb_word_parse_tree new_copy]]
							    [new_verb_word  [get first_word_verb new_copy]]]
							[set new_verb_word Main t]
							[have new_parse_tree add_child_to_type `verb_group new_verb_word]
							[= parses [cons [frame parse_tree    new_parse_tree
									       rest_sequence [cdr sequence]
									       verb_word     new_verb_word
									       verb_group    [get new_parse_tree containing_type `verb_group]]
									parses]]
							]]
					      [prog [parse_format '\n  parse_sequence_as_verb_group: parsing ' sequence ' as an imperative verb_group with first word as not an infinitive verb (not implemented).']
						    ]]]]]]
			    first_word_verbs]]]]
	  [prog [parse_format '\n  parse_sequence_as_verb_group: parsing ' sequence ' as not an imperative verb_group.']
		[let [[infinitive_helper_word_parses [have this parse_sequence_as_infinitive_helper_word sequence verb_group_parse_tree]]]
		  [mapc [funk [infinitive_helper_word_parse]
			      [let [[infinitive_helper_word_parse_tree    [have infinitive_helper_word_parse lookup `parse_tree]]
				    [infinitive_helper_word_rest_sequence [have infinitive_helper_word_parse lookup `rest_sequence]]
				    [infinitive_helper_word               [have infinitive_helper_word_parse lookup `infinitive_helper_word]]]
				[parse_format '\n  parse_sequence_as_verb_group: found infinitive helper word: ' [get infinitive_helper_word symbols]]
				[let [[verb_word_parses [have this parse_sequence_as_verb_word infinitive_helper_word_rest_sequence infinitive_helper_word_parse_tree]]]
				  [mapc [funk [verb_word_parse]
					      [let [[verb_word_parse_tree    [have verb_word_parse lookup `parse_tree]]
						    [verb_word_rest_sequence [have verb_word_parse lookup `rest_sequence]]
						    [verb_word               [have verb_word_parse lookup `verb_word]]]
						[set verb_word Main t]
						[have verb_word_parse_tree transfer_plurality_features_of_verb_word_to_containing_verb_group verb_word]
						[parse_format '\n  parse_sequence_as_verb_group: found simple main verb: ' verb_word]
						[= parses [cons [frame parse_tree    verb_word_parse_tree
								       rest_sequence verb_word_rest_sequence
								       verb_group    [get verb_word_parse_tree containing_type `verb_group]]
								parses]]]]
					verb_word_parses]]]]
			infinitive_helper_word_parses]]
		[let [[verb_word_parses [have this parse_sequence_as_verb_word sequence verb_group_parse_tree]]]
		  [mapc [funk [verb_word_parse]
			      [let [[verb_word_parse_tree    [have verb_word_parse lookup `parse_tree]]
				    [verb_word_rest_sequence [have verb_word_parse lookup `rest_sequence]]
				    [verb_word               [have verb_word_parse lookup `verb_word]]]
				[set verb_word Main t]
				[have verb_word_parse_tree transfer_plurality_features_of_verb_word_to_containing_verb_group verb_word]
				[parse_format '\n  parse_sequence_as_verb_group: found simple main verb: ' verb_word]
				[= parses [cons [frame parse_tree    verb_word_parse_tree
						       rest_sequence verb_word_rest_sequence
						       verb_group    [get verb_word_parse_tree containing_type `verb_group]]
						parses]]]]
			verb_word_parses]]
		[let [[auxiliary_be_verbs_parses [have this parse_sequence_as_verb_group-auxiliary_be_verbs sequence verb_group_parse_tree]]]
		  [mapc [funk [auxiliary_be_verbs_parse]
			      [let [[auxiliary_be_verbs_parse_tree    [have auxiliary_be_verbs_parse lookup `parse_tree]]
				    [auxiliary_be_verbs_rest_sequence [have auxiliary_be_verbs_parse lookup `rest_sequence]]]
				[if [not [get auxiliary_be_verbs_parse_tree containing_type_property `verb_group `not_only_auxiliary]]
				    [prog [= parses [cons [frame parse_tree    auxiliary_be_verbs_parse_tree
								 rest_sequence auxiliary_be_verbs_rest_sequence
								 verb_group    [get auxiliary_be_verbs_parse_tree containing_type `verb_group]]
							  parses]]]]
				[if [and [     get auxiliary_be_verbs_parse_tree containing_type_property `verb_group `not_only_auxiliary]
					 [not [get auxiliary_be_verbs_parse_tree containing_type_property `verb_group `auxiliary]]]
				    [let [[after_auxiliary_verbs_parses [have this parse_sequence_as_verb_group-after_auxiliary_verbs auxiliary_be_verbs_rest_sequence auxiliary_be_verbs_parse_tree]]]
				      [= parses [append after_auxiliary_verbs_parses parses]]]]]]
			auxiliary_be_verbs_parses]]
		]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_preposition_group [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parsing ' sequence ' as preposition group.']
    [let [[preposition_group [get parse_tree containing_type `preposition_group]]]
      [if [get preposition_group question]
	  [prog [parse_format '\n      parsing ' sequence ' as question preposition group.']
		]
	[prog [parse_format '\n      parsing ' sequence ' as non-question preposition group.']
	      [let [[preposition_word_parses [have this parse_sequence_as_preposition_word sequence parse_tree]]]
		[mapc [funk [preposition_word_parse]
			    [let [[preposition_word_parse_tree    [have preposition_word_parse lookup `parse_tree]]
				  [preposition_word_rest_sequence [have preposition_word_parse lookup `rest_sequence]]]
			      [let [[noun_group_initial_parse_tree [get preposition_word_parse_tree new_copy]]
				    [noun_group                    [new noun_group]]]
				[have noun_group_initial_parse_tree add_child_to_type `preposition_group noun_group]
				[let [[noun_group_parses [have this parse_sequence_as_noun_group preposition_word_rest_sequence noun_group_initial_parse_tree]]]
				  [= parses [append noun_group_parses parses]]]]]]
		      preposition_word_parses]]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_bound_clause [sequence parse_tree]
  [parse_format '\n  parsing ' sequence ' as a bound clause: not implemented yet.']
  ]

[deftypefunk english_dictionary execute parse_sequence_as_particle_word [sequence parse_tree child_of_type]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a particle word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_particles [get this definitions_by_type `particle_word first_word]]]
	    [mapc [funk [first_word_particle]
			[parse_format '\n    found first word to be a particle: ' first_word]
			[let [[new_parse_tree    [get parse_tree          new_copy]]
			      [new_particle_word [get first_word_particle new_copy]]]
			  [have new_parse_tree add_child_to_type child_of_type new_particle_word]
			  [= parses [cons [frame parse_tree    new_parse_tree
						 particle_word new_particle_word
						 rest_sequence [cdr sequence]]
					  parses]]]]
		  first_word_particles]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_determiner_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a determiner word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_determiners [get this definitions_by_type `determiner_word first_word]]]
	    [let [[second_word [if [cdr sequence] [second sequence]]]]
	      [let [[first_and_second_word_determiners [if [cdr sequence] [get this definitions_by_type `determiner_word [list first_word second_word]]]]]
		[let [[determiners [append first_word_determiners first_and_second_word_determiners]]]
		  [mapc [funk [determiner]
			      [parse_format '\n    found a determiner: ' [get determiner symbols]]
			      [let [[new_parse_tree      [get parse_tree new_copy]]
				    [new_determiner_word [get determiner new_copy]]
				    [rest_sequence       [if [is-type `symbol [get determiner symbols]]
							     [cdr sequence]
							   [cddr sequence]]]]
				[have new_parse_tree add_child_to_type `noun_group new_determiner_word]
				[= parses [cons [frame parse_tree      new_parse_tree
						       determiner_word new_determiner_word
						       rest_sequence   rest_sequence]
						parses]]]]
			determiners]]]]]]]
    parses]]

[deftypefunk parse_tree execute transfer_relevant_features_from_determiner_word_to_containing_noun_group [determiner_word]
  [set this containing_type_property `noun_group `definite   [get determiner_word definite]]
  [set this containing_type_property `noun_group `indefinite [get determiner_word indefinite]]
  [set this containing_type_property `noun_group `quantifier [get determiner_word quantifier]]
  [set this containing_type_property `noun_group `singular   [get determiner_word singular]]
  [set this containing_type_property `noun_group `plural     [get determiner_word plural]]
  [set this containing_type_property `noun_group `mass       [get determiner_word mass]]
  [set this containing_type_property `noun_group `determiner t]]

[deftypefunk parse_tree execute transfer_relevant_features_from_pronoun_word_to_containing_noun_group [pronoun_word]
  [set this containing_type_property `noun_group `singular   [or [get pronoun_word singular] [get pronoun_word first_person_singular]]]
  [set this containing_type_property `noun_group `plural     [get pronoun_word plural]]]

[deftypefunk english_dictionary execute parse_sequence_as_adjective_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an adjective word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_adjectives [get this definitions_by_type `adjective_word first_word]]]
	    [mapc [funk [first_word_adjective]
			[parse_format '\n    found first word to be an adjective: ' first_word]
			[let [[new_parse_tree     [get parse_tree           new_copy]]
			      [new_adjective_word [get first_word_adjective new_copy]]]
			  [have new_parse_tree add_next new_adjective_word]
			  [= parses [cons [frame parse_tree     new_parse_tree
						 adjective_word new_adjective_word
						 rest_sequence  [cdr sequence]]
					  parses]]]]
		  first_word_adjectives]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_adjective_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[adjective_parses [have this parse_sequence_as_adjective_word sequence parse_tree]]]
      [mapc [funk [adjective_parse]
		  [let [[adjective_parse_tree [have adjective_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful adjective_word parse: ' adjective_parse]
		    [= parses [cons adjective_parse parses]]
		    [let [[adjective_words_parses [have this parse_sequence_as_adjective_words [cdr sequence] adjective_parse_tree]]]
		      [mapc [funk [adjective_words_parse]
				  [= parses [cons adjective_words_parse parses]]]
			    adjective_words_parses]]]]
	    adjective_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_classifier_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a classifier word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_classifiers [get this definitions_by_type `classifier_word first_word]]]
	    [mapc [funk [first_word_classifier]
			[parse_format '\n    found first word to be a classifier: ' first_word]
			[let [[new_parse_tree      [get parse_tree            new_copy]]
			      [new_classifier_word [get first_word_classifier new_copy]]]
			  [have new_parse_tree add_next new_classifier_word]
			  [= parses [cons [frame parse_tree      new_parse_tree
						 classifier_word new_classifier_word
						 rest_sequence   [cdr sequence]]
					  parses]]]]
		  first_word_classifiers]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_classifier_words [sequence parse_tree]
  [let [[parses nil]]
    [let [[classifier_parses [have this parse_sequence_as_classifier_word sequence parse_tree]]]
      [mapc [funk [classifier_parse]
		  [let [[classifier_parse_tree [have classifier_parse lookup `parse_tree]]]
		    [parse_format '\n  found successful classifier_word parse: ' classifier_parse]
		    [= parses [cons classifier_parse parses]]
		    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words [cdr sequence] classifier_parse_tree]]]
		      [mapc [funk [classifier_words_parse]
				  [= parses [cons classifier_words_parse parses]]]
			    classifier_words_parses]]]]
	    classifier_parses]]
    parses]]


[deftypefunk english_dictionary execute parse_sequence_as_noun_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a noun word.']
    [if sequence
	[let [[first_word [first sequence]]]
	  [let [[first_word_nouns [get this definitions_by_type `noun_word first_word]]]
	    [mapc [funk [first_word_noun]
			[parse_format '\n    found first word to be a noun: ' first_word]
			[let [[new_parse_tree [get parse_tree      new_copy]]
			      [new_noun_word  [get first_word_noun new_copy]]]
			  [have new_parse_tree add_child_to_type `noun_group new_noun_word]
			  [= parses [cons [frame parse_tree    new_parse_tree
						 noun_word     new_noun_word
						 rest_sequence [cdr sequence]]
					  parses]]]]
		  first_word_nouns]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_number_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a number word.']
    [if sequence
	[let [[first_word [car sequence]]]
	  [let [[number_definitions [get this definitions_by_type `number_word first_word]]]
	    [mapc [funk [number_definition]
			[parse_format '\n    found first word to be a number: ' first_word]
			[let [[new_parse_tree [get parse_tree new_copy]]]
			  [have new_parse_tree add_next number_definition]
			  [= parses [cons [frame parse_tree    new_parse_tree
						 rest_sequence [cdr sequence]
						 number_word   [get number_definition new_copy]]
					  parses]]]]
		  number_definitions]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_ordinal_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as an ordinal word.']
    [if sequence
	[let [[first_word [car sequence]]]
	  [let [[ordinal_definitions [get this definitions_by_type `ordinal_word first_word]]]
	    [mapc [funk [ordinal_definition]
			[parse_format '\n    found first word to be an ordinal: ' first_word]
			[let [[new_parse_tree [get parse_tree new_copy]]]
			  [have new_parse_tree add_next ordinal_definition]
			  [= parses [cons [frame parse_tree    new_parse_tree
						 rest_sequence [cdr sequence]
						 ordinal_word  [get ordinal_definition new_copy]]
					  parses]]]]
		  ordinal_definitions]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_question_adjunct_word [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as a question_adjunct word.']
    [if sequence
	[let [[first_word [car sequence]]]
	  [let [[question_adjunct_definitions [get this definitions_by_type `question_adjunct_word first_word]]]
	    [mapc [funk [question_adjunct_definition]
			[parse_format '\n    found first word to be a question_adjunct: ' first_word]
			[let [[new_parse_tree [get parse_tree new_copy]]]
			  [have new_parse_tree add_next question_adjunct_definition]
			  [= parses [cons [frame parse_tree    new_parse_tree
						 rest_sequence [cdr sequence]
						 question_adjunct_word   [get question_adjunct_definition new_copy]]
					  parses]]]]
		  question_adjunct_definitions]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-relative_clause [sequence parse_tree]
  [let [[parses nil]]
    [let [[relative_clause_parses [have this parse_sequence_as_clause sequence parse_tree]]]
      [mapc [funk [relative_clause_parse]
		  [let [[relative_clause_parse_tree    [have relative_clause_parse lookup `parse_tree]]
			[relative_clause_rest_sequence [have relative_clause_parse lookup `rest_sequence]]]
		    [= parses [cons [frame parse_tree    relative_clause_parse_tree
					   rest_sequence relative_clause_rest_sequence
					   noun_group    [get relative_clause_parse_tree containing_type `noun_group]]
				    parses]]]]
	    relative_clause_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-qualifiers [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parsing ' sequence ' as noun_group-qualifiers.']
    [let [[noun_group [get parse_tree containing_type `noun_group]]]
      [let [[preposition_group_initial_parse_tree [get parse_tree new_copy]]
	    [preposition_group                    [new preposition_group]]]
	[have preposition_group_initial_parse_tree add_child_to_type `noun_group preposition_group]
	[let [[preposition_group_parses [have this parse_sequence_as_preposition_group sequence preposition_group_initial_parse_tree]]]
	  [mapc [funk [preposition_group_parse]
		      [let [[preposition_group_parse_tree          [have preposition_group_parse lookup `parse_tree]]
			    [preposition_group_parse_rest_sequence [have preposition_group_parse lookup `rest_sequence]]]
			[= parses [cons [frame parse_tree    preposition_group_parse_tree
					       rest_sequence preposition_group_parse_rest_sequence
					       noun_group    noun_group]
					parses]]]]
		preposition_group_parses]]]
      'relative word (which)'
      [let [[relative_clause_parse_tree [get parse_tree new_copy]]
	    [relative_clause            [new clause]]]
	[set relative_clause wh                           t]
	[set relative_clause secondary                    t]
	[set relative_clause unmatched_relative_reference t]
	[have relative_clause_parse_tree add_child_to_type `noun_group relative_clause]
	[let [[relative_clause_parses [have this parse_sequence_as_noun_group-relative_clause sequence relative_clause_parse_tree]]]
	  [mapc [funk [relative_clause_parse]
		      [let [[relative_clause_parse_tree [have relative_clause_parse lookup `parse_tree]]]
			[parse_format '\n    parse_sequence_as_noun_group-qualifiers: found relative_clause_parse: ' relative_clause_parse]
			[have relative_clause_parse_tree pop_to_type `clause]
			[have relative_clause_parse_tree pop_to_type `noun_group]
			[= parses [cons relative_clause_parse parses]]]]
		relative_clause_parses]]]
      [parse_format '\n  qualifiers are not completely implemented.']
      'past participle (supported by)'
      'ing verb'
      'comparative adjective (bigger than)'
      'as (as big as)'
      'RSO clause']
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_noun [sequence parse_tree]
  [let [[parses nil]]
    [if [not [null sequence]]
	[let [[qualifiers_parses [have this parse_sequence_as_noun_group-qualifiers sequence parse_tree]]]
	  [mapc [funk [qualifiers_parse]
		      [= parses [cons qualifiers_parse parses]]]
		qualifiers_parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_classifiers [sequence parse_tree]
  [let [[parses nil]]
    [let [[noun_parses [have this parse_sequence_as_noun_word sequence parse_tree]]]
      [mapc [funk [noun_parse]
		  [let [[noun_parse_tree    [have noun_parse lookup `parse_tree]]
			[noun_word          [have noun_parse lookup `noun_word]]
			[noun_rest_sequence [have noun_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_classifiers noun_word parse........: ' noun_parse]
		    [parse_format '\n      noun group-after_classifiers noun_word rest_sequence: ' noun_rest_sequence]
		    [parse_format '\n      noun group-after_classifiers noun_word serialized...: ' [get noun_parse_tree serialized]]
		    [if [or [and [get noun_parse_tree containing_type_property `noun_group `singular] [get noun_word singular]]
			    [and [get noun_parse_tree containing_type_property `noun_group `plural]   [get noun_word plural]]
			    [and [get noun_parse_tree containing_type_property `noun_group `mass]     [get noun_word mass]]]
			[prog [parse_format '\n      noun group-after_classifiers noun_word agrees with singular, plural, mass qualities of noun_group.']
			      [= parses [cons [frame parse_tree    noun_parse_tree
						     rest_sequence noun_rest_sequence
						     noun_group    [get noun_parse_tree containing_type `noun_group]]
					      parses]]
			      [let [[after_noun_parses [have this parse_sequence_as_noun_group-after_noun noun_rest_sequence noun_parse_tree]]]
				[mapc [funk [after_noun_parse]
					    [= parses [cons after_noun_parse parses]]]
				      after_noun_parses]]]
		      [prog [parse_format '\n      noun group-after_classifiers noun_word does not agree with singular, plural, mass qualities of noun_group.']
			    ]]]]
	    noun_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_adjectives [sequence parse_tree]
  [let [[parses nil]]
    [let [[classifier_words_parses [have this parse_sequence_as_classifier_words sequence parse_tree]]]
      [mapc [funk [classifier_words_parse]
		  [let [[classifier_words_parse_tree    [have classifier_words_parse lookup `parse_tree]]
			[classifier_words_rest_sequence [have classifier_words_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_adjectives found successful classifier_words parse: ' classifier_words_parse]
		    [let [[after_classifiers_parses [have this parse_sequence_as_noun_group-after_classifiers classifier_words_rest_sequence classifier_words_parse_tree]]]
		      [parse_format '\n      noun group-after_determiner after_classifiers (1) parses: ' after_classifiers_parses]
		      [= parses [append after_classifiers_parses parses]]]]]
	    classifier_words_parses]]
    [let [[after_classifiers_parses [have this parse_sequence_as_noun_group-after_classifiers sequence parse_tree]]]
      [parse_format '\n      noun group-after_determiner after_classifiers (2) parses: ' after_classifiers_parses]
      [= parses [append after_classifiers_parses parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_number [sequence parse_tree]
  [let [[parses nil]]
    [let [[adjective_words_parses [have this parse_sequence_as_adjective_words sequence parse_tree]]]
      [mapc [funk [adjective_words_parse]
		  [let [[adjective_words_parse_tree    [have adjective_words_parse lookup `parse_tree]]
			[adjective_words_rest_sequence [have adjective_words_parse lookup `rest_sequence]]]
		    [parse_format '\n      noun group-after_determiner found successful adjective_words parse: ' adjective_words_parse]
		    [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives adjective_words_rest_sequence adjective_words_parse_tree]]]
		      [parse_format '\n      noun group-after_determiner after_adjectives (1) parses: ' after_adjectives_parses]
		      [= parses [append after_adjectives_parses parses]]]]]
	    adjective_words_parses]]
    'finally, we try interpretting without any adjectives.'
    [let [[after_adjectives_parses [have this parse_sequence_as_noun_group-after_adjectives sequence parse_tree]]]
      [parse_format '\n      noun group-after_determiner after_adjectives (2) parses: ' after_adjectives_parses]
      [= parses [append after_adjectives_parses parses]]]
    parses]]



[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_ordinal [sequence parse_tree]
  [let [[parses nil]]
    [let [[number_parses [have this parse_sequence_as_number_word sequence parse_tree]]]
      [mapc [funk [number_parse]
		  [let [[number_parse_tree    [have number_parse lookup `parse_tree]]
			[number_word          [have number_parse lookup `number_word]]
			[number_rest_sequence [have number_parse lookup `rest_sequence]]]
		    [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number number_rest_sequence number_parse_tree]]]
		      [parse_format '\n      noun group-after_ordinal after_number (1) parses: ' after_number_parses]
		      [= parses [append after_number_parses parses]]]]]
	    number_parses]]
    [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number sequence parse_tree]]]
      [parse_format '\n      noun group-after_ordinal after_number (2) parses: ' after_number_parses]
      [= parses [append after_number_parses parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group-after_determiner [sequence parse_tree]
  [let [[parses nil]]
    [if [get parse_tree containing_type_property `noun_group `definite]
	[prog [parse_format '\n    our noun group is definite.']
	      'because our noun group is definite, we must look for an ordinal and a number.'
	      [let [[ordinal_parses [have this parse_sequence_as_ordinal_word sequence parse_tree]]]
		[mapc [funk [ordinal_parse]
			    [let [[ordinal_parse_tree    [have ordinal_parse lookup `parse_tree]]
				  [ordinal_rest_sequence [have ordinal_parse lookup `rest_sequence]]]
			      [let [[after_ordinal_parses [have this parse_sequence_as_noun_group-after_ordinal ordinal_rest_sequence ordinal_parse_tree]]]
				[parse_format '\n      noun group-after_determiner after_ordinal parses: ' after_number_parses]
				[= parses [append after_ordinal_parses parses]]]]]
		      ordinal_parses]]
	      [let [[after_ordinal_parses [have this parse_sequence_as_noun_group-after_ordinal sequence parse_tree]]]
		[= parses [append after_ordinal_parses parses]]]]
      [let [[after_number_parses [have this parse_sequence_as_noun_group-after_number sequence parse_tree]]]
	[parse_format '\n      noun group-after_determiner after_number parses: ' after_number_parses]
	[= parses [append after_number_parses parses]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_noun_group [sequence parse_tree]
  [let [[parses nil]]
    [let [[noun_group [get parse_tree containing_type `noun_group]]]
      [let [[noun_group_parse_tree [get parse_tree new_copy]]]
	[parse_format '\n  parsing ' sequence ' as a noun_group.']
	[let [[pronoun_parses [have this parse_sequence_as_pronoun_word sequence noun_group_parse_tree `noun_group]]]
	  [mapc [funk [pronoun_parse]
		      [let [[pronoun_parse_tree    [have pronoun_parse lookup `parse_tree]]
			    [pronoun_rest_sequence [have pronoun_parse lookup `rest_sequence]]
			    [pronoun_word          [have pronoun_parse lookup `pronoun_word]]]
			[have pronoun_parse_tree transfer_relevant_features_from_pronoun_word_to_containing_noun_group pronoun_word]
			[= parses [cons [frame parse_tree    pronoun_parse_tree
					       rest_sequence pronoun_rest_sequence
					       noun_group    [get pronoun_parse_tree containing_type `noun_group]]
					parses]]]]
		pronoun_parses]]
	[let [[determiner_parses [have this parse_sequence_as_determiner_word sequence noun_group_parse_tree]]]
	  [mapc [funk [determiner_parse]
		      [let [[determiner_parse_tree    [have determiner_parse lookup `parse_tree]]
			    [determiner_word          [have determiner_parse lookup `determiner_word]]
			    [determiner_rest_sequence [have determiner_parse lookup `rest_sequence]]]
			[if [eq [get noun_group question] [get determiner_word question]]
			    [prog [parse_format '\n    found successful determiner_word parse: ' determiner_parse]
				  [have determiner_parse_tree transfer_relevant_features_from_determiner_word_to_containing_noun_group determiner_word]
				  [let [[after_determiner_parses [have this parse_sequence_as_noun_group-after_determiner determiner_rest_sequence determiner_parse_tree]]]
				    [parse_format '\n      noun group after_determiner parses: ' after_determiner_parses]
				    [= parses [append after_determiner_parses parses]]]]
			  [prog [parse_format '\n    found unsuccessful determiner_word agreement with noun_group question attribute.']
				]]]]
		determiner_parses]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-main_question [sequence parse_tree]
  [let [[parses nil]]
    [let [[question_parse_tree [get parse_tree new_copy]]]
      [set question_parse_tree containing_type_property `clause `question t]
      [let [[question_adjunct_parses [have this parse_sequence_as_question_adjunct_word sequence question_parse_tree]]]
	[mapc [funk [question_adjunct_parse]
		    [let [[question_adjunct_parse_tree    [have question_adjunct_parse lookup `parse_tree]]
			  [question_adjunct_rest_sequence [have question_adjunct_parse lookup `rest_sequence]]]
		      [parse_format '\n    found successful question_adjunct_word parse: ' question_adjunct_parse]
		      
		      ]]
	      question_adjunct_parses]]
      [let [[preposition_group_initial_parse_tree [get question_parse_tree new_copy]]
	    [preposition_group                    [new preposition_group]]]
	[set preposition_group question t]
	[have preposition_group_initial_parse_tree add_child_to_type `clause preposition_group]
	[let [[preposition_group_parses [have this parse_sequence_as_preposition_group sequence preposition_group_initial_parse_tree]]]
	  [mapc [funk [preposition_group_parse]
		      [let [[preposition_group_parse_tree    [have preposition_group_parse lookup `parse_tree]]
			    [preposition_group_rest_sequence [have preposition_group_parse lookup `rest_sequence]]]
			[= parses [cons [frame parse_tree    preposition_group_parse_tree
					       rest_sequence preposition_group_rest_sequence
					       clause        [get preposition_group_parse_tree containing_type `clause]]
					parses]]]]
		preposition_group_parses]]]
      [let [[noun_group_initial_parse_tree [get question_parse_tree new_copy]]
	    [noun_group                    [new noun_group]]]
	[set noun_group question t]
	[have noun_group_initial_parse_tree add_child_to_type `clause noun_group]
	[let [[noun_group_parses [have this parse_sequence_as_noun_group sequence noun_group_initial_parse_tree]]]
	  [mapc [funk [noun_group_parse]
		      [let [[noun_group_parse_tree    [have noun_group_parse lookup `parse_tree]]
			    [noun_group_rest_sequence [have noun_group_parse lookup `rest_sequence]]
			    [noun_group               [have noun_group_parse lookup `noun_group]]]
			[parse_format '\n    found successful question noun_group parse: ' noun_group_parse]
			[have noun_group_parse_tree pop_to_type `clause]
			[let [[verb_group_parse_tree [get noun_group_parse_tree new_copy]]
			      [verb_group            [new verb_group]]]
			  [set verb_group not_only_auxiliary t]
			  [have verb_group_parse_tree add_child_to_type `clause verb_group]
			  [let [[verb_group_parses [have this parse_sequence_as_verb_group noun_group_rest_sequence verb_group_parse_tree]]]
			    [mapc [funk [verb_group_parse]
					[let [[verb_group_parse_tree    [have verb_group_parse lookup `parse_tree]]
					      [verb_group_rest_sequence [have verb_group_parse lookup `rest_sequence]]
					      [verb_group_verb_group    [have verb_group_parse lookup `verb_group]]]
					  [have verb_group_parse_tree pop_to_type `clause]
					  [parse_format '\n    verb_group_verb_group: ' verb_group_verb_group]
					  [parse_format '\n    noun_group...........: ' noun_group]
					  'only present tense verbs require agreement with noun_group'
					  [if [or [get verb_group en]
						  [or [and [get noun_group singular] [get verb_group_verb_group singular]]
						      [and [get noun_group plural]   [get verb_group_verb_group plural]]
						      [and [get noun_group mass]     [get verb_group_verb_group singular]]]]
					      [prog [parse_format '\n      verb_group quantity is okay with noun_group quantity: ' verb_group_parse]
						    [= parses [cons [frame parse_tree    verb_group_parse_tree
									   rest_sequence verb_group_rest_sequence
									   clause        [get verb_group_parse_tree containing_type `clause]]
								    parses]]
						    'look for preposition group modifying question verb.'
						    [let [[preposition_group_initial_parse_tree [get verb_group_parse_tree new_copy]]
							  [preposition_group                    [new preposition_group]]]
						      [have preposition_group_initial_parse_tree add_child_to_type `clause preposition_group]
						      [let [[preposition_group_parses [have this parse_sequence_as_preposition_group verb_group_rest_sequence preposition_group_initial_parse_tree]]]
							[mapc [funk [preposition_group_parse]
								    [let [[preposition_group_parse_tree    [have preposition_group_parse lookup `parse_tree]]
									  [preposition_group_rest_sequence [have preposition_group_parse lookup `rest_sequence]]]
								      [= parses [cons [frame parse_tree    preposition_group_parse_tree
											     rest_sequence preposition_group_rest_sequence
											     clause        [get preposition_group_parse_tree containing_type `clause]]
										      parses]]]]
							      preposition_group_parses]]]
						    
						    ]]]]
				  verb_group_parses]]]]]
		noun_group_parses]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-matching_verb_particle [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parse_sequence_as_clause-matching_verb_particle: parsing ' sequence ' as matching verb particle.']
    [if sequence
	[let [[verb_word [get parse_tree containing_type_child_of_type_child_of_type `clause `verb_group `verb_word]]]
	  [if [get verb_word takes_particle]
	      [prog [parse_format '\n  parse_sequence_as_clause-matching_verb_particle: verb_word takes particle.']
		    [if [get parse_tree containing_type_property `clause `particle]
			[prog [parse_format '\n  parse_sequence_as_clause-matching_verb_particle: already found particle for this clause.']
			      ]
		      [let [[try_particle_parse_tree [get parse_tree new_copy]]]
			[parse_format '\n  parse_sequence_as_clause-matching_verb_particle: this clause does not have particle yet.']
			[set try_particle_parse_tree containing_type_property `clause `particle t]
			[have try_particle_parse_tree pop_to_type `clause]
			[let [[first_word [first sequence]]]
			  [let [[first_word_particles [get this definitions_by_type `particle_word first_word]]]
			    [mapc [funk [first_word_particle]
					[parse_format '\n    parse_sequence_as_clause-matching_verb_particle: found first word to be particle: ' first_word]
					[let [[combination [append [let [[verb_words [get verb_word symbols]]]
								     [if [not [or [is-type `cons verb_words] [is-type `list verb_words]]]
									 [cons verb_words nil]
								       verb_words]]
								   [cons first_word nil]]]]
					  [let [[combination_definitions [get this definitions_by_type `combination_group combination]]]
					    [mapc [funk [combination_definition]
							[parse_format '\n      parse_sequence_as_clause-matching_verb_particle: found combination to be in dictionary: ' combination]
							[if [get combination_definition transitive]
							    [set try_particle_parse_tree containing_type_child_of_type_child_of_type_property `clause `verb_group `verb_word `transitive t]]
							[set try_particle_parse_tree containing_type_child_of_type_property `clause `verb_group `symbols combination]
							[let [[particle_parses [have this parse_sequence_as_particle_word sequence try_particle_parse_tree `clause]]]
							  [= parses [append particle_parses parses]]]]
						  combination_definitions]]]]
				  first_word_particles]]]]]]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-with_verb_group_next [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parse_sequence_as_clause-with_verb_group_next: parsing ' sequence]
    [let [[verb_group_parses [have this parse_sequence_as_verb_group sequence parse_tree]]]
      [mapc [funk [verb_group_parse]
		  [let [[verb_group_parse_tree    [have verb_group_parse lookup `parse_tree]]
			[verb_group_rest_sequence [have verb_group_parse lookup `rest_sequence]]
			[verb_group               [have verb_group_parse lookup `verb_group]]]
		    [parse_format '\n    parse_sequence_as_clause-with_verb_group_next --calling-> parse_sequence_as_clause-verb_objects on ' verb_group_rest_sequence '.']
		    [let [[verb_objects_parses [have this parse_sequence_as_clause-verb_objects verb_group_rest_sequence verb_group_parse_tree]]]
		      [parse_format '\n      parse_sequence_as_clause-with_verb_group_next verb_objects_parses: ' verb_objects_parses]
		      [= parses [append verb_objects_parses parses]]]]]
	    verb_group_parses]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-imperative_with_verb_first [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parse_sequence_as_clause-imperative_with_verb_first: parsing ' sequence]
    [let [[verb_group_initial_parse_tree [get parse_tree new_copy]]
	  [verb_group                    [new verb_group]]]
      [set verb_group imperative t]
      [set  verb_group_initial_parse_tree containing_type_property `clause `imperative t]
      [have verb_group_initial_parse_tree add_child_to_type `clause verb_group]
      [let [[verb_group_parses [have this parse_sequence_as_clause-with_verb_group_next sequence verb_group_initial_parse_tree]]]
	[parse_format '\n      parse_sequence_as_clause-imperative_with_verb_first verb_group_parses: ' verb_group_parses]
	[= parses [append verb_group_parses parses]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-verb_objects-after_second_particle_try [sequence parse_tree]
  [let [[parses nil]]
    [let [[verb_word [get parse_tree containing_type_child_of_type_child_of_type `clause `verb_group `verb_word]]]
      [if [get verb_word transitive_two]
	  [let [[noun_group_initial_parse_tree [get parse_tree new_copy]]
		[noun_group                    [new noun_group]]]
	    [have noun_group_initial_parse_tree add_child_to_type `clause noun_group]
	    [let [[direct_object_two_parses [have this parse_sequence_as_noun_group sequence noun_group_initial_parse_tree]]]
	      [mapc [funk [direct_object_two_parse]
			  [let [[direct_object_two_parse_tree    [have direct_object_two_parse lookup `parse_tree]]
				[direct_object_two_rest_sequence [have direct_object_two_parse lookup `rest_sequence]]]
			    [set direct_object_parse_tree containing_type_property `noun_group `object     t]
			    [set direct_object_parse_tree containing_type_property `noun_group `object_two t]
			    [let [[after_direct_object_two_parses [have this parse_sequence_as_clause-verb_objects-after_direct_object direct_object_two_rest_sequence direct_object_two_parse_tree]]]
			      [parse_format '\n        parse_sequence_as_clause-verb_objects-after_first_particle_try after_first_object_parses: ' after_direct_object_two_parses]
			      [= parses [append after_direct_object_two_parses parses]]
			      
			      [if [get parse_tree containing_type_child_of_type_child_of_type_property `clause `verb_group `verb_word `takes_particle]
				  [let [[try_particle_parses [have this parse_sequence_as_clause-matching_verb_particle sequence parse_tree]]]
				    [mapc [funk [try_particle_parse]
						[let [[try_particle_parse_tree    [have try_particle_parse lookup `parse_tree]]
						      [try_particle_rest_sequence [have try_particle_parse lookup `rest_sequence]]]
						  [= parses [append try_particle_parses parses]]]]
					  try_particle_parses]]]
			      
			      ]]]
		    direct_object_two_parses]
	      ]]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-verb_objects-after_direct_object [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parse_sequence_as_clause-verb_objects-after_direct_object parsing ' sequence '.']
    [= parses [cons [frame parse_tree    parse_tree
			   rest_sequence sequence]
		    parses]]
    
    [if [get parse_tree containing_type_child_of_type_child_of_type_property `clause `verb_group `verb_word `takes_particle]
	[let [[try_particle_parses [have this parse_sequence_as_clause-matching_verb_particle sequence parse_tree]]]
	  [mapc [funk [try_particle_parse]
		      [let [[try_particle_parse_tree    [have try_particle_parse lookup `parse_tree]]
			    [try_particle_rest_sequence [have try_particle_parse lookup `rest_sequence]]]
			[= parses [append try_particle_parses parses]]
			
			[let [[second_particle_try_parses [have this parse_sequence_as_clause-verb_objects-after_second_particle_try sequence parse_tree]]]
			  [= parses [append second_particle_try_parses parses]]]
			
			]]
		try_particle_parses]]]
    
    [let [[second_particle_try_parses [have this parse_sequence_as_clause-verb_objects-after_second_particle_try sequence parse_tree]]]
      [= parses [append second_particle_try_parses parses]]]
    
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-verb_objects-after_first_particle_try [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n      parse_sequence_as_clause-verb_objects-after_first_particle_try: parsing ' sequence '.']
    [let [[verb_word [get parse_tree containing_type_child_of_type_child_of_type `clause `verb_group `verb_word]]]
      [if [get verb_word transitive]
	  [let [[noun_group_initial_parse_tree [get parse_tree new_copy]]
		[noun_group                    [new noun_group]]]
	    [have noun_group_initial_parse_tree add_child_to_type `clause noun_group]
	    [parse_format '\n        parse_sequence_as_clause-verb_objects-after_first_particle_try -> parse_sequence_as_noun_group']
	    [let [[direct_object_parses [have this parse_sequence_as_noun_group sequence noun_group_initial_parse_tree]]]
	      [mapc [funk [direct_object_parse]
			  [let [[direct_object_parse_tree    [have direct_object_parse lookup `parse_tree]]
				[direct_object_rest_sequence [have direct_object_parse lookup `rest_sequence]]]
			    [set direct_object_parse_tree containing_type_property `noun_group `object     t]
			    [set direct_object_parse_tree containing_type_property `noun_group `object_one t]
			    [let [[after_direct_object_parses [have this parse_sequence_as_clause-verb_objects-after_direct_object direct_object_rest_sequence direct_object_parse_tree]]]
			      [parse_format '\n        parse_sequence_as_clause-verb_objects-after_first_particle_try after_first_object_parses: ' after_direct_object_parses]
			      [= parses [append after_direct_object_parses parses]]]]]
		    direct_object_parses]
	      ]]]
      [if [get verb_word takes_subject_to_object]
	  [let [[subject_to_object_initial_parse_tree [get parse_tree new_copy]]
		[subject_to_object_clause             [new clause]]]
	    [parse_format '\n    parse_sequence_as_clause-verb_objects-after_first_particle_try: verb_word takes subject_to_object.']
	    [set subject_to_object_clause secondary         t]
	    [set subject_to_object_clause subject_to_object t]
	    [have subject_to_object_initial_parse_tree add_child_to_type `clause subject_to_object_clause]
	    [let [[subject_to_object_clause_parses [have this parse_sequence_as_clause sequence subject_to_object_initial_parse_tree]]]
	      [mapc [funk [subject_to_object_clause_parse]
			  [let [[subject_to_object_clause_parse_tree [have subject_to_object_clause_parse lookup `parse_tree]]]
			    [parse_format '\n    parse_sequence_as_clause-verb_objects-after_first_particle_try: found subject_to_object parse: ' subject_to_object_clause_parse]
			    [have subject_to_object_clause_parse_tree pop_to_type `clause]
			    [have subject_to_object_clause_parse_tree pop_to_type `verb_group]
			    [= parses [cons subject_to_object_clause_parse parses]]]]
		    subject_to_object_clause_parses]]]]
      [if [get verb_word takes_to_object]
	  [let [[to_object_initial_parse_tree [get parse_tree new_copy]]
		[to_object_clause             [new clause]]]
	    [parse_format '\n  parse_sequence_as_clause-verb_objects-after_first_particle_try: verb_word takes to_object.']
	    [set to_object_clause secondary t]
	    [set to_object_clause to_object t]
	    [have to_object_initial_parse_tree add_child_to_type `clause to_object_clause]
	    [let [[to_object_clause_parses [have this parse_sequence_as_clause sequence to_object_initial_parse_tree]]]
	      [mapc [funk [to_object_clause_parse]
			  [let [[to_object_clause_parse_tree [have to_object_clause_parse lookup `parse_tree]]]
			    [parse_format '\n    parse_sequence_as_clause-verb_objects-after_first_particle_try: found to_object parse: ' to_object_clause_parse]
			    [have to_object_clause_parse_tree pop_to_type `clause]
			    [have to_object_clause_parse_tree pop_to_type `verb_group]
			    [= parses [cons to_object_clause_parse parses]]]]
		    to_object_clause_parses]]]]]
    
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-verb_objects [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parse_sequence_as_clause-verb_objects: parsing ' sequence '.']
    [if [get parse_tree containing_type_child_of_type_child_of_type_property `clause `verb_group `verb_word `takes_particle]
	[let [[try_particle_parses [have this parse_sequence_as_clause-matching_verb_particle sequence parse_tree]]]
	  [mapc [funk [try_particle_parse]
		      [let [[try_particle_parse_tree    [have try_particle_parse lookup `parse_tree]]
			    [try_particle_rest_sequence [have try_particle_parse lookup `rest_sequence]]]
			[if [and [get try_particle_parse_tree containing_type_child_of_type_child_of_type_property `clause `verb_group `verb_word `transitive]
				 [get try_particle_parse_tree containing_type_with_true_property `clause `secondary]
				 [get try_particle_parse_tree containing_type_with_true_property `clause `wh]
				 [get try_particle_parse_tree containing_type_with_true_property `clause `unmatched_relative_reference]]
			    [let [[unmatched_relative_reference_parse_tree [get try_particle_parse_tree new_copy]]]
			      [parse_format '\n    parse_sequence_as_clause-verb_objects: clause is secondary and has transitive verb, so we could be missing a direct object (and be done).']
			      [set unmatched_relative_reference_parse_tree containing_type_with_true_property `clause `unmatched_relative_reference nil]
			      [= parses [cons [frame parse_tree    unmatched_relative_reference_parse_tree
						     rest_sequence try_particle_rest_sequence
						     clause        [get unmatched_relative_reference_parse_tree containing_type `clause]]
					      parses]]]]
			[let [[after_first_particle_try_parses [have this parse_sequence_as_clause-verb_objects-after_first_particle_try try_particle_rest_sequence try_particle_parse_tree]]]
			  [= parses [append after_first_particle_try_parses parses]]]]]
		try_particle_parses]]]
    [let [[after_first_particle_try_parses [have this parse_sequence_as_clause-verb_objects-after_first_particle_try sequence parse_tree]]]
      [= parses [append after_first_particle_try_parses parses]]]
    [if [and [get parse_tree containing_type_child_of_type_child_of_type_property `clause `verb_group `verb_word `transitive]
	     [get parse_tree containing_type_with_true_property `clause `secondary]
	     [get parse_tree containing_type_with_true_property `clause `wh]
	     [get parse_tree containing_type_with_true_property `clause `unmatched_relative_reference]]
	[let [[unmatched_relative_reference_parse_tree [get parse_tree new_copy]]]
	  [parse_format '\n    parse_sequence_as_clause-verb_objects: clause is secondary and has transitive verb, so we could be missing a direct object (and be done).']
	  [set unmatched_relative_reference_parse_tree containing_type_with_true_property `clause `unmatched_relative_reference nil]
	  [= parses [cons [frame parse_tree    unmatched_relative_reference_parse_tree
				 rest_sequence sequence
				 clause        [get parse_tree containing_type `clause]]
			  parses]]]]
    
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-with_noun_group_first [sequence parse_tree]
  [let [[parses nil]]
    [let [[noun_group_initial_parse_tree [get parse_tree new_copy]]
	  [noun_group                    [new noun_group]]]
      [parse_format '\n    parse_sequence_as_clause-with_noun_group_first: parsing ' sequence]
      [have noun_group_initial_parse_tree add_child_to_type `clause noun_group]
      [let [[noun_group_parses [have this parse_sequence_as_noun_group sequence noun_group_initial_parse_tree]]]
	[mapc [funk [noun_group_parse]
		    [let [[noun_group_parse_tree    [have noun_group_parse lookup `parse_tree]]
			  [noun_group_rest_sequence [have noun_group_parse lookup `rest_sequence]]]
		      [parse_format '\n    parse_sequence_as_clause-with_noun_group_first: found noun_group parse: ' noun_group_parse_tree]
		      [let [[verb_group_initial_parse_tree [get noun_group_parse_tree new_copy]]
			    [verb_group                    [new verb_group]]]
			[have verb_group_initial_parse_tree add_child_to_type `clause verb_group]
			[let [[verb_first_parses [have this parse_sequence_as_clause-with_verb_group_next noun_group_rest_sequence verb_group_initial_parse_tree]]]
			  [parse_format '\n    parse_sequence_as_clause-with_noun_group_first verb_first_parses: ' verb_first_parses]
			  [= parses [append verb_first_parses parses]]]]]]
	      noun_group_parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-after_relative_pronoun [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n  parsing ' sequence ' as clause-after_relative_pronoun.']
    [let [[question_parses [have this parse_sequence_as_clause-main_question sequence parse_tree]]]
      [= parses [append question_parses parses]]]
    [let [[first_word [first sequence]]]
      [let [[first_word_adverbs [get this definitions_by_type `adverb_word first_word]]]
	[mapc [funk [first_word_adverb]
		    [parse_format '\n  ' first_word ' is an adverb_word.']
		    'assume major clause begins with a single word modifier'
		    ]
	      first_word_adverbs]]]
    [let [[preposition_group_initial_parse_tree [get parse_tree new_copy]]
	  [preposition_group                    [new preposition_group]]]
      [have preposition_group_initial_parse_tree add_child_to_type `clause preposition_group]
      [let [[preposition_group_parses [have this parse_sequence_as_preposition_group sequence preposition_group_initial_parse_tree]]]
	[= parses [append preposition_group_parses parses]]]]
    [let [[first_word [first sequence]]]
      [let [[first_word_binders [get this definitions_by_type `binder_word first_word]]]
	[mapc [funk [first_word_binder]
		    [parse_format '\n  ' first_word ' is a binder_word.']
		    [have this parse_sequence_as_bound_clause sequence parse_tree]]
	      first_word_binders]]]
    [let [[noun_group_first_parses [have this parse_sequence_as_clause-with_noun_group_first sequence parse_tree]]]
      [= parses [append noun_group_first_parses parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-subject_to_object [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parse_sequence_as_clause-subject_to_object: parsing ' sequence '.']
    [let [[noun_group_initial_parse_tree [get parse_tree new_copy]]
	  [noun_group                    [new noun_group]]]
      [parse_format '\n    parse_sequence_as_clause-subject_to_object: parsing ' sequence]
      [have noun_group_initial_parse_tree add_child_to_type `clause noun_group]
      [let [[noun_group_parses [have this parse_sequence_as_noun_group sequence noun_group_initial_parse_tree]]]
	[mapc [funk [noun_group_parse]
		    [let [[noun_group_parse_tree    [have noun_group_parse lookup `parse_tree]]
			  [noun_group_rest_sequence [have noun_group_parse lookup `rest_sequence]]]
		      [parse_format '\n    parse_sequence_as_clause-subject_to_object: found noun_group parse: ' noun_group_parse_tree]
		      [let [[verb_group_initial_parse_tree [get noun_group_parse_tree new_copy]]
			    [verb_group                    [new verb_group]]]
			[have verb_group_initial_parse_tree add_child_to_type `clause verb_group]
			[let [[verb_group_parses [have this parse_sequence_as_verb_group noun_group_rest_sequence verb_group_initial_parse_tree]]]
			  [mapc [funk [verb_group_parse]
				      [let [[verb_group_parse_tree    [have verb_group_parse lookup `parse_tree]]
					    [verb_group_rest_sequence [have verb_group_parse lookup `rest_sequence]]]
					[parse_format '\n    parse_sequence_as_clause-subject_to_object: found verb_group parse: ' verb_group_parse_tree]
					[let [[verb_objects_parses [have this parse_sequence_as_clause-verb_objects verb_group_rest_sequence verb_group_parse_tree]]]
					  [parse_format '\n    parse_sequence_as_clause-subject_to_object: found verb_objects parses: ' verb_objects_parses]
					  [= parses [append verb_objects_parses parses]]]]]
				verb_group_parses]]]]]
	      noun_group_parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause-to_object [sequence parse_tree]
  [let [[parses nil]]
    [parse_format '\n    parse_sequence_as_clause-to_object: parsing ' sequence '.']
    [let [[verb_group_initial_parse_tree [get parse_tree new_copy]]
	  [verb_group                    [new verb_group]]]
      [have verb_group_initial_parse_tree add_child_to_type `clause verb_group]
      [let [[verb_group_parses [have this parse_sequence_as_verb_group sequence verb_group_initial_parse_tree]]]
	[mapc [funk [verb_group_parse]
		    [let [[verb_group_parse_tree    [have verb_group_parse lookup `parse_tree]]
			  [verb_group_rest_sequence [have verb_group_parse lookup `rest_sequence]]]
		      [parse_format '\n    parse_sequence_as_clause-to_object: found verb_group parse: ' verb_group_parse_tree]
		      [parse_format '\n    parse_sequence_as_clause-to_object --calling-> parse_sequence_as_clause-verb_objects on ' verb_group_rest_sequence '.']
		      [let [[verb_objects_parses [have this parse_sequence_as_clause-verb_objects verb_group_rest_sequence verb_group_parse_tree]]]
			[parse_format '\n    parse_sequence_as_clause-to_object: found verb_objects parses: ' verb_objects_parses]
			[= parses [append verb_objects_parses parses]]]]]
	      verb_group_parses]]]
    parses]]

[deftypefunk english_dictionary execute parse_sequence_as_clause [sequence parse_tree]
  [let [[parses nil]]
    [if [get parse_tree containing_type_property `clause `secondary]
	[prog [parse_format '\n    parse_sequence_as_clause: clause is secondary.']
	      [if [get parse_tree containing_type_property `clause `wh]
		  [let [[pronoun_parses [have this parse_sequence_as_pronoun_word sequence parse_tree `clause]]]
		    [parse_format '\n    parse_sequence_as_clause: clause is wh.']
		    [mapc [funk [pronoun_parse]
				[let [[pronoun_parse_tree          [have pronoun_parse lookup `parse_tree]]
				      [pronoun_parse_rest_sequence [have pronoun_parse lookup `rest_sequence]]
				      [pronoun_word                [have pronoun_parse lookup `pronoun_word]]]
				  [if [get pronoun_word relative_clause]
				      [prog [parse_format '\n    noun_group-relative_clause found relative_clause pronoun: ' [get pronoun_word symbols]]
					    [let [[after_relative_pronoun_parses [have this parse_sequence_as_clause-after_relative_pronoun pronoun_parse_rest_sequence pronoun_parse_tree]]]
					      [= parses [append after_relative_pronoun_parses parses]]]]]]]
			  pronoun_parses]]]
	      [if [get parse_tree containing_type_property `clause `subject_to_object]
		  [prog [parse_format '\n    parse_sequence_as_clause: clause is subject_to_object.']
			[let [[subject_to_object_parses [have this parse_sequence_as_clause-subject_to_object sequence parse_tree]]]
			  [parse_format '\n    parse_sequence_as_clause: subject_to_object_parses, ' subject_to_object_parses]
			  [= parses [append subject_to_object_parses parses]]]]]
	      [if [get parse_tree containing_type_property `clause `to_object]
		  [prog [parse_format '\n    parse_sequence_as_clause: clause is to_object.']
			[let [[to_object_parses [have this parse_sequence_as_clause-to_object sequence parse_tree]]]
			  [parse_format '\n    parse_sequence_as_clause: to_object_parses, ' to_object_parses]
			  [= parses [append to_object_parses parses]]]]]
	      ]
      [prog [parse_format '\n    parse_sequence_as_clause: clause is not secondary.']
	    [let [[verb_first_parses [have this parse_sequence_as_clause-imperative_with_verb_first sequence parse_tree]]]
	      [= parses [append verb_first_parses parses]]]
	    [parse_format '\n    parse_sequence_as_clause: parse_sequence_as_clause-after_relative_pronoun.']
	    [let [[after_relative_pronoun_parses [have this parse_sequence_as_clause-after_relative_pronoun sequence parse_tree]]]
	      [= parses [append after_relative_pronoun_parses parses]]]]]
    parses]]

[deftypefunk english_dictionary get parse_trees [sequence]
  [let [[parse_trees nil]]
    [let [[main_clause_parse_tree [new parse_tree]]
	  [main_clause            [new clause]]]
      [have main_clause_parse_tree add_next main_clause]
      [let [[parses [have english_dictionary parse_sequence_as_clause sequence main_clause_parse_tree]]]
	[mapc [funk [parse]
		    [let [[parse_tree          [have parse lookup `parse_tree]]
			  [parse_rest_sequence [have parse lookup `rest_sequence]]]
		      [if [null parse_rest_sequence]
			  [= parse_trees [cons parse_tree parse_trees]]]]]
	      parses]]]
    parse_trees]]


'test funks'

[defunk english_language-test_parse [sequence]
  [let [[parse_trees [get english_dictionary parse_trees sequence]]]
    [mapc [funk [parse_tree]
		[terminal_format standard-terminal '\nserialized: ' [have parse_tree serialize]]
		[fiber [funk [] [have parse_tree gview]] nil]]
	  parse_trees]]
  nil]


[defunk english_language-test []
  [english_language-test_parse `[how many blocks are supported by the cube which I wanted you to pick up]]]


