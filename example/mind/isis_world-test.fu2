
'Copyright (c) 2007-2010 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[deframe          isis_world_body [frame] [name world says]]
[deftypeconstruct isis_world_body [name]
  [set this name  name]
  [set this world nil]
  [set this says  nil]
  this]

[deftypefunk isis_world_body get sense []
  [get [get this world] agent_sense [get this name]]]

[deftypefunk isis_world_body get time_step []
  [get [get this world] time_step]]



[deframe          isis_agent [frame] [name mind body fu_resource fu_args]]
[deftypeconstruct isis_agent [name]
  [let [[mind [new mind]]
	[body [new isis_world_body name]]]
    [set this name name]
    [set this mind mind]
    [set this body body]
    [set this fu_resource nil]
    [set this fu_args     nil]
	 
    
    'All isis_agents inherit these basic features.'
    
    [mind-create_layer mind 0 reactive]
    [mind-create_layer mind 1 learned_reactive]
    [mind-create_layer mind 2 deliberative]
    [mind-create_layer mind 3 reflective]
    [mind-create_layer mind 4 self_reflective]
    [mind-create_layer mind 5 self_conscious]
    
    [mind-create_agency mind reactive        sensory]
    [mind-create_agency mind reactive        physical]
    [mind-create_agency mind reactive        speech]
    [mind-create_agency mind deliberative    reality]
    [mind-create_agency mind deliberative    imagination]
    [mind-create_agency mind reflective      physical]
    [mind-create_agency mind self_reflective physical]
    [mind-create_agency mind self_conscious  imprimer_learning]
    
    [let [[sense-cell [new propogator_cell `sense]]
	  [story-cell [new propogator_cell `story]]]
      [have [mind-knowledge mind reactive sensory] add_constraint
	    [new propogator_constraint `sense->story story-cell [list sense-cell]
		 [funk [sense]
		       [have this think_to_self 'Propogating sense->story.']
		       [let [[sense_agent_frame [have sense lookup `agents]]
			     [story             [new story]]]
			 [let [[agent_names [get sense_agent_frame slots]]]
			   [if agent_names
			       [have this think_to_self 'While propogating sense->story, I can see agents, ' agent_names '.']
			     [have this think_to_self 'While propogating sense->story, I cannot see any other agents.']]
			   [mapc [funk [agent_name]
				       [let [[agent [have sense_agent_frame lookup agent_name]]]
					 [have story add_new_character agent_name]
					 [story-create_event story [get body time_step] `I `sees agent_name]
					 [let [[says [have agent lookup `says]]]
					   [if says
					       [mapc [funk [say]
							   [have this think_to_self 'While propogating sense->story, I can hear ' agent_name ' saying, "' say '"']
							   [story-create_event story [get body time_step] agent_name `says say]]
						     says]]]]]
				 agent_names]]
			 [have this think_to_self 'While propogating sense->story, I created this story: ' [get story as-list] '.']
			 story]]]]
      ]


    

    [mind-create_resource mind reactive physical turn_right [steps]
			  [format stdout '\n  turn_right']
			  [let [[starting_time [get body time_step]]]			
			    [isis-call [get [get this world] client] turn_right-start agent [get this name]]
			    [while [< [- [get body time_step] starting_time] steps]
			      [millisleep 50]]
			    [isis-call [get [get this world] client] turn_right-stop agent [get this name]]]]
    [print 'turn right']
    [mind-create_resource mind reactive physical turn_left [steps]
			  [format stdout '\n  turn_left']
			  [isis-call [get [get this world] client] turn_left-start agent [get this name]]
			  [let [[start_steps [get body time_step]]]
			    [while [< [- [get body time_step] start_steps] steps]
			      [millisleep 50]]
			    [isis-call [get [get this world] client] turn_left-stop agent [get this name]]]]
    [mind-create_resource mind reactive physical look_right [steps]
			  [format stdout '\n  look_right']
			  [let [[starting_time [get body time_step]]]			
			    [isis-call [get [get this world] client] look_right-start agent [get this name]]
			    [while [< [- [get body time_step] starting_time] steps]
			      [millisleep 50]]
			    [isis-call [get [get this world] client] look_right-stop agent [get this name]]]]
    [mind-create_resource mind reactive physical look_left [steps]
			  [format stdout '\n  turn_left']
			  [isis-call [get [get this world] client] look_left-start agent [get this name]]
			  [let [[start_steps [get body time_step]]]
			    [while [< [- [get body time_step] start_steps] steps]
			      [millisleep 50]]
			    [isis-call [get [get this world] client] look_left-stop agent [get this name]]]]
    [mind-create_resource mind reactive physical move_forward [steps]
			  [format stdout '\n  move_forward']
			  [let [[start_steps [get body time_step]]]
			    [isis-call [get [get this world] client] move_forward-start agent [get this name]]
			    [while [< [- [get body time_step] start_steps] steps]
			      [millisleep 50]]
			    [isis-call [get [get this world] client] move_forward-stop agent [get this name]]]]
    
    [mind-create_resource mind reactive physical move_backward [steps]
			  [format stdout '\n  move_backward']
			  [isis-call [get [get this world] client] move_backward-start agent [get this name]]
			  [let [[start_steps [get body time_step]]]
			    [while [< [- [get body time_step] start_steps] steps]
			      [millisleep 50]]
			    [isis-call [get [get this world] client] move_backward-stop agent [get this name]]]]
    [print 'turn left, move forward, etc']
    
     [mind-create_resource mind reactive physical drop_from_right_hand []
			   [format stdout '\n drop_from_right_hand']
			    [isis-call [get [get this world] client] drop_from_right_hand agent [get this name]]]    
    
     
    
     [mind-create_resource mind reactive physical pick_up_with_right_hand [target]
			   [format stdout '\n  pick_up_with_right_hand']
			   [while [null [get this sense]] 
			     [millisleep 100]]
			   [if [get this objects]
			       [if [have [get this objects] lookup `target]
				   [if [> arm_length [have [get this objects] lookup `distance]]
				       [if [null [have [get this sense] lookup `right_hand]]
					   [isis-call [get [get this world] client] pick_up_with_right_hand agent [get this name] target target]
					 [mind-activate [get this mind] reactive physical drop_from_right_hand]]
				     [prog 
				      [mind-activate [get this mind] reactive physical walk_directly_towards target]
				      [isis-call [get [get this world] client] pick_up_with_right_hand agent [get this name] target target]]]
				 [prog 
				  [mind-activate [get this mind] reactive physical walk_directly_towards target]
				  [isis-call [get [get this world] client] pick_up_with_right_hand agent [get this name] target target]]]
			     [prog 
			      [mind-activate [get this mind] reactive physical walk_directly_towards target]
			      [isis-call [get [get this world] client] pick_up_with_right_hand agent [get this name] target target]]]
			   [get body sense]]
     
     
     [mind-create_resource mind reactive physical drop_from_left_hand []
			   [format stdout '\n drop_from_left_hand']
			   [isis-call [get [get this world] client] drop_from_left_hand agent [get this name]]]    
     
     [mind-create_resource mind reactive physical pick_up_with_left_hand [target]
			   [format stdout '\n  pick_up_with_left_hand']
			   [while [null [get this sense]] 
			     [millisleep 100]]
			   [if [get this objects]
			       [if [have [get this objects] lookup `target]
				   [if [> arm_length [have [get this objects] lookup `distance]]
				       [if [null [have [get this sense] lookup `left_hand]]
					   [isis-call [get [get this world] client] pick_up_with_left_hand agent [get this name] target target]
					 [mind-activate [get this mind] reactive physical drop_from_left_hand]]
				     [prog 
				      [mind-activate [get this mind] reactive physical walk_directly_towards target]
				      [isis-call [get [get this world] client] pick_up_with_left_hand agent [get this name] target target]]]
				 [prog 
				  [mind-activate [get this mind] reactive physical walk_directly_towards target]
				  [isis-call [get [get this world] client] pick_up_with_left_hand agent [get this name] target target]]]
			     [prog 
			      [mind-activate [get this mind] reactive physical walk_directly_towards target]
			      [isis-call [get [get this world] client] pick_up_with_left_hand agent [get this name] target target]]]
			   [get body sense]]

     [mind-create_resource mind reactive physical open_fridge [fridge]
			   [format stdout '\n  open_fridge']
			   [while [null [get this sense]] 
			     [millisleep 100]]
			   [if [get this objects]
			       [if [have [get this objects] lookup fridge]
				   [if [> arm_length [have [get this objects] lookup `distance]]
				       [isis-call [get [get this world] client] agent [get this name] open_fridge]
				     [prog 
				      [mind-activate [get this mind] reactive physical walk_directly_towards fridge]
				      [isis-call [get [get this world] client] agent [get this name] open_fridge]]]
				 [prog 
				  [mind-activate [get this mind] reactive physical walk_directly_towards fridge]
				  [isis-call [get [get this world] client] agent [get this name] open_fridge]]]
			     [prog 
			      [mind-activate [get this mind] reactive physical walk_directly_towards fridge]
			      [isis-call [get [get this world] client] agent [get this name] open_fridge]]]
			   [get body sense]]
     
     
       [mind-create_resource mind reactive physical center_body_on [desired_object]
			   [have this think_to_self 'center_body_on_object activated']
			   [deftypefunk isis_agent execute turn_left_and_right []
			     [while [null [get this sense]] 
			       [millisleep 100]]
			     [if [get this objects]
				 [if [have [get this objects] lookup desired_object] 
				     [let [[x_pos [have [have [get this objects] lookup desired_object] lookup `x_pos]]]
				       [cond [[>  x_pos 0.4]
					      [prog [have this think_to_self   'x too positive' x_pos]
						    [mind-activate [get this mind] reactive physical turn_right 1]
						    [while [get [get [get this mind] resource `reactive `physical `turn_right] active]
						      [millisleep 100]
						      [have this think_to_self   'sleeping because turn_right still activated']]
						    [have this think_to_self   'i turned right']
						    [have this turn_left_and_right]]]
					     [[< x_pos [- 0 0.4]]
					      [prog [have this think_to_self   'x too negative' x_pos]
						    [mind-activate [get this mind] reactive physical turn_left 1]
						    [while [get [get [get this mind] resource `reactive `physical `turn_left] active]
						      [millisleep 100]
						      [have this think_to_self   'sleeping because turn_left still activated']]
						    [have this think_to_self 'i turned left']
						    [have this turn_left_and_right]]]
					     [t
					      [have this think_to_self 'centered']]]]
				   [prog [have this think_to_self   'no objects in view']
					 [mind-activate [get this mind] reactive physical search_for desired_object]
					 [have this turn_left_and_right]]]
			       [prog [have this think_to_self   'my_object not in view']
				     [mind-activate [get this mind] reactive physical search_for desired_object]
				     [have this turn_left_and_right]]]]
			   [have this turn_left_and_right]]
     
     [mind-create_resource mind reactive physical center_head_on [desired_object]
			   [print 'center_head_on_object']
			   [deftypefunk isis_agent execute look_left_and_right []
			     [print '0']
			     [while [null [get this sense]] 
			       [millisleep 100]]
			     [if [get this objects]
				 [if [have [get this objects] lookup desired_object] 
				     [let [[y_pos [have [have [get this objects] lookup desired_object] lookup `y_pos]]]
				       [print 'let']
				       [cond [[>  y_pos 0.2]
					      [prog [print 'y too positive']
						    [mind-activate [get this mind] reactive physical look_left 1]
						    [while [get [get [get this mind] resource `reactive `physical `look_left] active]
						      [millisleep 100]
						      [print 'sleeping cus resource still activated']]
						    [print 'i turned left']
						    [have this look_left_and_right]]]
					     [[<  y_pos [- 0 0.2]]
					      [prog [print 'y too negative']
						    [mind-activate [get this mind] reactive physical look_right 1]
						    [while [get [get [get this mind] resource `reactive `physical `look_right] active]
						      [millisleep 100]
						      [print 'sleeping cus resource still activated']]
						    [print 'i turned right']
						    [have this look_left_and_right]]]
					     [t
					      [print 'centered']]]]
				   [mind-activate [get this mind] reactive physical search_for desired_object]]
			       [mind-activate [get this mind] reactive physical search_for desired_object]]]
			   [have this look_left_and_right]]




 [mind-create_resource mind reactive physical walk_towards [desired_object]
			   [mind-activate [get this mind] reactive physical center_body_on desired_object]
			   [deftypefunk isis_agent execute cautiously_walk []
			     [cond [[and [null [have this check_obstacle]] 
					 [< arm_length [have [have [get this objects] lookup desired_object] lookup `distance]]]
				    [prog [mind-activate [get this mind] reactive physical move_forward 1]
					  [have this cautiously_walk]]]
				   [[> arm_length [have [have [get this objects] lookup desired_object] lookup `distance]]
				    nil]
				   [[and [have this check_obstacle] 
					 [< arm_length [have [have [get this objects] lookup desired_object] lookup `distance]]]
				    [mind-activate [get this mind] reactive physical avoid_obstacle desired_object [have this check_obstacle]]]
				   [t
				    [print 'weird, no conditions applied']]]]
			   [have this cautiously_walk]]
     [print 'walk_towards']

     [mind-create_resource mind reactive physical walk_directly_towards [desired_object]
			   [let [[achieved nil]]
			     [have this think_to_self ' walk_directly_towards activated!']
			     [while  [null achieved]
			       [have this think_to_self ' not achieved']
			       [while [null [get this sense]]
				 [have this think_to_self ' sense not ready yet, sleep']
				 [millisleep 100]]
			       [if [get this objects]
				   [if [have [get this objects] lookup desired_object]
				       [if [< arm_length [have [have [get this objects] lookup desired_object] lookup `distance]]
					   [prog 
					    [while [null [get this sense]]
					      [have this think_to_self 'sense not ready yet, sleep']
					      [millisleep 100]]
					    [have this think_to_self 'current distance:' [have [have [get this objects] lookup desired_object] lookup `distance]]
					    [while [< arm_length [have [have [get this objects] lookup desired_object] lookup `distance]]
					      [have this think_to_self 'yes object, activating center on']
					      [mind-activate [get this mind] reactive physical center_body_on desired_object]
					      [while [get [get [get this mind] resource `reactive `physical `center_body_on] active]			
						[millisleep 100]
						[have this think_to_self 'sleep because center on still active']]
					      [have this think_to_self 'activating move_forward']
					      [mind-activate [get this mind] reactive physical move_forward 1]
					      [while [get [get [get this mind] resource `reactive `physical `move_forward] active]
						[millisleep 100]
						[have this think_to_self 'sleep because move forward still active']]
					      [print 'end of while loop']
					      [have this think_to_self 'current distance:' [have [have [get this objects] lookup desired_object] lookup `distance]]]
					    [have this think_to_self 'object within arm_length now']]
					 [prog [have this think_to_self 'finally got it']
					       [= achieved t]]]
				     [prog [have this think_to_self 'dont have object, activating search']
					   [mind-activate [get this mind] reactive physical search_for desired_object]
					   [while [get [get [get this mind] resource `reactive `physical `search_for] active]
					     [millisleep 200]
					     [have this think_to_self 'search still active']]]]   
				 [prog [have this think_to_self 'dont have object, activating search']
				       [mind-activate [get this mind] reactive physical search_for desired_object]
				       [while [get [get [get this mind] resource `reactive `physical `search_for] active]
					 [millisleep 200]
					 [have this think_to_self 'search still active']]]]]
			     [have this think_to_self 'finished walking towards']]]
			   

     'can move waiting for sense to finish in get sense/get object/timestep commands
why does it randomly exit the while loop/??'
     
  
     [mind-create_resource mind reactive physical search_for [desired_object]
			   [let [[patience 30]]
			     [have this think_to_self 'search_for activated']
			     [while 
				 [> patience 0]
			       [have this think_to_self 'patience > 0']
	                       [while [null [get this sense]] 
				 [millisleep 100]]
			       [if [null [get this objects]]
				   [prog 
				    [have this think_to_self  'no objects in view']
				    [mind-activate [get this mind] reactive physical turn_left 1]
				    [while [get [get [get this mind] resource `reactive `physical `turn_left] active]
				      [millisleep 100]
				      [have this think_to_self 'sleeping because turn_left still activated']]]
				 [if [null [have [get this objects] lookup desired_object]]
				     [prog [have this think_to_self 'i see these objects:' [have [get this objects] lookup desired_object]]
					   [mind-activate [get this mind] reactive physical turn_left 1]
					   [print 'activated turn-left']
					   [while [get [get [get this mind] resource `reactive `physical `turn_left] active]
					     [millisleep 100]
					     [have this think_to_self 'sleeping cus turn_left still activated']]
					   [= patience [- patience 1]]
					   [print 'at the end of while: ']]
				   [prog [= patience 0]
					 [have this think_to_self 'found it']]]]]
			     [have this think_to_self 'finished searching']]]
     

     'problem now is lagg in perception, can fix by checking activeness of sensing resource?
      weird! step_simulation suddenly stopped controlling the simulator'
    [print 'search_for']
  
     
     [mind-create_resource mind reactive physical avoid_obstacle [desired_object obstacle]
			   [mind-activate [get this mind] reactive physical center_body_on desired_object]
			   [deftypefunk isis_agent execute walk_around [if_left]
			     [mind-activate [get this mind] reactive physical center_body_on obstacle]
			     [let [[patience 30]]
			       [if if_left
				   [prog [mind-activate [get this mind] reactive physical turn_right 5]
					[while [and [have this check_obstacle desired_object] [> patience 0]]
					  [mind-activate [get this mind] reactive physical move_forward 3]
					  [mind-activate [get this mind] reactive physical center_head_on obstacle]
					  [let [[distance [have [have [get this objects] lokup desired_object] lookup `distance]]]
					    [cond [[> distance 8]
						   [mind-activate [get this mind] reactive physical turn_left 2]]
						  [[> distance 2]
						   [mind-activate [get this mind] reactive physical turn_right 2]]
						  [t
						   [mind-activate [get this mind] reactive physical move_forward 2]]]
					    [mind-activate [get this mind] reactive physical search_for desired_object]
					    [= patience [patience -1]]]]]
				[prog [mind-activate [get this mind] reactive physical turn_left 5]
				      [while [and [have this check_obstacle desired_object] [patience >0]]
					[mind-activate [get this mind] reactive physical move_forward 3]
					[mind-activate [get this mind] reactive physical center_head_on obstacle]
					[let [[distance [have [have [get this objects] lookup desired_object] lookup `distance]]]
					  [cond [[> distance 8]
						 [mind-activate [get this mind] reactive physical turn_right 2]]
						[[> distance 2]
						 [mind-activate [get this mind] reactive physical turn_left 2]]
						[t
						 [mind-activate [get this mind] reactive physical move_forward 2]]]
					  [mind-activate [get this mind] reactive physical search_for desired_object]
					  [= patience [patience -1]]]]]]]]
			  [have this walk_around [> 0 [have [have [get this objects] lookup obstacle] lookup `x_pos]]]		   
			  [mind-activate [get this mind] reactive physical walk_directly_towards desired_object]]
    [print 'avoid obstacle']
    
    
    [mind-create_resource mind reactive sensory continuous_sensing []
			  [have this think_to_self 'Continuous sensing is starting.']
			  [let [[last_time_step nil]]
			    [while t
			      [let [[time_step [get body time_step]]]
				[if [eq last_time_step time_step]
				    [millisleep 100]
				  [let [[sense [get body sense]]]
				    [have this think_to_self 'My body senses the world.']
				    [set [mind-knowledge mind reactive sensory] value `sense `[time_step ,time_step] sense]
				    [= last_time_step time_step]]]]
			      ]]]
    
    [mind-create_resource mind reactive speech say [string]
			  [set body says [list string]]
			  [let [[start_time_step [get body time_step]]]
			    [while [< [- [get body time_step] 2] start_time_step]
			      [millisleep 100]]]
			  [set body says nil]]
    
    [mind-create_resource mind reactive sensory sense_imprimer_scold [imprimer]
			  [if [get [get imprimer speech] is-scold]
			      [prog [have this think_to_self 'Uh oh, my imprimer, ' [get imprimer name] ', said something that sounds like a scold!']
				    [cause-define cause-time_step [get body time_step]]
				    [cause-define cause-name      `[reactive sensory sense_imprimer_scold]]
				    [let [[imprimer_focus [mind-call reactive sensory discover_person_focus imprimer]]]
				      [mind-activate mind self_conscious imprimer_learning react_to_imprimer_scold
						     imprimer imprimer_focus]]]
			    [have this think_to_self 'My imprimer, ' [get imprimer name] ', is not scolding me.']]
			  ]
    
    [let [[reality_story-cell [new propogator_cell `reality_story]]]
      
      [have [mind-knowledge mind deliberative reality] add_cell reality_story-cell]
      
      [mind-create_resource mind deliberative reality include_reactive_stories_into_deliberative_story []
			    [cause-define cause-time_step [get body time_step]]
			    [cause-define cause-name      `[deliberative reality interpret_senses_into_current_story]]
			    [let [[last_time_step     -1]
				  [last_reality_story [new story]]]
			      [while t
				[let [[time_step [get body time_step]]]
				  [if [== last_time_step time_step]
				      [millisleep 100]
				    [let [[knowledge [mind-knowledge mind reactive sensory]]]
				      [let [[reactive_sensory_story [get knowledge value `story `[time_step ,time_step]]]]
					[if [null reactive_sensory_story]
					    [millisleep 1000]
					  [prog [have this think_to_self 'Including reactive sensory story into deliberative story: ' [get reactive_sensory_story as-list]]
						[let [[reality_story [get last_reality_story union reactive_sensory_story]]]
						  [set [mind-knowledge mind deliberative reality] value `reality_story `[time_step ,time_step]
						       reality_story]
						  [= last_reality_story reality_story]]
						[= last_time_step time_step]]]]]]]]]]
      
      ]
    
    [mind-create_resource mind self_conscious imprimer_learning react_to_imprimer_scold [imprimer scold]
			  [have this think_to_self 'Uh oh, my imprimer, ' [get imprimer name] ', has scolded something about ' [get scold focus] '!  How should I react?']
			  ]


    [mind-create_resource mind reactive physical funk_user []
			  [if [null [get this fu_resource]]
			      [sleep 1]
			    [if [null [get this fu_args]]
				[prog [mind-activate [get this mind] reactive physical [get this fu_resource]]
				      [set this fu_resource nil]
				      [set this fu_args nil]]
			      [prog [have [get this mind] activate `reactive `physical [quote ,[get this fu_resource]] @[get this fu_args]]
				    [set this fu_resource nil]
				    [set this fu_args nil]]]]]
    
    ]
  this]

[deftypefunk isis_agent execute user_activate [resource args]
  [set this fu_resource resource]
  [set this fu_args args]]

[deftypefunk isis_agent get world []
  [get [get this body] world]]

[deftypefunk isis_agent get objects []
  [while [null [get this sense]]
    [print 'sense not here yet, sleep']
    [millisleep 100]]
  [have [get [mind-knowledge [get this mind] reactive sensory] value `sense `[time_step ,[get [get this body] time_step]]] lookup `objects]]

[deftypefunk isis_agent get sense []
  [get [mind-knowledge [get this mind] reactive sensory] value `sense `[time_step ,[get [get this body] time_step]]]]


[deftypefunk isis_agent set world [world]
  [set [get this body] world world]]

[deftypefunk isis_agent execute think_to_self [:rest expressions]
  [have cause-resource add_new_trace_story_event [get cause-resource name] `thinks [frame direct_object expressions]]
  [have-apply [get this world] format `['\nAgent ' ,[get this name] ' Thinks: ' @expressions]]]

[deftypefunk isis_agent execute destroy []
  [have [get this mind] destroy]]


[deframe          isis_world [frame] [client agent_frame time_step format_mutex]]
[deftypeconstruct isis_world [client]
  [set this client       client]
  [set this agent_frame  [frame]]
  [set this time_step    0]
  [set this format_mutex [new mutex]]
  this]

[deftypefunk isis_world execute add_agent [agent]
  [if [get agent world]
      [error bug_type isis_agent_is_already_in_a_world agent agent]
    [prog [set agent world this]
	  [have [get this agent_frame] add [get agent name] agent]]]]

[deftypefunk isis_world get agents []
  [get [get this agent_frame] values]]

[deftypefunk isis_world get agent_names []
  [get [get this agent_frame] slots]]

[deftypefunk isis_world get agent [agent_name]
  [have [get this agent_frame] lookup agent_name]]

[deftypefunk isis_world get agent_mind [agent_name]
  [get [get this agent agent_name] mind]]

[deftypefunk isis_world get agent_body [agent_name]
  [get [get this agent agent_name] body]]

[deftypefunk isis_world get agent_says [agent_name]
  [get [get this agent_body agent_name] says]]

[deftypefunk isis_world get agent_sense [agent_name]
  [let [[sense [isis-call [get this client] sense agent agent_name]]]
    [let [[agent_frame [frame]]]
      [mapc [funk [sense_agent_name]
		  [if [not [eq agent_name sense_agent_name]]
		      [have agent_frame add sense_agent_name [frame distance       15.0
								    recent_actions nil
								    says           [get this agent_says sense_agent_name]]]]]
	    [get this agent_names]]
      [have sense add `agents agent_frame]]
    sense]]

[deftypefunk isis_world get agent_sense_info [agent_name]
  [get [mind-knowledge [get this agent_mind agent_name] reactive sensory] value `sense `[time_step ,[get [get this agent_body agent_name] time_step]]]]



[deftypefunk isis_world execute step_simulation []
    [isis-call [get this client] meta_step seconds 0.15]
    [set this time_step [+ 1 [get this time_step]]]]

[deftypefunk isis_world execute mini_step []
    [isis-call [get this client] meta_step seconds 0.02]
    [set this time_step [+ 1 [get this time_step]]]]

[deftypefunk isis_world execute pause_simulation []
  [isis-call [get this client] meta_pause]]

[deftypefunk isis_world execute destroy []
  [mapc [funk [agent]
	      [have agent destroy]]
	[get this agents]]]

[deftypefunk isis_world execute format [:rest expressions]
  [let [[format_mutex [get this format_mutex]]]
    [have format_mutex lock]
    [apply &format [cons stdout expressions]]
    [have format_mutex unlock]]]


[defunk ralph_agent-new []
  [let [[this [new isis_agent `Ralph]]]
    
    this]]

[defunk lauren_agent-new []
  [let [[this [new isis_agent `Lauren]]]
    this]]

[defunk isis_world-initialize [hostname]

  [shelter [have isis_world destroy]]
  [let [[client [new isis_world_client hostname]]]
    [let [[isis_world [new isis_world client]]]
      [have isis_world add_agent [ralph_agent-new]]
      [have isis_world add_agent [lauren_agent-new]]
      
      [globalize isis_world isis_world]
      
      [have isis_world pause_simulation]
      
      [cause-define cause-resource  [resource funk-user [] [print 'Warning: Funk user resource should not be activated.']]]
      [cause-define cause-time_step [get isis_world time_step]]
      [cause-define cause-name      `isis_world-initialize]
      
      [mind-activate [get isis_world agent_mind `Lauren] reactive     speech  say                                              'Bad Ralph!']
      [print 'lauren say']
      [mind-activate [get isis_world agent_mind `Lauren] deliberative reality include_reactive_stories_into_deliberative_story]
      [print 'Lauren story']
      [mind-activate [get isis_world agent_mind `Lauren] reactive     sensory continuous_sensing]
      [print 'lauren conti sense']
      [mind-activate [get isis_world agent_mind `Lauren] reactive     physical  funk_user]
      [print 'lauren funk user']
      
      [mind-activate [get isis_world agent_mind `Ralph]  deliberative reality include_reactive_stories_into_deliberative_story]
      [print 'ralph story']
      [mind-activate [get isis_world agent_mind `Ralph]  reactive     sensory continuous_sensing]
      [mind-activate [get isis_world agent_mind `Ralph] reactive     physical  funk_user]
      
      [format stdout '\nA new ' `isis_world ' object has been created in the global ' `isis_world ' variable!']
      
      'success']]]

[defunk test-step []
  [globalize step_fiber [fiber [funk [] [print [have isis_world step_simulation]]
				     ]
			       nil]]]
[defunk test-mini []
  [globalize step_fiber [fiber [funk [] [print [have isis_world mini_step]]
				     ]
			       nil]]]
[defunk step-loop []
  [dotimes [i 100]
    [have isis_world step_simulation]
    [millisleep 100]
    [print 'step']
    ]]

[isis_world-initialize '18.85.59.46']

