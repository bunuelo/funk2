'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'mind'

[deframe mind [frame] [body
		       layer_frame
		       resources_waiting_for_mental_trigger_event_frame
		       knowledge_event_stream_iterator_frame
		       global_semantic_realm
		       semantic_knowledge_base_ptypehash
		       semantic_knowledge_base_add_event_callback_funks
		       [index_name_type_mutex                 [new mutex]]
		       [index_name_type_ptypehash             [new ptypehash]]
		       [ready_for_physical_world_step_trigger [new fiber_trigger]]]
  [new []
       [terminal_format standard-terminal '\ncreating mind.']
       [cause-define semantic_frame-trace_add                            t]
       [cause-define semantic_frame-trace_remove                         t]
       [cause-define semantic_knowledge_base-trace_add_semantic_frame    t]
       [cause-define semantic_knowledge_base-trace_remove_semantic_frame t]
       [= layer_frame                                      [frame]]
       [= knowledge_event_stream_iterator_frame            [frame]]
       [= semantic_knowledge_base_ptypehash                [new ptypehash]]
       [= semantic_knowledge_base_add_event_callback_funks nil]
       this]]

[deftypefunk mind get name_type_index [name_type]
  [let [[result [have index_name_type_ptypehash lookup name_type]]]
    [if [null result]
	[prog [= result 1]
	      [have index_name_type_ptypehash add name_type result]]]
    result]]

[deftypefunk mind set name_type_index [name_type index]
  [have index_name_type_ptypehash add name_type index]]

[deftypefunk mind get new-name [name_type]
  [have index_name_type_mutex lock]
  [let [[index [get this name_type_index name_type]]]
    [set this name_type_index name_type [+ 1 index]]
    [have index_name_type_mutex unlock]
    [get [string-concat [get name_type as-string] '-' [get index as-string]] as-symbol]]]


[deftypefunk mind get name []
  [if [not [null body]]
      [get body name]
    nil]]

[deftypefunk mind get layers []
  [get [get this layer_frame] values]]

[deftypefunk mind get semantic_realm []
  [if [null global_semantic_realm]
      [= global_semantic_realm [new semantic_realm]]]
  global_semantic_realm]

[deftypefunk mind set semantic_realm [semantic_realm]
  [= global_semantic_realm semantic_realm]]

[deftypefunk mind execute add_layer [layer]
  [if [get layer mind]
      [error bug_type `layer_is_already_part_of_a_mind layer layer mind this]]
  [if [not [is-type `mental_layer layer]]
      [error bug_type `type_error
	     description 'layer should be type mental_layer.']]
  [set layer mind this]
  [have [get this layer_frame] add [get layer name] layer]]

[defmetro mind-create_layer [mind layer_index layer_name]
  `[have ,mind add_layer [new mental_layer ,layer_index [quote ,layer_name]]]]

[deftypefunk mind get layer [name]
  [let [[layer [have [get this layer_frame] lookup name]]]
    [if [null layer]
	[error bug_type   `layer_does_not_exist_in_mind
	       layer_name name]
      layer]]]

[deftypefunk mind get layer_agency_names [name]
  [get [get this layer name] agency_names]]

[defmetro mind-layer [mind layer_name]
  `[get ,mind layer [quote ,layer_name]]]

[deftypefunk mind get layer_names []
  [get [get this layer_frame] slots]]

[deftypefunk mind get layer_count []
  [simple_length [get this layer_names]]]

[deftypefunk mind get time_step []
  [get body time_step]]

[deftypefunk mind get time_step_trigger []
  [get body time_step_trigger]]

[deftypefunk mind execute create_knowledge_event_stream_iterator [knowledge_base_name knowledge_event_stream_iterator_name]
  [let [[knowledge_base [have [get this semantic_realm] lookup_semantic_knowledge_base knowledge_base_name]]]
    [if [null knowledge_base]
	[error bug_type                             `tried_to_create_knowledge_event_stream_iterator_for_nonexistent_knowledge_base
	       knowledge_base_name                  knowledge_base_name
	       knowledge_event_stream_iterator_name knowledge_event_stream_iterator_name]
      [have knowledge_event_stream_iterator_frame add knowledge_event_stream_iterator_name [get knowledge_base new-event_stream_iterator]]]]]

[deftypefunk mind get knowledge_event_stream_iterator [knowledge_event_stream_iterator_name]
  [have knowledge_event_stream_iterator_frame lookup knowledge_event_stream_iterator_name]]


[deftypefunk mind execute add_agency [layer_name agency]
  [have [get this layer layer_name] add_agency agency]]

[defmetro mind-create_agency [mind layer_name agency_name]
  `[have ,mind add_agency [quote ,layer_name] [new agency [quote ,agency_name]]]]


[deftypefunk mind get agency [layer_name agency_name]
  [get [get this layer layer_name] agency agency_name]]

[defmetro mind-agency [mind layer_name agency_name]
  `[get ,mind agency [quote ,layer_name] [quote ,agency_name]]]


[deftypefunk mind execute add_resource [layer_name agency_name resource]
  [have [get this agency layer_name agency_name] add_resource resource]]

[defmetro mind-create_resource [mind layer_name agency_name resource_name resource_args :rest resource_body]
  `[have ,mind add_resource [quote ,layer_name] [quote ,agency_name] [resource ,resource_name ,resource_args @resource_body]]]


[deftypefunk mind get layer_agency_resource_names [layer_name agency_name]
  [get [get this layer layer_name] agency_resource_names agency_name]]

[deftypefunk mind get layer_agency_resource_count [layer_name agency_name]
  [get [get this layer layer_name] agency_resource_count agency_name]]

[deftypefunk mind execute call [layer_name agency_name resource_name :rest args]
  [let [[layer_frame [get this layer_frame]]]
    [let [[layer [have layer_frame lookup layer_name]]]
      [have-apply layer call `[,agency_name ,resource_name @args]]]]]

[defmetro mind-call [mind layer_name agency_name resource_name :rest args]
  `[have ,mind call [quote ,layer_name] [quote ,agency_name] [quote ,resource_name] @args]]

[deftypefunk mind execute wait_to_call [layer_name agency_name resource_name :rest args]
  [let [[layer_frame [get this layer_frame]]]
    [let [[layer [have layer_frame lookup layer_name]]]
      [have-apply layer wait_to_call `[,agency_name ,resource_name @args]]]]]

[defmetro mind-wait_to_call [mind layer_name agency_name resource_name :rest args]
  `[have ,mind wait_to_call [quote ,layer_name] [quote ,agency_name] [quote ,resource_name] @args]]

[deftypefunk mind execute activate [layer_name agency_name resource_name :rest args]
  [let [[layer_frame [get this layer_frame]]]
    [let [[layer [get this layer layer_name]]]
      [have-apply layer activate `[,agency_name ,resource_name @args]]]]]

[defmetro mind-activate [mind layer_name agency_name resource_name :rest args]
  `[have ,mind activate [quote ,layer_name] [quote ,agency_name] [quote ,resource_name] @args]]

[deftypefunk mind execute wait_to_activate [layer_name agency_name resource_name :rest args]
  [let [[layer_frame [get this layer_frame]]]
    [let [[layer [get this layer layer_name]]]
      [have-apply layer wait_to_activate `[,agency_name ,resource_name @args]]]]]

[defmetro mind-wait_to_activate [mind layer_name agency_name resource_name :rest args]
  `[have ,mind wait_to_activate [quote ,layer_name] [quote ,agency_name] [quote ,resource_name] @args]]

[deftypefunk mind execute add_semantic_knowledge_base [semantic_knowledge_base]
  [let [[name [get semantic_knowledge_base name]]]
    [have semantic_knowledge_base_ptypehash add name semantic_knowledge_base]]
  [mapc [funk [callback_funk]
	      [funkall callback_funk semantic_knowledge_base]]
	semantic_knowledge_base_add_event_callback_funks]]

[deftypefunk mind get semantic_knowledge_base [name]
  [let [[semantic_knowledge_base [have semantic_knowledge_base_ptypehash lookup name]]]
    [if [null semantic_knowledge_base]
	[error bug_type                     `mind-get-semantic_knowledge_base-not_defined
	       semantic_knowledge_base_name name]
      semantic_knowledge_base]]]

[deftypefunk mind get semantic_knowledge_bases []
  [get semantic_knowledge_base_ptypehash values]]

[deftypefunk mind execute add_semantic_knowledge_base_add_event_callback_funk [callback_funk]
  [= semantic_knowledge_base_add_event_callback_funks [cons callback_funk semantic_knowledge_base_add_event_callback_funks]]]  

[deftypefunk mind get resource [layer_name agency_name resource_name]
  [get [get this layer layer_name] resource agency_name resource_name]]

[deftypefunk mind get resources []
  [let [[resources nil]]
    [mapc [funk [layer]
		[mapc [funk [agency]
			    [mapc [funk [resource]
					[= resources [cons resource resources]]]
				  [get agency resources]]]
		      [get layer agencies]]]
	  [get this layers]]
    resources]]

[deftypefunk mind execute activate_vital_resources []
  [mapc [funk [resource]
	      [if [get resource vital]
		  [prog `[terminal_format standard-terminal '\n  mind-activate_vital_resources: ' [get resource name] ' is vital.']
			[while [not [get resource initialized]]
			  `[terminal_format standard-terminal '\n  mind-activate_vital_resources: waiting for ' [get resource name] ' resource to initialize.']
			  `[terminal_format standard-terminal '\n                                 waiting for ' [get resource name] ' fiber=' [get resource fiber]]
			  [sleep 1]]
			`[terminal_format standard-terminal '\n  mind-activate_vital_resources: activating ' [get resource name] '!']
			[have resource activate]]]]
	[get this resources]]]

[deftypefunk mind get self_model []
  [let [[self_model [new self_model]]]
    [mapc [funk [layer]
		[mapc [funk [agency]
			    [mapc [funk [resource]
					[have self_model add_activity [get layer name] [get agency name] [get resource name] [get resource active]]]
				  [get agency resources]]]
		      [get layer agencies]]]
	  [get this layers]]
    self_model]]

[deftypefunk mind execute destroy []
  [mapc [funk [resource]
	      [have resource destroy]]
	[get this resources]]]

[deftypefunk mind execute quit []
  [have this destroy]
  [sleep 1]
  [mapc [funk [resource]
	      [have resource quit]]
	[get this resources]]]

[deftypefunk mind execute print_stack_traces []
  [let [[resources [get this resources]]]
    [mapc [funk [resource]
		[format stdout '\n' '***' [get resource name] '***']
		[have resource print_stack_trace]]
	  resources]]]

