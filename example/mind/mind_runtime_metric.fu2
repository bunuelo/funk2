'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'mind_runtime_metric_point'

[deframe mind_runtime_metric_point [frame] [real_time
					    bytecode_count
					    execution_nanoseconds
					    bytes_allocated_count]
  [new [initial-real_time
	initial-bytecode_count
	initial-execution_nanoseconds
	initial-bytes_allocated_count]
       [= real_time             initial-real_time]
       [= bytecode_count        initial-bytecode_count]
       [= execution_nanoseconds initial-execution_nanoseconds]
       [= bytes_allocated_count initial-bytes_allocated_count]
       nil]]

[defunk mind_runtime_metric_point-new_from_cause_group [cause_group]
  [new mind_runtime_metric_point
       [time]
       [get cause_group bytecode_count]
       [get cause_group execution_nanoseconds]
       [get cause_group bytes_allocated_count]]]

'mind_runtime_metric_monitor_ticker'

[deframe mind_runtime_metric_monitor_ticker [[trigger [new fiber_trigger]]
					     [done    nil]
					     fiber]
  [new []
       [= fiber [fiber [funk []
			     [while [not done]
			       [sleep 120]
			       [have trigger trigger]]]
		       nil]]
       nil]]

[deftypefunk mind_runtime_metric_monitor_ticker execute wait_for_tick []
  [wait-for-trigger trigger]]

[globalize global_mind_runtime_metric_monitor_ticker [new mind_runtime_metric_monitor_ticker]]

'mind_runtime_metric_monitor'

[deframe mind_runtime_metric_monitor [frame] [cause_group
					      fiber
					      [done            nil]
					      [metric_sequence nil]]
  [new [initial-cause_group]
       [= cause_group initial-cause_group]
       [= fiber       [fiber [funk []
				   [while [not done]
				     [let [[metric [mind_runtime_metric_point-new_from_cause_group cause_group]]]
				       [= metric_sequence [cons metric metric_sequence]]]
				     [have global_mind_runtime_metric_monitor_ticker wait_for_tick]]]
			     nil]]
       nil]]

[deftypefunk mind_runtime_metric_monitor get bytecode_count_plot_text [time_offset]
  [let [[line_strings nil]
	[prev_metric  nil]
	[metric_iter  metric_sequence]]
    [while metric_iter
      [let [[metric [car metric_iter]]]
	[if prev_metric
	    [let [[prev_metric_value     [get prev_metric bytecode_count]]
		  [prev_metric_real_time [get prev_metric real_time]]
		  [metric_value          [get metric      bytecode_count]]
		  [metric_real_time      [get metric      real_time]]]
	      [let [[real_time_diff [- prev_metric_real_time metric_real_time]]
		    [value_diff     [- prev_metric_value     metric_value]]]
		[let [[output_x [/ [/ [get [get [- metric_real_time time_offset] total_nanoseconds] as-double]
				      1000000000]
				   60]]
		      [output_y [/ [/ [get value_diff as-double]
				      [/ [get [get real_time_diff total_nanoseconds] as-double]
					 1000000000]]
				   1000]]]
		  [let [[line_string [format nil output_x ' ' output_y '\n']]]
		    [= line_strings [cons line_string line_strings]]]]]]]
	[= prev_metric metric]
	[= metric_iter [cdr metric_iter]]]]
    [stringlist-concat line_strings]]]

[deftypefunk mind_runtime_metric_monitor execute save_bytecode_count_plot [time_offset filename_root]
  [assert-type string filename_root]
  [let [[filename [format nil filename_root '-bytecode_count.data']]]
    [have [get this bytecode_count_plot_text time_offset] save filename]
    [terminal_format standard-terminal '\nmind_runtime_metric_monitor done saving bytecode_count plot "' filename '"']]]


[deftypefunk mind_runtime_metric_monitor get execution_nanoseconds_plot_text [time_offset]
  [let [[line_strings nil]
	[prev_metric  nil]
	[metric_iter  metric_sequence]]
    [while metric_iter
      [let [[metric [car metric_iter]]]
	[if prev_metric
	    [let [[prev_metric_value     [/ [get [get prev_metric execution_nanoseconds] as-double] 1000000000]]
		  [prev_metric_real_time         [get prev_metric real_time]]
		  [metric_value          [/ [get [get metric      execution_nanoseconds] as-double] 1000000000]]
		  [metric_real_time              [get metric      real_time]]]
	      [let [[real_time_diff [- prev_metric_real_time metric_real_time]]
		    [value_diff     [- prev_metric_value     metric_value]]]
		[let [[output_x [/ [/ [get [get [- metric_real_time time_offset] total_nanoseconds] as-double]
				      1000000000]
				   60]]
		      [output_y [/ [get value_diff as-double]
				   [/ [get [get real_time_diff total_nanoseconds] as-double]
				      1000000000]]]]
		  [let [[line_string [format nil output_x ' ' output_y '\n']]]
		    [= line_strings [cons line_string line_strings]]]]]]]
	[= prev_metric metric]
	[= metric_iter [cdr metric_iter]]]]
    [stringlist-concat line_strings]]]

[deftypefunk mind_runtime_metric_monitor execute save_execution_nanoseconds_plot [time_offset filename_root]
  [assert-type string filename_root]
  [let [[filename [format nil filename_root '-execution_seconds.data']]]
    [have [get this execution_nanoseconds_plot_text time_offset] save filename]
    [terminal_format standard-terminal '\nmind_runtime_metric_monitor done saving execution_nanoseconds plot "' filename '"']]]


[deftypefunk mind_runtime_metric_monitor get bytes_allocated_count_plot_text [time_offset]
  [let [[line_strings nil]
	[prev_metric  nil]
	[metric_iter  metric_sequence]]
    [while metric_iter
      [let [[metric [car metric_iter]]]
	[if prev_metric
	    [let [[prev_metric_value     [get prev_metric bytes_allocated_count]]
		  [prev_metric_real_time [get prev_metric real_time]]
		  [metric_value          [get metric      bytes_allocated_count]]
		  [metric_real_time      [get metric      real_time]]]
	      [let [[real_time_diff [- prev_metric_real_time metric_real_time]]
		    [value_diff     [- prev_metric_value     metric_value]]]
		[let [[output_x [/ [/ [get [get [- metric_real_time time_offset] total_nanoseconds] as-double]
				      1000000000]
				   60]]
		      [output_y [/ [/ [get value_diff as-double]
				      [* 1024.0 1024.0]]
				   [/ [get [get real_time_diff total_nanoseconds] as-double]
				      1000000000]]]]
		  [let [[line_string [format nil output_x ' ' output_y '\n']]]
		    [= line_strings [cons line_string line_strings]]]]]]]
	[= prev_metric metric]
	[= metric_iter [cdr metric_iter]]]]
    [stringlist-concat line_strings]]]

[deftypefunk mind_runtime_metric_monitor execute save_bytes_allocated_count_plot [time_offset filename_root]
  [assert-type string filename_root]
  [let [[filename [format nil filename_root '-bytes_allocated_count.data']]]
    [have [get this bytes_allocated_count_plot_text time_offset] save filename]
    [terminal_format standard-terminal '\nmind_runtime_metric_monitor done saving bytes_allocated_count plot "' filename '"']]]


[deftypefunk mind_runtime_metric_monitor execute save_all_plots [time_offset filename_root]
  [parog [have this save_bytecode_count_plot        time_offset filename_root]
	 [have this save_execution_nanoseconds_plot time_offset filename_root]
	 [have this save_bytes_allocated_count_plot time_offset filename_root]]]



[deftypefunk mind_runtime_metric_monitor execute quit []
  [= done t]
  [have fiber quit]]


