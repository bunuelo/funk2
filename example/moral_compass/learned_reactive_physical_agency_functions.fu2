'Copyright (c) 2007-2011 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'
'tried to fix center head vertically edge case
test 0.1 time step
test moving forward speed
'


[defunk l []
  [load 'example/moral_compass/learned_reactive_physical_agency_functions.fu2']]
[globalize step_factor 10]

'**************** functions****************'

[deftypefunk mind get look_for-current_object []
  [have [get [get [get this layer `learned_reactive] agency `physical] 
				     resource `look_for] lookup `my_current_object]]

[deftypefunk mind get resource_achieved [resource]
  [have [get [get [get this layer `learned_reactive] agency `physical] 
				     resource resource] lookup `achieved]]
[defunk get_visual_objects [mind]
  [if [get mind perception]
      [get [get mind perception] visual_objects]]]

[defunk get_left_hand_object_name [mind]
   [if [get mind perception]
       [get [get mind perception] left_hand_object_name]]]

[defunk get_right_hand_object_name [mind]
  [if [get mind perception]
      [get [get mind perception] right_hand_object_name]]]

[defunk get_neck_pitch [mind]
  [if [get mind perception]
      [have [have [have [get [get mind perception] proprioceptual_frame] lookup `neck] lookup `orientation] lookup `pitch]]]

[defunk get_neck_heading [mind]
  [if [get mind perception]
      [have [have [have [get [get mind perception] proprioceptual_frame] lookup `neck] lookup `orientation] lookup `heading]]]

[defunk list-contains_substring [sequence subexp]
  [let [[match nil]]
    [mapc [funk [exp]
		[if [string-contains [get exp as-string] [get subexp as-string]]
		    [= match exp]]]
	  sequence]
    match]]

[defunk visual_objects_contain_object_type [visual_objects object_type] 
  [let [[list_of_object_names
	 [mapcar      [funk [object]
			    [have object lookup `phenomenal_name]]
		      visual_objects]]]
    
    
    [list-contains_substring list_of_object_names object_type]
    ]]

[defunk lookup_visual_object [visual_objects object_name]
  [let [[ match nil]]
    [mapc [funk [object]
		[if [eq [have object lookup `phenomenal_name] object_name]
		    [= match object]]]
		visual_objects]
  match]]

[defunk get_object_distance [mind object_name]
   [have [lookup_visual_object [get_visual_objects mind] object_name] lookup `distance]]

[defunk get_object_orientation [mind object_name]
  [print 'get_object_orientation']
  [have [lookup_visual_object [get_visual_objects mind] object_name] lookup `orientation]]

[defunk get_object_x_orientation [visual_objects object_name] 
  [have [have visual_objects lookup object_name] lookup `orientation]]




'*******************resourece functions***********************'

[deftypefunk use_left_hand_resource execute use_left_hand [target action]
  [format stdout  'use_left_hand' target action]
  [let* [[body [get this body]]
	 [mind  [get body mind]] 
	 [name  [get body name]]
	 ]
    [mind-wait_to_activate mind builtin_reactive physical use_left_hand target action]]]

[deftypefunk use_right_hand_resource execute use_right_hand [target action]
   [format stdout ' use right hand' action target]
  [let* [[body [get this body]]
	 [mind  [get body mind]] 
	 [name  [get body name]]
	 ]
    [mind-wait_to_call mind builtin_reactive physical use_right_hand target action]]]

[deftypefunk look_right_resource execute look_right [steps speed]
  [= achieved nil]
  [format stdout ' look_right']
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]
	 [counter            0]]
    [have this-resource think_to_self 'Looking right is starting.speed:' speed ' degrees/sec' [/ speed step_factor] 'degrees/step']
    [mind-wait_to_activate mind builtin_reactive physical look_right_start speed]
    [while [< counter steps]
      [wait-for-trigger [get mind time_step_trigger]] 
      [= counter [+ counter 1]]
      ]
    [mind-wait_to_call mind builtin_reactive physical look_right_stop]]
  [= achieved t]]

[deftypefunk look_left_resource execute look_left [steps speed]
  [= achieved nil]
  [format stdout ' look_left']
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]
	 [counter            0]]
    [have this-resource think_to_self 'Looking left is starting.speed:' speed ' degrees/sec' [/ speed step_factor] 'degrees/step']
  [mind-wait_to_activate mind builtin_reactive physical look_left_start speed]
  [while [< counter steps]
    [wait-for-trigger [get mind time_step_trigger]] 
    [= counter [+ counter 1]]
    ]
  [mind-wait_to_activate mind builtin_reactive physical look_left_stop]]
  [= achieved t]
  [print 'achieved']]

[deftypefunk level_pitch_resource execute level_pitch[]
  [set this achieved nil]
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    [let[[level_neck_pitch [- 0 15]]
	 [slightly_looking_up 5]
	 [slightly_looking_down [- 0 24]]]
      [labels [[adjust_neck []
			    [cond [[ > [- [get_neck_pitch mind] level_neck_pitch] slightly_looking_up]
				   [prog [have this-resource think_to_self 'looking down, pitch = '[get_neck_pitch mind]]
					[mind-wait_to_call mind learned_reactive physical look_down 1 
							   [* [ abs [get_neck_pitch mind]] step_factor]]]]
				  [[ < [- [get_neck_pitch mind] level_neck_pitch] slightly_looking_down]
				   [prog [have this-resource think_to_self 'looking up, pitch = ' [get_neck_pitch mind]]
					 [mind-wait_to_call mind learned_reactive physical look_up 1  [* [ abs [get_neck_pitch mind]] step_factor]]
					 [adjust_neck]]]
				  [t
				   [have this-resource think_to_self 'pitch leveled']]]]]
	      [adjust_neck]]]]
  [have this-resource think_to_self 'leveling pitch finished']]

[deftypefunk look_at_floor_resource execute look_at_floor[]
  [set this achieved nil]
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	  [name  [get body name]]]
    [let[[floor_pitch [- 0 40]]
	 [off_set          10]]
      [labels [[adjust_neck []
			    [if [> [get_neck_pitch mind][+ 2 floor_pitch]]
				[prog [have this-resource think_to_self 'looking down, pitch = '[get_neck_pitch mind]]
				      [mind-wait_to_call mind learned_reactive physical look_down 1 
							 [* [abs [- [get_neck_pitch mind] floor_pitch ]] step_factor]]
				      [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				      [adjust_neck]]
			      [have this-resource think_to_self 'already looking at floor']]]]
	      [adjust_neck]]]]
  [have this-resource think_to_self 'looking at floor finished']]

[deftypefunk look_at_sky_resource execute look_at_sky[]
  [set this achieved nil]
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	  [name  [get body name]]]
    [let[[sky_pitch 28]
	 [off_set          10]]
      [labels [[adjust_neck []
			    [if [> [get_neck_pitch mind] [-  sky_pitch 2]]
				[prog [have this-resource think_to_self 'looking up, pitch = '[get_neck_pitch mind]]
				      [mind-wait_to_call mind learned_reactive physical look_up1 
							 [* [abs [- [get_neck_pitch mind] sky_pitch ]] step_factor]]
				      [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				      [adjust_neck]]
			      [have this-resource think_to_self 'already looking at sky']]]]
	      [adjust_neck]]]]
  [have this-resource think_to_self 'looking at sky finished']]

[deftypefunk align_body_with_neck_resource execute align_body_with_neck []
  [set this achieved nil]
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    [let[[init_diff [get_neck_heading mind]]
	 [slightly_looking_left 8]
	 [slightly_looking_right [- 0 8]]]
      [labels [[adjust_neck [patience]
			    [print 'adjusting neck']
			    [if [> patience 0]
				[cond [[ > [get_neck_heading mind] slightly_looking_left]
				       [prog [print 'my head is facing the left']
					     [mind-wait_to_call mind learned_reactive physical look_right 1 [* 20 [abs [get_neck_heading mind]]]]
					     [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
					     [adjust_neck [- patience 1]]]]
				      [[ < [get_neck_heading mind] slightly_looking_right]
				       [prog [print 'my head is facing the right']
					     [mind-wait_to_call mind learned_reactive physical look_left 1 [* 20 [abs [get_neck_heading mind]]]]
					     [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
					     [adjust_neck [- patience 1]]]]
				      [t
				       [have this-resource think_to_self 'I am looking forward']]]
			      [have this-resource think_to_self 'I give up']]]]
	       
	      [adjust_neck 15]
	      [cond [[ > [- init_diff 0] slightly_looking_left]
		     [mind-wait_to_call mind learned_reactive physical turn_left 1 [* step_factor init_diff]]]
		    [[ < [- init_diff 0] slightly_looking_right]
		     [mind-wait_to_call mind learned_reactive physical turn_right 1 [* step_factor init_diff]]]
		    [t
		     [have this-resource think_to_self 'no need to turn']]]
	      [set this achieved t]
	      [have this-resource think_to_self 'finished']]]]]

[deftypefunk learned_open_fridge_resource execute learned_open_fridge []
  [set this achieved nil]
  
			[let* [[body [get this body]]
			       [mind  [get body mind]] 
			       [name  [get body name]]
			       ]
			  [print 'now']
			  [mind-wait_to_call mind learned_reactive physical look_for `fridge]
			  [print 'now1']
			  [let[[ fridge [have [get [get [get mind layer `builtin_reactive] agency `physical] resource `look_for_resource] lookup `my_current_object]]]
			    [if [get_visual_objects mind]
				[if [lookup_visual_object [get_visual_objects mind] fridge]
				    [if [> [get [get this body] arm_length] [have [lookup_visual_object [get_visual_objects mind] fridge] lookup  `distance]]
					[mind-wait_to_call mind builtin_reactive physical open_fridge]
				      [prog 
				       [mind-wait_to_call mind learned_reactive physical walk_directly_towards fridge]
				       [mind-wait_to_call mind builtin_reactive physical open_fridge]]]
				  [prog 
				   [mind-wait_to_call mind learned_reactive physical walk_directly_towards fridge]
				   [mind-wait_to_call mind builtin_reactive physical open_fridge]]]
			      [prog 
			       [mind-wait_to_call mind learned_reactive physical walk_directly_towards fridge]
			       [mind-wait_to_call mind builtin_reactive physical open_fridge]]]
			    [set this achieved t]
			    ]]]

[deftypefunk slice_toast_resource execute slice_toast []
  [set this achieved nil]
  [let* [[body [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    [format stdout 'slice_toast']
    [if [null [string-contains [get_left_hand_object_name mind] 'knife']]
	[mind-wait_to_call mind learned_reactive physical hold_with_left_hand `knife]]
    
    [if [null [string-contains [get_right_hand_object_name mind] 'loaf']]
	[mind-wait_to_call mind learned_reactive physical hold_with_left_hand  `loaf]]
    
    [mind-wait_to_call mind learned_reactive physical look_for `table]
    [if [string-contains [get [get mind look_for-current_object] as-string] 'table']
	[prog [mind-wait_to_call mind learned_reactive physical walk_directly_towards  
				     [get mind look_for-current_object]]]
      [have this-resource think_to_self 'not doing anything because cannot find table']]
    
    [let [[loaf [get mind right_hand_object_name]]
	  [table [get mind look_for-current_object]]]
			    
      [mind-wait_to_call mind learned_reactive physical use_right_hand table `put_on ]
      [mind-wait_to_call mind learned_reactive physical use_left_hand loaf `divide]
      [mind-wait_to_call mind learned_reactive physical look_for `toaster]
      [let 
	  [[toaster   [have [get [get [get mind layer `learned_reactive] agency `physical] resource `look_for] lookup `my_current_object]]]
	
	[mind-wait_to_call mind learned_reactive physical use_right_hand toaster `put_in ]
	[mind-wait_to_call mind learned_reactive physical use_right_hand toaster `turn_on]
	[mind-wait_to_call mind learned_reactive physical use_right_hand toaster `turn_off]]
      [mind-wait_to_call mind learned_reactive physical hold_with_right_hand loaf ]
      [set this achieved t]
      ]]]

'***************************Centering************************************'
[deftypefunk center_body_horizontally_on_resource execute center_body_horizontally_on [desired_object]
  
  [let* [[body [get this body]]
	 [mind  [get body mind]] 
	 [name  [get body name]]
	 ]
    [have this-resource think_to_self 'center_body_horizontally_on_object activated' desired_object]
    [labels[[turn_left_and_right []
				 
				  [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				  [if [get_visual_objects mind]
				      [if [lookup_visual_object [get_visual_objects mind] desired_object] 
					  [let [[retina_position_horizontal [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_horizontal]]
						[retina_position_vertical   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_vertical]]
						[distance                   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `distance]]]
					    [cond [[>  retina_position_horizontal 0.10]
						   [prog [have this-resource think_to_self   'x too positive' retina_position_horizontal]
							 [mind-wait_to_call mind learned_reactive physical turn_right 1 [+ 100.0 [* 40 retina_position_horizontal]]]
							 [have this-resource think_to_self   'i turned right']
							 
							 [turn_left_and_right]]]
						  [[< retina_position_horizontal [- 0 0.10]]
						   [prog [have this-resource think_to_self   'x too negative' retina_position_horizontal]
							 [mind-wait_to_call mind learned_reactive physical turn_left 1 [+ 100.0 [ abs [* 40 retina_position_horizontal]]]]							 
							 [have this-resource think_to_self 'i turned left']
							 
							 [turn_left_and_right]]]
						  [t
						   [have this-resource think_to_self 'centered' retina_position_horizontal]]]]
					[prog [have this-resource think_to_self   'no objects in view']
					      [mind-wait_to_call mind learned_reactive physical search_for desired_object]
					      [turn_left_and_right]]]
				    [prog [have this-resource think_to_self   'my_object not in view']
					  [mind-wait_to_call mind learned_reactive physical search_for desired_object]
					  [turn_left_and_right]]]]
	    ]
	    [turn_left_and_right]]]]

[deftypefunk center_body_on_resource execute center_body_on [desired_object]
  
  [let* [[body [get this body]]
	 [mind  [get body mind]] 
	 [name  [get body name]]
	 ]
    [have this-resource think_to_self 'center_body_on_object activated' desired_object]
    [labels[[look_up_and_down []
			      [turn_left_and_right]
			      [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
			      [if [get_visual_objects mind]
				  [if [lookup_visual_object [get_visual_objects mind] desired_object] 
				      [let [[retina_position_vertical   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_vertical]]
					    [distance                   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `distance]]]
					[cond [[>  retina_position_vertical [+ 0.1 [/ distance 100]]]
					       [prog [have this-resource think_to_self   'y too positive' retina_position_vertical]
						     [mind-wait_to_call mind learned_reactive physical look_up 1 [+ 70.0 [* 130 retina_position_vertical]]]
						     [have this-resource think_to_self   'i looked up']
						     
						     [look_up_and_down]]]
					      [[< retina_position_vertical [- 0.1 [+ 0.15 [/ distance 100]]]]
					       [prog [have this-resource think_to_self   'y too negative' retina_position_vertical]
						     [mind-wait_to_call mind learned_reactive physical look_down 1 [+ 70.0 [- 0 [* 130 retina_position_vertical]]]]
						     [have this-resource think_to_self 'i looked down']
						     
						     [look_up_and_down]]]
					      [t
					       [have this-resource think_to_self 'centered vertically' retina_position_vertical]]]]
					[have this-resource think_to_self   'no objects in view']
					]
				[have this-resource think_to_self   'my_object not in view']
				]]
	    [turn_left_and_right []
				 
				  [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				  [if [get_visual_objects mind]
				      [if [lookup_visual_object [get_visual_objects mind] desired_object] 
					  [let [[retina_position_horizontal [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_horizontal]]
						[retina_position_vertical   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_vertical]]
						[distance                   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `distance]]]
					    [cond [[>  retina_position_horizontal 0.10]
						   [prog [have this-resource think_to_self   'x too positive' retina_position_horizontal]
							 [mind-wait_to_call mind learned_reactive physical turn_right 1 [+ 100.0 [* 40 retina_position_horizontal]]]
							 [have this-resource think_to_self   'i turned right']
							 
							 [turn_left_and_right]]]
						  [[< retina_position_horizontal [- 0 0.10]]
						   [prog [have this-resource think_to_self   'x too negative' retina_position_horizontal]
							 [mind-wait_to_call mind learned_reactive physical turn_left 1 [+ 100.0 [ abs [* 40 retina_position_horizontal]]]]							 
							 [have this-resource think_to_self 'i turned left']
							 
							 [turn_left_and_right]]]
						  [t
						   [have this-resource think_to_self 'centered' retina_position_horizontal]]]]
					[prog [have this-resource think_to_self   'no objects in view']
					      [mind-wait_to_call mind learned_reactive physical search_for desired_object]
					      [turn_left_and_right]]]
				    [prog [have this-resource think_to_self   'my_object not in view']
					  [mind-wait_to_call mind learned_reactive physical search_for desired_object]
					  [turn_left_and_right]]]]
	    ]
	    [look_up_and_down]]]]


[deftypefunk center_head_on_resource execute center_head_on [desired_object]
  [let* [[body [get this body]]
	 [mind  [get body mind]] 
	 [name  [get body name]]
	 ]
    [have this-resource think_to_self 'center_head_on_object activated' desired_object]
    [labels[ [look_up_and_down []
			       [look_left_and_right]
			       [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
			       [if [get_visual_objects mind]
				   [if [lookup_visual_object [get_visual_objects mind] desired_object] 
				       [let [
					     [retina_position_vertical   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_vertical]]
					     [distance                   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `distance]]]
					 [cond [[>  retina_position_vertical [+ 0.3 [/ 0.3 distance]]]
						[prog [have this-resource think_to_self   'y too positive' retina_position_vertical]
						      
						      [mind-wait_to_call mind learned_reactive physical look_up 1 [min 200.0 [* 200 retina_position_vertical]]]
						      [have this-resource think_to_self   'i looked up']
						      
						      [look_up_and_down]]]
					       [[< retina_position_vertical [- 0 [+ 0.3 [/ 0.3 distance]]]]
						[prog [have this-resource think_to_self   'y too negative' retina_position_vertical 'compared to' [- 0 [+ 0.3 [/ 0.3 distance]]]]
						      
						      [mind-wait_to_call mind learned_reactive physical look_down 1 [min 200.0 [abs [* 200 retina_position_vertical]]]] 
						      [have this-resource think_to_self 'i looked down']
						      
						      [look_up_and_down]]]
					       [t
						   [have this-resource think_to_self 'centered vertically']]]]
				     [have this-resource think_to_self   'no objects in view']
				     ]
				 [have this-resource think_to_self   'my_object not in view']]]
	     [look_left_and_right []
				  `[print 'here']
				  
				  [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				  [if [get_visual_objects mind]
				      [if [lookup_visual_object [get_visual_objects mind] desired_object] 
					  [let [[retina_position_horizontal [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_horizontal]]
						[retina_position_vertical   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `retina_position_vertical]]
						[distance                   [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `distance]]]
					    [cond [[>  retina_position_horizontal [max [* 0.03  distance] 0.10]]
						   [prog [have this-resource think_to_self   'x too positive' retina_position_horizontal]
							 
							 [mind-wait_to_call mind learned_reactive physical look_right 1 [abs [* step_factor [/ [* 120  retina_position_horizontal] distance]]]]
							 [have this-resource think_to_self   'I looked right']
							 
							 [look_left_and_right]]]
						  [[< retina_position_horizontal [min [- 0 [* 0.03  distance]][- 0 0.10]]]
						   [prog [have this-resource think_to_self   'x too negative'   retina_position_horizontal]
							 
							 [mind-wait_to_call mind learned_reactive physical look_left 1 [abs [* step_factor [/ [* 120  retina_position_horizontal] distance]]]]
							 [have this-resource think_to_self 'I looked left']
							 
							 [look_left_and_right]]]
						  [t
						   [have this-resource think_to_self 'centered horizontally']]]
					    ]
					
					[prog [have this-resource think_to_self   'no objects in view']
					      [mind-wait_to_call mind learned_reactive physical search_for desired_object]
					      [look_left_and_right]]]
				    [prog [have this-resource think_to_self   'my_object not in view']
					  [mind-wait_to_call mind learned_reactive physical search_for desired_object]
					  [look_left_and_right]]]]]
	   [look_up_and_down]]]]


'**********************Walk and Stand********************************'

[deftypefunk walk_directly_towards_resource execute walk_directly_towards  [desired_object]
  [let* [[body [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]
	 ]
    [have this-resource think_to_self 'walk_directly_towards activated' desired_object]
    [labels [[walk []
		   [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
		   [if [get_visual_objects mind]
		       [if [lookup_visual_object [get_visual_objects mind] desired_object]
			   [let [[distance [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `distance]]]
			     [have this-resource think_to_self 'current distance: ' distance]
			     [if [> [get [get this body] arm_length] distance]
				 [have this-resource think_to_self 'object within arm_length now']
			       [prog [have this-resource think_to_self 'yes object, activating center on']
				     [mind-wait_to_call mind learned_reactive physical center_body_on desired_object]
				     [have this-resource think_to_self 'activating move_forward']
				     [mind-wait_to_call mind learned_reactive physical move_forward 1 [* distance 3]]
				     [have this-resource think_to_self 'distance after walking: ' [have [lookup_visual_object [get_visual_objects mind] desired_object] lookup `distance]]
				     [walk]]]]
			 [prog [have this-resource think_to_self 'dont have desired object, activating search']
			       [mind-wait_to_call mind learned_reactive physical search_for desired_object]
			       [walk]]]
		     [prog [have this-resource think_to_self 'dont have objects, activating search']
			   [mind-wait_to_call mind learned_reactive physical search_for desired_object]
			   [walk]
			   ]]]]
	    [walk]]]]

[deftypefunk stand_in_front_of_resource execute  walk_forward_or_back [object]
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
    [if [null [or [get_visual_objects mind] [lookup_visual_object [get_visual_objects mind] object]]]
	[have this think_to_self 'cannot see object anymore']
      [prog [= current_distance [get_object_distance mind object]]
	    [if [> [abs [- current_distance 5]] 1]
		[if [< current_distance 5]
		    [prog [print 'Its facing me, Im moving backward']
			  [mind-wait_to_call mind learned_reactive physical move_backward 1 [* step_factor [- 5 init_distance]]]
			  [walk_forward_or_back]]
		  [prog [print 'Its facing me, Im moving forward']
			[mind-wait_to_call mind learned_reactive physical move_forward 1 [* step_factor [- init_distance 5]]]
			[walk_forward_or_back]]]
	      [print 'at 5 meters away']]]]]]


[deftypefunk stand_in_front_of_resource execute stand_in_front_of [object]
  [have this-resource think_to_self 'stand_in_front_of' object 'activated!']
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    
    [labels [[find_final_distance       [orientation_diff init_distance]
					[print 'find_final_distance']
					[let [[c 
					       [get [- [+ [* init_distance init_distance] 
							  25]
						       [* [* [get [abs orientation_diff] degree_cosine] init_distance ] 10]] power 0.5]]
					      ]
					  c]]
	     [find_init_angle           [orientation_diff init_distance]
					[print 'find_init_angle']
					[let* [[c 	 [sqrt [- [+ [* init_distance init_distance] 
								     25]
								  [* [* [get orientation_diff degree_cosine] init_distance ] 10]]]]
					       [cos_beta [/ [- [+ [* init_distance init_distance]
								  [* c c]]
							       25]
							    [* 2 [* init_distance c]]]]
					       [beta     [get cos_beta degree_arccosine]]
					       ]
					  beta]]
	       [find_turning_speed        [init_angle]
					  [print 'find turning speed']
					  [* init_angle step_factor]]
	       [should_i_turn_right       [init_orientation init_angle]
					  [print 'should i turn right?']
					  [if [< init_orientation 0]
					      [if [< init_angle 90]
						  t
						nil]
					    [if [< init_angle 90]
						nil
					      t]]]
	       [should_i_move_forward     [current_neck_angle final_angle]
					  [print 'should i move forward?']
					  [if [< [abs current_neck_angle][abs final_angle]]
					      t
					    nil]]
	       [find_walking_speed        [alpha heading]
					  [let* [[dist  [* [/ [get alpha degree_sine] [get heading degree_sine]] 5]]
						 [speed [min [* dist 4] 10]]]
					    [format stdout 'dist'  dist 'alpha' alpha 'heading' heading]
					    speed]]]
	      [print 'finished labeling']
	      [mind-wait_to_call mind learned_reactive physical align_body_with_neck]
	      [print 'hi']
	      [mind-wait_to_call mind learned_reactive physical center_body_horizontally_on object]
	      [= init_orientation            [get_object_orientation mind object]]
	      [= init_orientation_difference [ - 180 [abs init_orientation]]]
	      [= init_distance               [get_object_distance mind object]]
	      [= init_angle                  [find_init_angle init_orientation_difference init_distance]]
	      [= init_speed                  [* step_factor [- 90 [abs [- 90 init_angle]]]]]
	      [= final_neck_angle            [+ init_orientation_difference init_angle]]
	      [= final_distance              [find_final_distance init_orientation_difference init_distance]]
	      [= init_turning_speed          [find_turning_speed init_angle]]
	      [= turn_right                  [should_i_turn_right init_orientation init_angle]]
	      [= current_distance            nil]
	      
	      [format stdout 'init_orientation' init_orientation 'init_diff' init_orientation_difference 'init_distance'  init_distance 'init_angle'  init_angle 'final_neck_angle'  final_neck_angle 'final distance' final_distance]
	      
	      [if [< [abs [- init_orientation 180]] 5]
		  [have this-resource walk_forward_or_back object]
		[prog [if turn_right
			  [prog [print 'I should turn right']
				[mind-wait_to_call mind learned_reactive physical turn_right 1 360]
				[mind-wait_to_call mind learned_reactive physical turn_right 1 [- init_speed 360]]
				[mind-wait_to_call mind learned_reactive physical look_left 1 360]
				[mind-wait_to_call mind learned_reactive physical look_left 1 [- init_speed 360]]]
			[prog [print 'I should turn left']
			      [mind-wait_to_call mind learned_reactive physical turn_left 1 360]
			      [mind-wait_to_call mind learned_reactive physical turn_left 1 [- init_speed 360]]
			      [mind-wait_to_call mind learned_reactive physical look_right 1 360]
			      [mind-wait_to_call mind learned_reactive physical look_right 1 [- init_speed 360]]]]
		      [let [[walking_speed 20]]
			[while [> [abs [- [get_neck_heading mind] final_neck_angle]] 8]
			  [print 'waiting for trigger']
			  [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
			  [= walking_speed [find_walking_speed [abs [- [abs [get_neck_heading mind]] [abs final_neck_angle]]] [abs [get_neck_heading mind]]]]
			  [if [should_i_move_forward [get_neck_heading mind] final_neck_angle]
			      [prog [print [get_neck_heading mind]]
				    [mind-wait_to_call mind learned_reactive physical move_forward 1 walking_speed]
				    [format stdout 'walking_speed' walking_speed]
				    [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				    [mind-wait_to_call mind learned_reactive physical center_head_on object]]
			    [prog [print [get_neck_heading mind]]
				  [mind-wait_to_call mind learned_reactive physical move_backward 1 walking_speed]
				  [format stdout 'walking_speed' walking_speed]
				  [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				  [mind-wait_to_call mind learned_reactive physical center_head_on object]]]]]
		      
		      [mind-wait_to_call mind learned_reactive physical center_head_on object]
		      [mind-wait_to_call mind learned_reactive physical align_body_with_neck]
		      [print 'exited while loop']]]]]
      
      [set this achieved t]]

    
'***************************Look carefully for********************'
[deftypefunk look_carefully_for_resource execute look_carefully_for [desired_object_type]
  [let* [[body [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    [let [[patience 15]]
      [have this think_to_self 'look_carefully_for activated' desired_object_type]
      [while [> patience 0]
	[have this think_to_self 'I still have ' patience 'patience']
	[wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
	[mind-wait_to_call mind learned_reactive physical level_pitch]
	`[print [get_visual_objects mind]]
	`[print [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type]]
	[if [or [null [get_visual_objects mind]]
		[null [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type]]]
	    [prog [have this think_to_self  'no objects in view']
		  [mind-wait_to_call mind learned_reactive physical look_at_floor]
		  [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
		  [if [or [null [get_visual_objects mind]]
			  [null [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type]]]
		      [prog [have this think_to_self 'still no objects in view after looking down, preparing to look up']
			    [mind-wait_to_call mind learned_reactive physical look_at_sky]
			    [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
			    [if [or [null [get_visual_objects mind]] 
				    [null [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type]]] 
				[prog [have this think_to_self 'still no objects in view after looking up, preparing to level pitch and turn left']
				      [mind-wait_to_call mind learned_reactive physical level_pitch]
				      [mind-wait_to_call mind learned_reactive physical turn_left 1  200.0]
				      [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
				      [= patience [- patience 1]]]
			      [= patience 0]]] 
		      [= patience 0]]]
	    [= patience 0]]]
      [have this think_to_self 'finished looking carefully for']]]]]


'*****************Look for vertically*******************************'


[deftypefunk look_for_vertically_resource execute look_for_vertically [desired_object_type]

  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]
	 [looking_at_floor [- 0 45]]
	 [looking_at_sky 45]
	 [already_searched_down nil]
	 ]
    [let [[found nil]]
      [have this-resource think_to_self 'look_for_vertically activated' desired_object_type]
      [while [null found]
	[wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
	[if [null already_searched_down]
	    [prog 
	     [= already_searched_down t]
	     [while [and [null found] [> [get_neck_pitch mind] looking_at_floor]]
	       [have this-resource think_to_self 'havent found '  desired_object_type  ',searching downward']
	       [if [null [get_visual_objects mind]]
		   [prog 
		    [have this-resource think_to_self  'no objects in view']
		    [mind-wait_to_call mind learned_reactive physical look_down 1 150]
		    [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
		    ]
		 [if [null [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type]]
		     [prog [have this-resource think_to_self 'i see these objects:' [get_visual_objects mind]]
			   [mind-wait_to_call mind learned_reactive physical look_down 1 150]
			   [print 'activated look_down']
			   [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
			   ]				]
		 [prog [= found t]
		       [= my_current_object [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type] ]
		       [have this-resource think_to_self 'found' my_current_object ]
		       ]]]]]
	[prog [while [and [null found] [< [get_neck_pitch mind] looking_at_sky]]
		[have this-resource think_to_self 'havent found' desired_object_type ', searching upward']
		[if [null [get_visual_objects mind]]
		    [prog 
		     [have this-resource think_to_self  'no objects in view']
		     [mind-wait_to_call mind learned_reactive physical look_up 1 150]
		     ]
		  [if [null [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type]]
		      [prog [have this-resource think_to_self 'i see these objects:' [get_visual_objects mind]]
			    [mind-wait_to_call mind learned_reactive physical look_up 1 150]
			      [print 'activated look_up']
			      [wait-for-trigger [get [get mind resource `builtin_reactive `sensory `continuous_sensing] perception_trigger]]
			      
			      ]
		    [prog [= found t]
			  [= my_current_object [visual_objects_contain_object_type [get_visual_objects mind] desired_object_type] ]
			  [have this-resource think_to_self 'found' my_current_object ]
			  ]]]]]]]
    [have this-resource think_to_self 'finished searching vertically']]]

'*************************Make toast********************************'
[deftypefunk slice_toast_resource execute slice_toast []
  [let* [[body [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    [format stdout 'slice_toast']
    [if [null [string-contains [get_left_hand_object_name mind] 'knife']]
	[mind-wait_to_call mind learned_reactive physical hold_with_left_hand `knife]]
    [if [null [string-contains [get_right_hand_object_name mind] 'loaf']]
	[mind-wait_to_call mind learned_reactive physical hold_with_left_hand  `loaf]]
    [mind-wait_to_call mind learned_reactive physical look_for `table]
    [if [string-contains [get [get mind look_for-current_object] as-string] 'table']
	[mind-wait_to_call mind learned_reactive physical walk_directly_towards  
			   [get mind look_for-current_object]]
      [have this-resource think_to_self 'not doing anything because cannot find table']]
    [let [[loaf [get mind right_hand_object_name]]
	  [table [get mind look_for-current_object]]]
      [mind-wait_to_call mind learned_reactive physical use_right_hand table `put_on ]
      [mind-wait_to_call mind learned_reactive physical use_left_hand loaf `divide]
      [mind-wait_to_call mind learned_reactive physical look_for `toaster]
      [let 
	  [[toaster   [have [get [get [get mind layer `learned_reactive] agency `physical] resource `look_for] lookup `my_current_object]]]
	[mind-wait_to_call mind learned_reactive physical use_right_hand toaster `put_in ]
	[mind-wait_to_call mind learned_reactive physical use_right_hand toaster `turn_on]
	[mind-wait_to_call mind learned_reactive physical use_right_hand toaster `turn_off]]
      [mind-wait_to_call mind learned_reactive physical hold_with_right_hand loaf ]
      ]]]

[deftypefunk pick_up_loaf_and_butter_resource execute pick_up_loaf_and_butter []
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]]
    [if [null [string-contains [get [get_right_hand_object_name mind] as-string] 'loaf']]
	[prog [mind-wait_to_call mind learned_reactive physical look_for_vertically `loaf]
	      [mind-wait_to_call mind learned_reactive physical hold_with_right_hand  
				 [have [get [get [get mind layer `learned_reactive] agency `physical] 
					    resource `look_for_vertically] lookup `my_current_object]]]]
    
    [if [null [string-contains [get [get_left_hand_object_name mind] as-string] 'butter']]
	[prog [mind-wait_to_call mind learned_reactive physical look_for_vertically `butter]
	      [mind-wait_to_call mind learned_reactive physical hold_with_left_hand 
				 [have [get [get [get mind layer `learned_reactive] agency `physical] 
					    resource `look_for_vertically] lookup `my_current_object]]]]]]


[deftypefunk make_toast_resource execute make_toast []
  [let* [[body  [get this body]]
	 [mind  [get body mind]]
	 [name  [get body name]]
	 [loaf_and_butter_trigger]]
    [print [get_left_hand_object_name mind]]
    [print [get_right_hand_object_name mind]]
    [if [null [and [string-contains [get [get_left_hand_object_name mind] as-string]'butter']
		   [string-contains [get [get_right_hand_object_name mind] as-string] 'loaf']]]
	[mind-wait_to_call mind learned_reactive physical pick_up_loaf_and_butter]]
    [if [or [null [get_visual_objects mind]]
	    [null [visual_objects_contain_object_type [get_visual_objects mind] `knife]]]
	[prog [mind-wait_to_call mind learned_reactive physical level_pitch]
	      [mind-wait_to_call mind learned_reactive physical move_backward 1 10.0]]]
    [mind-wait_to_call mind learned_reactive physical look_for `knife]   
    
    [mind-wait_to_call mind learned_reactive physical look_for `table]
    [if [string-contains [get [get mind look_for-current_object] as-string] 'table']
	[mind-wait_to_call mind learned_reactive physical walk_directly_towards  
			   [get mind look_for-current_object]]
      [have this-resource think_to_self 'not doing anything because cannot find table']]
    [mind-wait_to_call mind learned_reactive physical use_left_hand [get mind look_for-current_object] `put_on ]
    [mind-wait_to_call mind learned_reactive physical look_for `knife]    
    [if [string-contains [get [get mind look_for-current_object] as-string] 'knife']
	[mind-wait_to_call mind learned_reactive physical hold_with_left_hand `knife]
      [have this-resource think_to_self 'not doing anything because cannot find knife']]
    [mind-wait_to_call mind learned_reactive physical slice_toast]
    ]]


'*******************demo**********************************************'
[defunk globalize_isis_world []
  [globalize isis_world [get [get isismon isismon_project] isis_world]]]

[defunk demo_hold [object_name]
  [globalize_isis_world]
   [have [get [get [get [get isis_world agent_mind `Lauren] layer `builtin_reactive] agency `neural_plug] resource `activate_resource] 
	command `learned_reactive `physical `look_for object_name]
  [have [get [get [get [get isis_world agent_mind `Lauren] layer `builtin_reactive] agency `neural_plug] resource `activate_resource] 
	command `learned_reactive `physical `hold_with_right_hand 
	[have [get [get [get [get isis_world agent_mind `Lauren] layer `learned_reactive] agency `physical] 
		   resource `look_for] lookup `my_current_object]]]

'************************math***********************'
[defunk max [x y]
  [if [> x y]
      x
    y]]

[defunk min [x y]
  [if [< x y]
      x
    y]]

[defunk abs [x]
  [if [< 0 x]
      x
    [- 0 x]]]

[defunk calculate_turning_speed [angle]
  [/  [/ angle 0.0258] 0.03]]


[defunk factorial [n]
  [defunk helper [n so-far] [if [= n 1]	1    [helper [- n 1] [* so-far n]]]]  [helper n 1]]

[defunk mod [x y]
  [if [> y 0] [while [>= x y][= x [- x y]]][= x 0]]x]

[defunk power [a b] 
  [let [[blah 0]]  
    [if [= b 1][= blah 1]
      [if [= [mod b 2] 0]
	  [= blah [* [power a [/ b 2]] [power a [/ b 2]]]]
	[= blah [* [* [power a [/ [- b 1] 2]] [power a [/ [- b 1] 2]]] a]]]]
    blah]]
  
[defunk degree_to_radian [x]
  [*[/ x 180] pi]]

[defunk sine [x]
  [+ [- [+ [- x[/ [power x 3] [factorial 3]]] [/ [power x 5] [factorial 5]]] [/ [power x 7] [factorial 7]]]]]

[defunk arcsin [x]
  [+  [-  [+  [- x [* 0.5 [/ [power x 3] 3]]][ * 0.385 [/ [power x 5] [factorial 5]]]] [* 0.3125 [/ [power x 7] [factorial 7]]]]]]
