'Copyright (c) 2007-2011 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'learned_reactive_physical_knowledge_agency'

[deframe learned_reactive_physical_knowledge_agency [agency] []
  [new []
       [construct agency `physical_knowledge]
       [have this add_resource [new translate_visual_knowledge_to_physical_knowledge_resource]]
       [have this add_resource [new translate_physical_knowledge_to_physical_type_knowledge_resource]]
       this]]


[deftypefunk learned_reactive_physical_knowledge_agency execute create_knowledge []
  [new meta_semantic_knowledge_base `physical_knowledge      [get [get this mind] semantic_realm]]
  [new meta_semantic_knowledge_base `physical_type_knowledge [get [get this mind] semantic_realm]]
  ]

[deftypefunk learned_reactive_physical_knowledge_agency execute connect_knowledge_reflection []
  [have [get this mind] create_knowledge_event_stream_iterator `visual_knowledge   `visual_knowledge->physical_knowledge]
  [have [get this mind] create_knowledge_event_stream_iterator `physical_knowledge `physical_knowledge->physical_type_knowledge]
  ]



'translate_visual_knowledge_to_physical_knowledge_resource'

[deframe translate_visual_knowledge_to_physical_knowledge_resource [traced_resource] []
  [new []
       [construct traced_resource `translate_visual_knowledge_to_physical_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_visual_knowledge_to_physical_knowledge_resource get semantic_physical_object [phenomenal_name]
  [let [[semantic_physical_object [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]]
    [if [null semantic_physical_object]
	[prog [= semantic_physical_object [new semantic_physical_object [get [get this mind] semantic_realm]]]
	      [semantic-set semantic_physical_object phenomenal_name phenomenal_name]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_physical_object]
	      ]]
    semantic_physical_object]]

[deftypefunk translate_visual_knowledge_to_physical_knowledge_resource execute execute_resource_raw_funk []
  [let [[visual_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `visual_knowledge->physical_knowledge]]]
    [while t
      `[print 'translate_visual_knowledge_to_physical_knowledge_resource waiting for visual_knowledge_iterator.']
      [let [[event [have visual_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [have this-resource think_to_self 'translate visual->physical visual event: ' event]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `add_semantic_frame]]           [let [[semantic_frame [get event semantic_frame]]]
										 [if [is-type `semantic_visual_object semantic_frame]
										     [let [[phenomenal_name [semantic-get semantic_frame phenomenal_name]]]
										       [let [[semantic_physical_object [get this semantic_physical_object phenomenal_name]]]
											 [semantic-set semantic_physical_object object_type [semantic-get semantic_frame object_type]]
											 [have [get [get this mind] semantic_knowledge_base `physical_knowledge] add_semantic_frame semantic_physical_object]
											 ]]]]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[key_type [get event key_type]]
										     [key      [get event key]]]
										 [cond [[eq key_type `preposition] [cond [[eq key `in] [let [[subject [get event semantic_frame]]
																	     [object  [get event value]]]
																	 [let [[subject-phenomenal_name [semantic-get subject phenomenal_name]]
																	       [object-phenomenal_name  [semantic-get object  phenomenal_name]]]
																	   [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name]]
																		 [object-semantic_physical_object  [get this semantic_physical_object object-phenomenal_name]]]
																	     [have subject-semantic_physical_object assure_exists `preposition `in object-semantic_physical_object]]]]]
															 [[eq key `on] [let [[subject [get event semantic_frame]]
																	     [object  [get event value]]]
																	 [let [[subject-phenomenal_name [semantic-get subject phenomenal_name]]
																	       [object-phenomenal_name  [semantic-get object  phenomenal_name]]]
																	   [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name]]
																		 [object-semantic_physical_object  [get this semantic_physical_object object-phenomenal_name]]]
																	     [have subject-semantic_physical_object assure_exists `preposition `on object-semantic_physical_object]]]]]
															 ]]
										       ]]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_visual_changes]]        [prog [have [get [get this mind] semantic_knowledge_base `physical_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_changes nil]]
										     nil]]
			  ]]]]
	[have visual_knowledge_iterator increment]]]]]



'translate_physical_knowledge_to_physical_type_knowledge_resource'

[deframe translate_physical_knowledge_to_physical_type_knowledge_resource [traced_resource] []
  [new []
       [construct traced_resource `translate_physical_knowledge_to_physical_type_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_type [phenomenal_name]
  [let [[semantic_physical_object_type [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]]
    [if [null semantic_physical_object_type]
	[prog [= semantic_physical_object_type [new semantic_physical_object_type [get [get this mind] semantic_realm]]]
	      [semantic-set semantic_physical_object_type phenomenal_name phenomenal_name]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_physical_object_type]
	      ]]
    semantic_physical_object_type]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute execute_resource_raw_funk []
  [let [[physical_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `physical_knowledge->physical_type_knowledge]]]
    [while t
      [let [[event [have physical_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [if [get this debug] [terminal_format standard-terminal '\n  translate physical->physical_type_relationship event: ' event]]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[and [eq event-key_type `property] [eq event-key `object_type]]
											[terminal_format standard-terminal '\ndebug: got object_type ' event-value]
											'create semantic_physical_object_type.'
											[get this semantic_physical_object_type event-value]
											]
										       [[and [eq event-key_type `preposition] [eq event-key `on]]
											[terminal_format standard-terminal '\ndebug: got add preposition-on relation.']
											[let [[event-semantic_frame-object_type [semantic-get event-semantic_frame object_type]]
											      [event-value-object_type          [semantic-get event-value          object_type]]]
											  [let [[event-semantic_frame-semantic_object_type [get this semantic_physical_object_type event-semantic_frame-object_type]]
												[event-value-semantic_object_type          [get this semantic_physical_object_type event-value-object_type]]]
											    [let [[relation_set [have event-semantic_frame-semantic_object_type lookup `preposition_on event-value-object_type]]
												  [relation     nil]]
											      [if [or [null relation_set] [get relation_set is_empty]]
												  [prog [= relation [new semantic_physical_object_type_relation [get [get this mind] semantic_realm] event-value-semantic_object_type]]
													[have event-semantic_frame-semantic_object_type add `preposition_on event-value-object_type relation]]
												[= relation [get relation_set an_arbitrary_element]]]
											      
											      ]]]]
										       [[and [eq event-key_type `preposition] [eq event-key `in]]
											[terminal_format standard-terminal '\ndebug: got add preposition-in relation.']
											[let [[event-semantic_frame-object_type [semantic-get event-semantic_frame object_type]]
											      [event-value-object_type          [semantic-get event-value          object_type]]]
											  [let [[event-semantic_frame-semantic_object_type [get this semantic_physical_object_type event-semantic_frame-object_type]]
												[event-value-semantic_object_type          [get this semantic_physical_object_type event-value-object_type]]]
											    [let [[relation_set [have event-semantic_frame-semantic_object_type lookup `preposition_in event-value-object_type]]
												  [relation     nil]]
											      [if [or [null relation_set] [get relation_set is_empty]]
												  [prog [= relation [new semantic_physical_object_type_relation [get [get this mind] semantic_realm] event-value-semantic_object_type]]
													[have event-semantic_frame-semantic_object_type add `preposition_in event-value-object_type relation]]
												[= relation [get relation_set an_arbitrary_element]]]
											      
											      ]]]]
										       ]
										 ]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `remove]]                       [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[and [eq event-key_type `preposition] [eq event-key `on]]
											[terminal_format standard-terminal '\ndebug: got remove preposition-on relation.']
											]
										       [[and [eq event-key_type `preposition] [eq event-key `in]]
											[terminal_format standard-terminal '\ndebug: got remove preposition-in relation.']
											]
										       ]
										 ]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_physical_changes]]      [prog [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_type_changes nil]]
										     nil]]
			  ]]]]
	[have physical_knowledge_iterator increment]]]]]



