'Copyright (c) 2007-2011 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'learned_reactive_physical_knowledge_agency'

[deframe learned_reactive_physical_knowledge_agency [agency] []
  [new []
       [construct agency `physical_knowledge]
       [have this add_resource [new translate_visual_knowledge_to_physical_knowledge_resource]]
       [have this add_resource [new translate_physical_knowledge_to_physical_type_knowledge_resource]]
       this]]


[deftypefunk learned_reactive_physical_knowledge_agency execute create_knowledge []
  [new meta_semantic_knowledge_base `physical_knowledge      [get [get this mind] semantic_realm]]
  [new meta_semantic_knowledge_base `physical_type_knowledge [get [get this mind] semantic_realm]]
  ]

[deftypefunk learned_reactive_physical_knowledge_agency execute connect_knowledge_reflection []
  [have [get this mind] create_knowledge_event_stream_iterator `visual_knowledge   `visual_knowledge->physical_knowledge]
  [have [get this mind] create_knowledge_event_stream_iterator `physical_knowledge `physical_knowledge->physical_type_knowledge]
  ]



'translate_visual_knowledge_to_physical_knowledge_resource'

[deframe translate_visual_knowledge_to_physical_knowledge_resource [traced_resource] []
  [new []
       [construct traced_resource `translate_visual_knowledge_to_physical_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_visual_knowledge_to_physical_knowledge_resource get semantic_physical_object [phenomenal_name object_type]
  [let [[semantic_physical_object [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]]
    [if [null semantic_physical_object]
	[prog [= semantic_physical_object [new semantic_physical_object [get [get this mind] semantic_realm]]]
	      [semantic-set semantic_physical_object phenomenal_name phenomenal_name]
	      [semantic-set semantic_physical_object object_type     object_type]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_physical_object]
	      ]]
    semantic_physical_object]]

[deftypefunk translate_visual_knowledge_to_physical_knowledge_resource execute execute_resource_raw_funk []
  [let [[visual_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `visual_knowledge->physical_knowledge]]]
    [while t
      `[print 'translate_visual_knowledge_to_physical_knowledge_resource waiting for visual_knowledge_iterator.']
      [let [[event [have visual_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [have this-resource think_to_self 'translate visual->physical visual event: ' event]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `add_semantic_frame]]           [let [[semantic_frame [get event semantic_frame]]]
										 [if [is-type `semantic_visual_object semantic_frame]
										     [let [[phenomenal_name [semantic-get semantic_frame phenomenal_name]]
											   [object_type     [semantic-get semantic_frame object_type]]]
										       [let [[semantic_physical_object [get this semantic_physical_object phenomenal_name object_type]]]
											 [have [get [get this mind] semantic_knowledge_base `physical_knowledge] add_semantic_frame semantic_physical_object]
											 ]]]]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[key_type [get event key_type]]
										     [key      [get event key]]]
										 [cond [[eq key_type `preposition] [cond [[eq key `in] [let [[subject [get event semantic_frame]]
																	     [object  [get event value]]]
																	 [let [[subject-phenomenal_name [semantic-get subject phenomenal_name]]
																	       [subject-object_type     [semantic-get subject object_type]]
																	       [object-phenomenal_name  [semantic-get object  phenomenal_name]]
																	       [object-object_type      [semantic-get object  object_type]]
																	       ]
																	   [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name subject-object_type]]
																		 [object-semantic_physical_object  [get this semantic_physical_object object-phenomenal_name  object-object_type]]]
																	     [have subject-semantic_physical_object assure_exists `preposition `in object-semantic_physical_object]]]]]
															 [[eq key `on] [let [[subject [get event semantic_frame]]
																	     [object  [get event value]]]
																	 [let [[subject-phenomenal_name [semantic-get subject phenomenal_name]]
																	       [subject-object_type     [semantic-get subject object_type]]
																	       [object-phenomenal_name  [semantic-get object  phenomenal_name]]
																	       [object-object_type      [semantic-get object  object_type]]]
																	   [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name subject-object_type]]
																		 [object-semantic_physical_object  [get this semantic_physical_object object-phenomenal_name  object-object_type]]]
																	     [have subject-semantic_physical_object assure_exists `preposition `on object-semantic_physical_object]]]]]
															 ]]
										       ]]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_visual_changes]]        [prog [have [get [get this mind] semantic_knowledge_base `physical_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_changes nil]]
										     nil]]
			  ]]]]
	[have visual_knowledge_iterator increment]]]]]



'translate_physical_knowledge_to_physical_type_knowledge_resource'

[deframe translate_physical_knowledge_to_physical_type_knowledge_resource [traced_resource] []
  [new []
       [construct traced_resource `translate_physical_knowledge_to_physical_type_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_type [phenomenal_name]
  [let [[semantic_physical_object_type [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]]
    [if [null semantic_physical_object_type]
	[prog [= semantic_physical_object_type [new semantic_physical_object_type [get [get this mind] semantic_realm]]]
	      [semantic-set semantic_physical_object_type phenomenal_name phenomenal_name]
	      [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame semantic_physical_object_type]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_physical_object_type]
	      ]]
    semantic_physical_object_type]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute execute_resource_raw_funk []
  [let [[physical_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `physical_knowledge->physical_type_knowledge]]]
    [while t
      [let [[event [have physical_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [if [get this debug] [terminal_format standard-terminal '\n  translate physical->physical_type event: ' event]]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[and [eq event-key_type `property] [eq event-key `object_type]]
											'create semantic_physical_object_type.'
											[get this semantic_physical_object_type event-value]
											]
										       [[and [eq event-key_type `preposition] [eq event-key `on]]
											[let [[event-semantic_frame-object_type [semantic-get event-semantic_frame object_type]]
											      [event-value-object_type          [semantic-get event-value          object_type]]]
											  [let [[event-semantic_frame-semantic_object_type [get this semantic_physical_object_type event-semantic_frame-object_type]]
												[event-value-semantic_object_type          [get this semantic_physical_object_type event-value-object_type]]]
											    [let [[relation_set [have event-semantic_frame-semantic_object_type lookup `preposition_on event-value-object_type]]
												  [relation     nil]]
											      [if [or [null relation_set] [get relation_set is_empty]]
												  [prog [= relation [new semantic_physical_object_type_relation [get [get this mind] semantic_realm] event-value-semantic_object_type]]
													[semantic-set relation phenomenal_name [get [string-concat [get event-semantic_frame-object_type as-string]
																				   '_'
																				   [get `preposition_on as-string]
																				   '_'
																				   [get event-value-object_type as-string]
																				   '_object_type_relation']
																		    as-symbol]]
													[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame relation]
													[have event-semantic_frame-semantic_object_type add `preposition_on event-value-object_type relation]]
												[prog [= relation [get relation_set an_arbitrary_element]]
												      [semantic-set relation count [+ [semantic-get relation count] 1]]]]
											      ]]]]
										       [[and [eq event-key_type `preposition] [eq event-key `in]]
											[let [[event-semantic_frame-object_type [semantic-get event-semantic_frame object_type]]
											      [event-value-object_type          [semantic-get event-value          object_type]]]
											  [let [[event-semantic_frame-semantic_object_type [get this semantic_physical_object_type event-semantic_frame-object_type]]
												[event-value-semantic_object_type          [get this semantic_physical_object_type event-value-object_type]]]
											    [let [[relation_set [have event-semantic_frame-semantic_object_type lookup `preposition_in event-value-object_type]]
												  [relation     nil]]
											      [if [or [null relation_set] [get relation_set is_empty]]
												  [prog [= relation [new semantic_physical_object_type_relation [get [get this mind] semantic_realm] event-value-semantic_object_type]]
													[semantic-set relation phenomenal_name [get [string-concat [get event-semantic_frame-object_type as-string]
																				   '_'
																				   [get `preposition_in as-string]
																				   '_'
																				   [get event-value-object_type as-string]
																				   '_object_type_relation']
																		    as-symbol]]
													[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame relation]
													[have event-semantic_frame-semantic_object_type add `preposition_in event-value-object_type relation]]
												[prog [= relation [get relation_set an_arbitrary_element]]
												      [semantic-set relation count [+ [semantic-get relation count] 1]]]]
											      ]]]]
										       ]
										 ]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `remove]]                       [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[and [eq event-key_type `preposition] [eq event-key `on]]
											[let [[event-semantic_frame-object_type [semantic-get event-semantic_frame object_type]]
											      [event-value-object_type          [semantic-get event-value          object_type]]]
											  [let [[event-semantic_frame-semantic_object_type [get this semantic_physical_object_type event-semantic_frame-object_type]]
												[event-value-semantic_object_type          [get this semantic_physical_object_type event-value-object_type]]]
											    [let [[relation_set [have event-semantic_frame-semantic_object_type lookup `preposition_on event-value-object_type]]
												  [relation     nil]]
											      [if [or [null relation_set] [get relation_set is_empty]]
												  [prog [terminal_format standard-terminal '\nwarning: got remove preposition-on relation, but no relation found.']
													]
												[prog [= relation [get relation_set an_arbitrary_element]]
												      [let [[relation-count [semantic-get relation count]]]
													[if [> relation-count 1]
													    [semantic-set relation count [- relation-count 1]]
													  [prog [have event-semantic_frame-semantic_object_type remove `preposition_on event-value-object_type relation]
														[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] remove_semantic_frame relation]
														]]]]]
											      ]]]]
										       [[and [eq event-key_type `preposition] [eq event-key `in]]
											[let [[event-semantic_frame-object_type [semantic-get event-semantic_frame object_type]]
											      [event-value-object_type          [semantic-get event-value          object_type]]]
											  [let [[event-semantic_frame-semantic_object_type [get this semantic_physical_object_type event-semantic_frame-object_type]]
												[event-value-semantic_object_type          [get this semantic_physical_object_type event-value-object_type]]]
											    [let [[relation_set [have event-semantic_frame-semantic_object_type lookup `preposition_in event-value-object_type]]
												  [relation     nil]]
											      [if [or [null relation_set] [get relation_set is_empty]]
												  [prog [terminal_format standard-terminal '\nwarning: got remove preposition-in relation, but no relation found.']
													]
												[prog [= relation [get relation_set an_arbitrary_element]]
												      [let [[relation-count [semantic-get relation count]]]
													[if [> relation-count 1]
													    [semantic-set relation count [- relation-count 1]]
													  [prog [have event-semantic_frame-semantic_object_type remove `preposition_in event-value-object_type relation]
														[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] remove_semantic_frame relation]
														]]]]]
											      ]]]]
										       ]
										 ]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_physical_changes]]      [prog [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_type_changes nil]]
										     nil]]
			  ]]]]
	[have physical_knowledge_iterator increment]]]]]



