'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[deframe blocks_world_reflective_mind [reflective_mind] []
  [new []
       [construct reflective_mind]
       
       [let [[result [shelter [type-have blocks_world_reflective_mind this create_resources]]]]
	 [if [is-type `bug result]
	     [error bug_name `blocks_world_reflective_mind-could_not_create_resources
		    subbug   result]]]
       
       [let [[result [shelter [type-have blocks_world_reflective_mind this create_builtin_actions]]]]
	 [if [is-type `bug result]
	     [error bug_name `blocks_world_reflective_mind-could_not_create_builtin_actions
		    subbug   result]]]
       
       [let [[result [shelter [type-have blocks_world_reflective_mind this create_builtin_plans]]]]
	 [if [is-type `bug result]
	     [error bug_name `blocks_world_reflective_mind-could_not_create_builtin_plans
		    subbug   result]]]
       
       [terminal_format standard-terminal '\nblocks_world_reflective_mind: created.']
       ]]

[deftypefunk blocks_world_reflective_mind execute create_resources []
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating resources.']
  
  'create blocks_world agent specific physical commands in parallel'
  [parog 'builtin resources'
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-slow_move_left_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-move_left_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-slow_move_right_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-move_right_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-grab_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-drop_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-stop_resource]]]
  
  nil]

[deftypefunk blocks_world_reflective_mind execute create_builtin_actions []
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating built-in actions.']
  
  'create blocks_world agent specific actions'
  
  [parog [have-apply this create_physical_action `[builtin_reactive physical slow_move_left]]
	 [have-apply this create_physical_action `[builtin_reactive physical move_left]]
	 [have-apply this create_physical_action `[builtin_reactive physical slow_move_right]]
	 [have-apply this create_physical_action `[builtin_reactive physical move_right]]
	 [have-apply this create_physical_action `[builtin_reactive physical grab]]
	 [have-apply this create_physical_action `[builtin_reactive physical drop]]
	 [have-apply this create_physical_action `[builtin_reactive physical stop]]]
  
  nil]

[deftypefunk blocks_world_reflective_mind execute create_builtin_plans []
  
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating built-in deliberative plans.']
  
  'create blocks_world agent specific plans'
  
  [cause-enable_reactive_critics [this-cause]]
  [cause-define cause-ignore_background_bug nil]
  
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating built-in plans.']
  
  [parog [have this imagine_deliberative_plan_expression
	       `[prog [defplan 'stack a cube on a pyramid'
			:matches ['stack a [? top_shape] on a [? bottom_shape]']
			 :frame [[top_shape    'cube']
				 [bottom_shape 'pyramid']]
			  [plan-call [plan 'pick up a [? top_shape]']]
			  [plan-call [plan 'drop the block I am holding on a [? bottom_shape]']]
			  [plan-call [plan 'assert that a [? top_shape] is on a [? bottom_shape]']]]
		      
		      [defplan 'a pyramid to be on a cube'
			:matches ['a [? top_shape] to be on a [? bottom_shape]'
				  'a [? bottom_shape] to be below a [? top_shape]']
			 :frame [[top_shape    'pyramid']
				 [bottom_shape 'cube']]
			  [relationship block property shape [? top_shape]
					preposition on
					block property shape [? bottom_shape]]]
		      
		      [defplan 'a pyramid to be on a table'
			:matches ['a [? shape] to be on a table']
			 :frame [[shape 'pyramid']]
			  [relationship block property shape [? shape]
					preposition on
					table property color white]]
		      
		      [defplan 'a cube to be to my left'
			:matches ['a [? shape] to be to my left']
			 :frame [[shape 'cube']]
			  [relationship block property shape [? shape]
					preposition left-of
					gripper property is-me t]]
		      
		      [defplan 'a cube to be to my right'
			:matches ['a [? shape] to be to my right']
			 :frame [[shape 'cube']]
			  [relationship block property shape [? shape]
					preposition right-of
					gripper property is-me t]]
		      
		      [defplan 'me to be holding a cube'
			:matches ['me to be holding a [? shape]']
			 :frame [[shape 'cube']]
			  [relationship gripper property is-me t
					preposition is-holding
					block property shape [? shape]]]
		      
		      [defplan 'I am holding a cube'
			:matches ['I am [? gerund]']
			 :frame [[gerund 'holding a cube']]
			  [exists [plan-call [plan 'me to be [? gerund]']]]]
		      
		      [defplan 'a pyramid to be below me'
			:matches ['a [? shape] to be below me']
			 :frame [[shape 'pyramid']]
			  [relationship block property shape [? shape]
					preposition below
					gripper property is-me t]]
		      
		      [defplan 'a pyramid to be immediately to my left'
			:matches ['a [? shape] to be immediately to my left']
			 :frame [[shape 'pyramid']]
			  [relationship block property shape [? shape]
					preposition below-left
					gripper property is-me t]]
		      
		      [defplan 'a pyramid to be immediately to my right'
			:matches ['a [? shape] to be immediately to my right']
			 :frame [[shape 'pyramid']]
			  [relationship block property shape [? shape]
					preposition below-right
					gripper property is-me t]]
		      
		      [defplan 'wait for a pyramid to be below me'
			:matches ['wait for [? to-be-partial_state]']
			 :frame [[to-be-partial_state 'a pyramid to be below me']]
			  [wait-for [plan-call [plan [? to-be-partial_state]]]]]
		      
		      [defplan 'a cube is to my right'
			:matches ['[? subject] is [? preposition]']
			 :frame [[subject     'a cube']
				 [preposition 'to my right']]
			  [exists [plan-call [plan '[? subject] to be [? preposition]']]]]
		      
		      [defplan 'a cube is not to my right'
			:matches ['[? subject] is not [? preposition]']
			 :frame [[subject     'a cube']
				 [preposition 'to my right']]
			  [not [plan-call [plan '[? subject] is [? preposition]']]]]
		      
		      [defplan 'assert that a pyramid is on a cube'
			:matches ['assert that [? partial_state]']
			 :frame [[partial_state 'a pyramid is on a cube']]
			  [if [not [plan-call [plan [? partial_state]]]]
			      [fail]]]
		      
		      [defplan 'move slowly left until over pyramid'
			:matches ['move slowly [? direction] until over [? shape]']
			 :frame [[direction 'left']
				 [shape     'pyramid']]
			  [if [plan-call [plan 'a [? shape] is not below me']]
			      [prog [call-below 'slow move [? direction]']
				    [plan-call [plan 'wait for a [? shape] to be below me']]
				    [call-below 'stop']]]]
		      
		      [defplan 'move left until over pyramid'
			:matches ['move [? direction] until over [? shape]']
			 :frame [[direction 'left']
				 [shape     'pyramid']]
			  [call-below 'move [? direction]']
			  [plan-call [plan 'wait for a [? shape] to be immediately to my [? direction]']]
			  [call-below 'stop']]
		      
		      [defplan 'if a cube is to my left, move left until over cube'
			:matches ['if [? condition], [? command]']
			 :frame [[condition 'a cube is to my left']
				 [command   'move left until over cube']]
			  [if [plan-call [plan [? condition]]]
			      [plan-call [plan [? command]]]]]
		      
		      [defplan 'if a cube is to my left, move left until over cube, otherwise move right until over cube'
			:matches ['if [? condition], [? true_branch], otherwise [? false_branch]']
			 :frame [[condition    'a cube is to my left']
				 [true_branch  'move left until over cube']
				 [false_brance 'move right until over cube']]
			  [if [plan-call [plan [? condition]]]
			      [plan-call [plan [? true_branch]]]
			    [plan-call [plan [? false_branch]]]]]
		      
		      [defplan 'move slowly until over cube'
			:matches ['move slowly until over [? shape]']
			 :frame [[shape 'cube']]
			  [plan-call [plan 'if a [? shape] is to my left, move slowly left until over [? shape], otherwise if a [? shape] is to my right, move slowly right until over [? shape]']]]
		      
		      [defplan 'move until over cube'
			:matches ['move until over [? shape]']
			 :frame [[shape 'cube']]
			  [plan-call [plan 'if a [? shape] is to my left, move left until over [? shape], otherwise if a [? shape] is to my right, move right until over [? shape]']]
			  [plan-call [plan 'move slowly until over [? shape]']]]
		      
		      [defplan 'attempt to grab block until gripper stops moving'
			[call-below 'grab']
			[wait-for-time 2]
			[wait-for [property gripper property is-me t
					    property movement_command
					    stop]]]
		      [defplan 'pick up a cube'
			:matches ['pick up a [? shape]']
			 :frame [[shape 'cube']]
			  [plan-call [plan 'move until over [? shape]']]
			  [plan-call [plan 'attempt to grab block until gripper stops moving']]
			  [plan-call [plan 'assert that I am holding a [? shape]']]]
		      
		      [defplan 'drop block and wait for block to fall'
			[call-below 'drop']
			[wait-for-time 20]]
		      
		      [defplan 'drop the block I am holding on a pyramid'
			:matches ['drop the block I am holding on a [? shape]']
			 :frame [[shape pyramid]]
			  [plan-call [plan 'move until over [? shape]']]
			  [plan-call [plan 'drop block and wait for block to fall']]]
		      
		      [defplan 'goal register A equals goal register B'
			[goal-register-A-equals-goal-register-B]]
		      
		      `['tests']
		      
		      [defplan 'test goal register A equals goal register B'
			[plan-call [plan 'goal register A equals goal register B']]]
		      
		      ]]
	 
	 'reflective plans'
	 
	 [have this imagine_reflective_plan_expression
	       `[prog [defplan 'a cube to be on a pyramid'
			:matches ['a [? top_shape] to be on a [? bottom_shape]']
			 :frame [[top_shape    'cube']
				 [bottom_shape 'pyramid']]
			  [relationship block property shape [? top_shape]
					preposition on
					block property shape [? bottom_shape]]]
		      
		      [defplan 'a planner to be focusing on a plan that has been imagined'
			[relationship planner property planner_type deliberative
				      relation focus_plan
				      plan property has_been_imagined t]]
		      
		      [defplan 'a planner to be focusing on a plan that has not been imagined'
			[relationship planner property planner_type deliberative
				      relation focus_plan
				      plan property has_been_imagined nil]]
		      
		      [defplan 'a planner to be focusing on a plan that has failed in execution'
			[relationship planner property planner_type deliberative
				      relation focus_plan
				      plan property executed_complete_failure t]]
		      
		      [defplan 'a planner is focusing on a plan that has been imagined'
			:matches ['[? subject] is [? preposition]']
			 :frame [[subject     'a planner']
				 [preposition 'focusing on a plan that has been imagined']]
			  [exists [plan-call [plan '[? subject] to be [? preposition]']]]]
		      
		      [defplan 'a planner is not focusing on a plan that has been imagined'
			:matches ['[? subject] is not [? relation]']
			 :frame [[subject  'a planner']
				 [relation 'focusing on a plan that has been imagined']]
			  [not [plan-call [plan '[? subject] is [? relation]']]]]
		      
		      [defplan 'a planner to be focusing on a plan that is hypothesized to cause a cube to be on a pyramid'
			:matches ['a planner to be focusing on a plan that is hypothesized to cause [? partial_state]']
			 :frame [[partial_state 'a cube to be on a pyramid']]
			  [relationship planner property planner_type deliberative
					relation focus_plan
					plan property hypothesized_to_cause_partial_state [plan-call [plan [? partial_state]]]]]
		      
		      [defplan 'if a planner is not focusing on a plan that is hypothesized to cause a cube to be on a pyramid, find a recent plan to cause a cube to be on a pyramid'
			:matches ['if [? condition], [? command]']
			 :frame [[condition 'a planner is not focusing on a plan that is hypothesized to cause a cube to be on a pyramid']
				 [command   'find a recent plan to cause a cube to be on a pyramid']]
			  [if [plan-call [plan [? condition]]]
			      [plan-call [plan [? command]]]]]
		      
		      [defplan 'find next unimagined plan'
			[call-below 'focus on next object']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find next unimagined plan']]]
		      
		      [defplan 'find previous unimagined plan'
			[call-below 'focus on previous object']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find previous unimagined plan']]]
		      
		      [defplan 'find recent unimagined plan'
			[call-below 'focus on first plan']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find next unimagined plan']]]
		      
		      [defplan 'find old unimagined plan'
			[call-below 'focus on last plan']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find previous unimagined plan']]]
		      
		      [defplan 'imagine recent unimagined plan'
			[plan-call [plan 'find recent unimagined plan']]
			[call-below 'imagine executing plan in focus']]
		      
		      [defplan 'imagine old unimagined plan'
			[plan-call [plan 'find old unimagined plan']]
			[call-below 'imagine executing plan in focus']]
		      
		      [defplan 'find a recent plan to cause a cube to be on a pyramid'
			:matches ['find a recent plan to cause [? partial_state]']
			 :frame [[partial_state 'a cube to be on a pyramid']]
			[plan-call [plan 'imagine recent unimagined plan']]
			[plan-call [plan 'if a planner is not focusing on a plan that is hypothesized to cause [? partial_state], find a recent plan to cause [? partial_state]']]]
		      
		      [defplan 'find an old plan to cause a cube to be on a pyramid'
			:matches ['find an old plan to cause [? partial_state]']
			 :frame [[partial_state 'a cube to be on a pyramid']]
			[plan-call [plan 'imagine old unimagined plan']]
			[plan-call [plan 'if a planner is not focusing on a plan that is hypothesized to cause [? partial_state], find an old plan to cause [? partial_state]']]]
		      
		      `['goals']
		      
		      [defplan 'me to want a cube to be on a pyramid'
			:matches ['me to want [? partial_state]']
			 :frame [[partial_state 'a cube to be on a pyramid']]
			  [relationship planner property planner_type deliberative
					relation positive_goal
					goal property partial_state_phenomenal_name [plan-call [plan [? partial_state]]]]]
		      
		      [defplan 'I want a cube to be on a pyramid'
			:matches ['I want [? partial_state]']
			 :frame [[partial_state 'a cube to be on a pyramid']]
			  [exists [plan-call [plan 'me to want [? partial_state]']]]]
		      
		      [defplan 'me to avoid a cube being on a pyramid'
			:matches ['me to avoid [? subject] being on [? preposition]']
			 :frame [[subject     'a cube']
				 [preposition 'on a pyramid']]
			  [relationship planner property planner_type deliberative
					relation positive_goal
					goal property partial_state_phenomenal_name [plan-call [plan '[? subject] to be [? preposition]']]]]
		      
		      [defplan 'I am avoiding a cube being on a pyramid'
			:matches ['I am avoiding [? subject] being [? preposition]']
			 :frame [[subject     'a cube']
				 [preposition 'on a pyramid']]
			  [exists [plan-call [plan 'me to avoid [? subject] being [? preposition]']]]]
		      
		      [defplan 'want a cube to be on a pyramid'
			:matches ['want [? partial_state]']
			 :frame [[partial_state 'a cube to be on a pyramid']]
			  [add-positive-goal [plan-call [plan [? partial_state]]]]]
		      
		      [defplan 'avoid a cube being on a pyramid'
			:matches ['avoid [? subject] being [? preposition]']
			 :frame [[subject     'a cube']
				 [preposition 'on a pyramid']]
			  [add-negative-goal [plan-call [plan '[? subject] to be [? preposition]']]]]
		      
		      [defplan 'stop wanting a cube to be on a pyramid'
			:matches ['stop wanting [? partial_state]']
			 :frame [[partial_state 'a cube to be on a pyramid']]
			  [remove-positive-goal [plan-call [plan [? partial_state]]]]]
		      
		      [defplan 'stop avoiding a cube being on a pyramid'
			:matches ['stop avoiding [? subject] being [? preposition]']
			 :frame [[subject     'a cube']
				 [preposition 'on a pyramid']]
			  [remove-negative-goal [plan-call [plan '[? subject] to be [? preposition]']]]]
		      
		      [defplan 'want a block to be on a block'
			[plan-call [plan 'want a cube to be on a pyramid']]
			[plan-call [plan 'want a pyramid to be on a cube']]]
		      
		      [defplan 'avoid a block being on a block'
			[plan-call [plan 'avoid a cube being on a pyramid']]
			[plan-call [plan 'avoid a pyramid being on a cube']]]
		      
		      [defplan 'stop wanting a block to be on a block'
			[plan-call [plan 'stop wanting a cube to be on a pyramid']]
			[plan-call [plan 'stop wanting a pyramid to be on a cube']]]
		      
		      [defplan 'stop avoiding a block being on a block'
			[plan-call [plan 'stop avoiding a cube being on a pyramid']]
			[plan-call [plan 'stop avoiding a pyramid being on a cube']]]
		      
		      `['planner']
		      
		      `[defplan 'find a recent plan to acheive one of my goals'
			[if [plan-call [plan 'I want a cube to be on a pyramid']]
			    [plan-call [plan 'find a recent plan to cause a cube to be on a pyramid']]
			  [if [plan-call [plan 'I want a pyramid to be on a cube']]
			      [plan-call [plan 'find a recent plan to cause a pyramid to be on a cube']]
			    [fail]]]]
		      
		      [defplan 'find next most recent plan to achieve one of my goals'
			[call-below 'focus on reverse_car object']
			]
		      
		      [defplan 'this goal is a positive goal'
			[boolean [lookup-slot-value property positive]]]
		      
		      `[[focus-register [input this-goal]]
			[register-A     this-goal]
			[register-B     positive-goal]]
		      
		      [defplan 'register A goal is one of the rest of my positive goals'
			[call-below 'focus on cdr object']
			[if [boolean [focus-register]]
			    [prog [call-below 'focus on car object']
				  [call-below 'copy focus register to register B']
				  [call-below 'focus on reverse_car object']
				  [if [register-A-equals-register-B]
				      [boolean t]
				    [plan-call [plan 'register A goal is one of the rest of my positive goals']]]]
			  [boolean nil]]]
		      
		      [defplan 'this goal is one of my positive goals'
			[call-below 'copy focus register to register A']
			[call-below 'focus on first positive goal']
			[call-below 'focus on car object']
			[call-below 'copy focus register to register B']
			[call-below 'focus on reverse_car object']
			[if [register-A-equals-register-B]
			    [boolean t]
			  [boolean [plan-call [plan 'register A goal is one of the rest of my positive goals']]]]]
		      
		      [defplan 'find a recent plan to acheive one of my positive goals'
			[call-below 'focus on first plan']
			[call-below 'focus on car object']
			[call-below 'imagine executing plan in focus']
			[call-below 'focus on first_hypothesized_to_cause_goal object']
			[if [not [plan-call [plan 'this goal is one of my positive goals']]]
			    [plan-call [plan 'find next most recent plan to achieve one of my goals']]]]
		      
		      [defplan 'find an old plan to acheive one of my goals'
			[if [plan-call [plan 'I want a cube to be on a pyramid']]
			    [plan-call [plan 'find an old plan to cause a cube to be on a pyramid']]
			  [if [plan-call [plan 'I want a pyramid to be on a cube']]
			      [plan-call [plan 'find an old plan to cause a pyramid to be on a cube']]
			    [fail]]]]
		      
		      `['tests']
		      
		      [defplan 'test this goal is a positive goal'
			[plan-call [plan 'this goal is a positive goal']]]
		      
		      [defplan 'test this goal is one of my positive goals'
			[plan-call [plan 'this goal is one of my positive goals']]]
		      
		      [defplan 'test find a recent plan to acheive one of my positive goals'
			[plan-call [plan 'find a recent plan to acheive one of my positive goals']]]
		      
		      [defplan 'test I want a cube to be on a pyramid'
			[plan-call [plan 'I want a cube to be on a pyramid']]]
		      
		      [defplan 'test I want a pyramid to be on a cube'
			[plan-call [plan 'I want a pyramid to be on a cube']]]
		      
		      [defplan 'test want a pyramid to be on a cube'
			[plan-call [plan 'want a pyramid to be on a cube']]]
		      
		      [defplan 'test want a cube to be on a pyramid'
			[plan-call [plan 'want a cube to be on a pyramid']]]
		      
		      [defplan 'test initialize goals'
			[plan-call [plan 'want a block to be on a block']]]
		      
		      [defplan 'test find a recent plan to acheive one of my goals'
			[plan-call [plan 'find a recent plan to acheive one of my goals']]]
		      
		      [defplan 'test find an old plan to acheive one of my goals'
			[plan-call [plan 'find an old plan to acheive one of my goals']]]
		      
		      [defplan 'test go after a stack of a pyramid on a cube on a cube'
			[plan-call [plan 'want a pyramid to be on a cube']]
			[plan-call [plan 'want a cube to be on a cube']]
			[plan-call [plan 'find a recent plan to acheive one of my goals']]
			[call-below 'register plan currently in focus']
			[plan-call [plan 'find a recent plan to acheive one of my goals']]
			[call-below 'add a plan before the beginning of plan currently in focus']
			[call-below 'execute plan in focus']]
		      
		      [defplan 'test go after a cube to be on a pyramid'
			[plan-call [plan 'want a cube to be on a pyramid']]
			[plan-call [plan 'find a recent plan to acheive one of my goals']]
			[call-below 'execute plan in focus']]
		      
		      ]]
	 
	 'super reflective plans'
	 
	 [have this imagine_super_reflective_plan_expression
	       `[prog [defplan 'a planner to be focusing on a plan that has been imagined'
			[relationship planner property planner_type reflective
				      relation focus_plan
				      plan property has_been_imagined t]]
		      
		      [defplan 'a planner to be focusing on a plan that has not been imagined'
			[relationship planner property planner_type reflective
				      relation focus_plan
				      plan property has_been_imagined nil]]
		      
		      [defplan 'a planner to be focusing on a plan that has failed'
			[relationship planner property planner_type reflective
				      relation focus_plan
				      plan property imagined_complete_failure t]]
		      
		      [defplan 'a cube to be on a pyramid'
			:matches ['a [? top_shape] to be on a [? bottom_shape]']
			 :frame [[top_shape    'cube']
				 [bottom_shape 'pyramid']]
			  [relationship block property shape [? top_shape]
					preposition on
					block property shape [? bottom_shape]]]
		      
		      [defplan 'a planner is focusing on a plan that has been imagined'
			:matches ['[? subject] is [? preposition]']
			 :frame [[subject     'a planner']
				 [preposition 'focusing on a plan that has been imagined']]
			  [exists [plan-call [plan '[? subject] to be [? preposition]']]]]
		      
		      [defplan 'a planner is not focusing on a plan that has been imagined'
			:matches ['[? subject] is not [? preposition]']
			 :frame [[subject     'a planner']
				 [preposition 'focusing on a plan that has been imagined']]
			  [not [plan-call [plan '[? subject] is [? preposition]']]]]
		      
		      [defplan 'a planner to be focusing on a plan that is hypothesized to cause a planner to be focusing on a plan that has failed'
			:matches ['a planner to be focusing on a plan that is hypothesized to cause [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [relationship planner property planner_type reflective
					relation focus_plan
					plan property hypothesized_to_cause_partial_state [plan-call [plan [? partial_state]]]]]
		      
		      `['goals']
		      
		      [defplan 'me to want a planner to be focusing on a plan that has failed'
			:matches ['me to want [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [relationship planner property planner_type reflective
					relation positive_goal
					goal property partial_state_phenomenal_name [plan-call [plan [? partial_state]]]]]
		      
		      [defplan 'I want a planner to be focusing on a plan that has failed'
			:matches ['I want [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [exists [plan-call [plan 'me to want [? partial_state]']]]]
		      
		      [defplan 'me to avoid a planner being focused on a plan that has failed'
			:matches ['me to avoid [? subject] being focused [? preposition]']
			 :frame [[subject     'a planner']
				 [preposition 'on a plan that has failed']]
			  [relationship planner property planner_type reflective
					relation negative_goal
					goal property partial_state_phenomenal_name [plan-call [plan '[? subject] to be focusing [? preposition]']]]]
		      
		      [defplan 'I am avoiding a planner being focused on a plan that has failed'
			:matches['I am avoiding [? subject] being [? preposition]']
			 :frame [[subject     'a planner']
				 [preposition 'focused on a plan that has failed']]
			  [exists [plan-call [plan 'me to avoid [? subject] being [? preposition]']]]]
		      
		      [defplan 'want a planner to be focusing on a plan that has failed'
			:matches ['want [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [add-positive-goal [plan-call [plan [? partial_state]]]]]
		      
		      [defplan 'avoid a planner being focused on a plan that has failed'
			:matches ['avoid [? subject] being focused [? preposition]']
			 :frame [[subject     'a planner']
				 [preposition 'on a plan that has failed']]
			  [add-negative-goal [plan-call [plan '[? subject] to be focusing [? preposition]']]]]
		      
		      [defplan 'test avoid a planner being focused on a plan that has failed'
			[plan-call [plan 'avoid a planner being focused on a plan that has failed']]]
		      
		      [defplan 'if a planner is not focusing on a plan that is hypothesized to cause a planner to be focusing on a plan that has failed, find a recent plan to cause a planner to be focusing on a plan that has failed'
			:matches ['if [? condition], [? command]']
			 :frame [[condition 'a planner is not focusing on a plan that is hypothesized to cause a planner to be focusing on a plan that has failed']
				 [command   'find a recent plan to cause a planner to be focusing on a plan that has failed']]
			  [if [plan-call [plan [? condition]]]
			      [plan-call [plan [? command]]]]]
		      
		      [defplan 'if a planner is not focusing on a plan that is hypothesized to cause a planner to be focusing on a plan that has failed, find an old plan to cause a planner to be focusing on a plan that has failed'
			:matches ['if [? condition], [? command]']
			 :frame [[condition 'a planner is not focusing on a plan that is hypothesized to cause a planner to be focusing on a plan that has failed']
				 [command   'find an old plan to cause a planner to be focusing on a plan that has failed']]
			  [if [plan-call [plan [? condition]]]
			      [plan-call [plan [? command]]]]]
		      
		      [defplan 'find next unimagined plan'
			[call-below 'focus on next object']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find next unimagined plan']]]
		      
		      [defplan 'find previous unimagined plan'
			[call-below 'focus on previous object']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find previous unimagined plan']]]
		      
		      [defplan 'find recent unimagined plan'
			[call-below 'focus on first plan']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find next unimagined plan']]]
		      
		      [defplan 'find old unimagined plan'
			[call-below 'focus on last plan']
			[plan-call [plan 'if a planner is focusing on a plan that has been imagined, find previous unimagined plan']]]
		      
		      [defplan 'imagine recent unimagined plan'
			[plan-call [plan 'find recent unimagined plan']]
			[call-below 'imagine executing plan in focus']]
		      
		      [defplan 'imagine old unimagined plan'
			[plan-call [plan 'find old unimagined plan']]
			[call-below 'imagine executing plan in focus']]
		      
		      [defplan 'find a recent plan to cause a planner to be focusing on a plan that has failed'
			:matches ['find a recent plan to cause [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [plan-call [plan 'imagine recent unimagined plan']]
			  [plan-call [plan 'if a planner is not focusing on a plan that is hypothesized to cause [? partial_state], find a recent plan to cause [? partial_state]']]]
		      
		      [defplan 'find a recent plan to not cause a planner to be focusing on a plan that has failed'
			:matches ['find a recent plan to not cause [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [plan-call [plan 'imagine recent unimagined plan']]
			  [plan-call [plan 'if a planner is focusing on a plan that is hypothesized to cause [? partial_state], find a recent plan to not cause [? partial_state]']]]
		      
		      [defplan 'find an old plan to cause a planner to be focusing on a plan that has failed'
			:matches ['find an old plan to cause [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [plan-call [plan 'imagine old unimagined plan']]
			  [plan-call [plan 'if a planner is not focusing on a plan that is hypothesized to cause [? partial_state], find an old plan to cause [? partial_state]']]]
		      
		      [defplan 'find an old plan to not cause a planner to be focusing on a plan that has failed'
			:matches ['find an old plan to not cause [? partial_state]']
			 :frame [[partial_state 'a planner to be focusing on a plan that has failed']]
			  [plan-call [plan 'imagine old unimagined plan']]
			  [plan-call [plan 'if a planner is focusing on a plan that is hypothesized to cause [? partial_state], find an old plan to not cause [? partial_state]']]]
		      
		      `['planner']
		      
		      [defplan 'find a recent plan to avoid my negative goals'
			[if [plan-call [plan 'I am avoiding a planner being focused on a plan that has failed']]
			    [plan-call [plan 'find a recent plan to not cause a planner to be focusing on a plan that has failed']]
			  [fail]]]
		      
		      [defplan 'find an old plan to avoid my negative goals'
			[if [plan-call [plan 'I am avoiding a planner being focused on a plan that has failed']]
			    [plan-call [plan 'find an old plan to cause a planner to be focusing on a plan that has failed']]
			  [fail]]]
		      
		      `['tests']
		      
		      [defplan 'test I am avoiding a planner being focused on a plan that has failed'
			[plan-call [plan 'I am avoiding a planner being focused on a plan that has failed']]]
		      
		      [defplan 'test find a recent plan to avoid my negative goals'
			[plan-call [plan 'find a recent plan to avoid my negative goals']]]
		      
		      [defplan 'test find an old plan to to avoid my negative goals'
			[plan-call [plan 'find an old plan to avoid my negative goals']]]
		      
		      [defplan 'test avoid a planner being focused on a plan that has failed'
			[plan-call [plan 'avoid a planner being focused on a plan that has failed']]]
		      
		      [defplan 'test go with recent plan away from a planner being focused on a plan that has failed'
			[plan-call [plan 'avoid a planner being focused on a plan that has failed']]
			[plan-call [plan 'find a recent plan to avoid my negative goals']]
			[call-below 'execute plan in focus']]
		      
		      [defplan 'test go with old plan away from a planner being focused on a plan that has failed'
			[plan-call [plan 'avoid a planner being focused on a plan that has failed']]
			[plan-call [plan 'find an old plan to avoid my negative goals']]
			[call-below 'execute plan in focus']]
		      
		      ]]]
  
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: done creating built-in plans.']
  
  nil]

