'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[deframe blocks_world_reflective_mind [reflective_mind] []
  [new []
       [construct reflective_mind]
       
       [let [[result [shelter [type-have blocks_world_reflective_mind this create_resources]]]]
	 [if [is-type `bug result]
	     [error bug_name `blocks_world_reflective_mind-could_not_create_resources
		    subbug   result]]]
       
       [let [[result [shelter [type-have blocks_world_reflective_mind this create_builtin_actions]]]]
	 [if [is-type `bug result]
	     [error bug_name `blocks_world_reflective_mind-could_not_create_builtin_actions
		    subbug   result]]]
       
       [let [[result [shelter [type-have blocks_world_reflective_mind this create_builtin_plans]]]]
	 [if [is-type `bug result]
	     [error bug_name `blocks_world_reflective_mind-could_not_create_builtin_plans
		    subbug   result]]]
       
       [terminal_format standard-terminal '\nblocks_world_reflective_mind: created.']
       ]]

[deftypefunk blocks_world_reflective_mind execute create_resources []
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating resources.']
  
  'create blocks_world agent specific physical commands in parallel'
  [parog 'builtin resources'
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-slow_move_left_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-move_left_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-slow_move_right_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-move_right_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-grab_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-drop_resource]]
	 [have this add_resource `builtin_reactive `physical [new reflective_mind-blocks_world-stop_resource]]]
  
  nil]

[deftypefunk blocks_world_reflective_mind execute create_builtin_actions []
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating built-in actions.']
  
  'create blocks_world agent specific actions'
  
  [parog [have-apply this create_physical_action `[builtin_reactive physical slow_move_left]]
	 [have-apply this create_physical_action `[builtin_reactive physical move_left]]
	 [have-apply this create_physical_action `[builtin_reactive physical slow_move_right]]
	 [have-apply this create_physical_action `[builtin_reactive physical move_right]]
	 [have-apply this create_physical_action `[builtin_reactive physical grab]]
	 [have-apply this create_physical_action `[builtin_reactive physical drop]]
	 [have-apply this create_physical_action `[builtin_reactive physical stop]]]
  
  nil]

[deftypefunk blocks_world_reflective_mind execute create_builtin_plans []
  
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating built-in deliberative plans.']
  
  'create blocks_world agent specific plans'
  
  [cause-enable_reactive_critics [this-cause]]
  [cause-define cause-ignore_background_bug nil]
  
  [have this imagine_deliberative_plan_expression
	`[parog [defplan 'a pyramid to be on a cube'
		  :matches ['a [? top_shape] to be on a [? bottom_shape]'
			    'a [? bottom_shape] to be below a [? top_shape]']
		   :frame [[top_shape    pyramid]
			   [bottom_shape cube]]
		    [relationship block property shape [? top_shape]
				  preposition on
				  block property shape [? bottom_shape]]]
		
		[defplan 'a pyramid to be on a table'
		  :matches ['a [? shape] is on a table']
		   :frame [[shape pyramid]]
		    [relationship block property shape [? shape]
				  preposition on
				  table property color white]]
		
		[defplan 'a cube to be to my left'
		  :matches ['a [? shape] is to my left']
		   :frame [[shape cube]]
		    [relationship block property shape [? shape]
				  preposition left-of
				  gripper property is-me t]]
		
		[defplan 'a cube to be to my right'
		  :matches ['a [? shape] to be to my right']
		   :frame [[shape cube]]
		    [relationship block property shape [? shape]
				  preposition right-of
				  gripper property is-me t]]
		
		[defplan 'me to be holding a cube'
		  :matches ['me to be holding a [? shape]'
			    'I to be holding a [? shape]']
		   :frame [[shape cube]]
		    [relationship gripper property is-me t
				  preposition is-holding
				  block property shape [? shape]]]
		
		[defplan 'a pyramid to be below me'
		  :matches ['a [? shape] to be below me']
		   :frame [[shape pyramid]]
		    [relationship block property shape [? shape]
				  preposition below
				  gripper property is-me t]]
		
		[defplan 'a pyramid to be immediately to my left'
		  :matches ['a [? shape] to be immediately to my left']
		   :frame [[shape pyramid]]
		    [relationship block property shape [? shape]
				  preposition below-left
				  gripper property is-me t]]
		
		[defplan 'a pyramid to be immediately to my right'
		  :matches ['a [? shape] to be immediately to my right']
		   :frame [[shape pyramid]]
		    [relationship block property shape [? shape]
				  preposition below-right
				  gripper property is-me t]]
		
		[defplan 'wait for a pyramid to be below me'
		  :matches ['wait for [? to-be-partial_state]']
		   :frame [[to-be-partial_state 'a pyramid to be below me']]
		    [wait-for [plan-call [plan [? to-be-partial_state]]]]]
		
		[defplan 'a cube is to my right'
		  :matches ['[? subject] is [? preposition]']
		   :frame [[shape cube]]
		    [exists [plan-call [plan '[? subject] to be [? preposition]']]]]
		
		[defplan 'assert that a pyramid is on a cube'
		  :matches ['assert that [? partial_state]']
		   :frame [[partial_state 'a pyramid is on a cube']]
		    [if [not [plan-call [plan [? partial_state]]]]
			[fail]]]
		
		[defplan 'move slowly left until over pyramid'
		  :matches ['move slowly [? direction] until over [? shape]']
		   :frame [[direction left]
			   [shape     pyramid]]
		    [if [not [exists [plan-call [plan 'a [? shape] to be below me']]]]
			[prog [call-below 'slow move [? direction]']
			      [plan-call [plan 'wait for a [? shape] to be below me']]
			      [call-below 'stop']]]]
		
		[defplan 'move left until over pyramid'
		  :matches ['move [? direction] until over [? shape]']
		   :frame [[direction left]
			   [shape     pyramid]]
		    [call-below 'move [? direction]']
		    [plan-call [plan 'wait for a [? shape] to be immediately to my [? direction]']]
		    [call-below 'stop']]
		
		`[compile [plan 'move left until over pyramid']]
		`[compile [plan 'move left until over cube']]
		`[compile [plan 'move right until over pyramid']]
		`[compile [plan 'move right until over cube']]
		
		[defplan 'if a cube is to my left, move left until over cube'
		  :matches ['if [? condition], [? command]']
		   :frame [[condition 'a cube is to my left']
			   [command   'move left until over cube']]
		    [if [plan-call [plan [? condition]]]
			[plan-call [plan [? command]]]]]
		
		[defplan 'if a cube is to my left, move left until over cube, otherwise move right until over cube'
		  :matches ['if [? condition], [? true_branch], otherwise [? false_branch]']
		   :frame [[condition    'a cube is to my left']
			   [true_branch  'move left until over cube']
			   [false_brance 'move right until over cube']]
		    [if [plan-call [plan [? condition]]]
			[plan-call [plan [? true_branch]]]
		      [plan-call [plan [? false_branch]]]]]
		
		[defplan 'move slowly until over cube'
		  :matches ['move slowly until over [? shape]']
		   :frame [[shape cube]]
		    [plan-call [plan 'if a [? shape] is to my left, move slowly left until over [? shape], otherwise if a [? shape] is to my right, move slowly right until over [? shape]']]]
		
		[defplan 'move until over cube'
		  :matches ['move until over [? shape]']
		   :frame [[shape cube]]
		    [plan-call [plan 'if a [? shape] is to my left, move left until over [? shape], otherwise if a [? shape] is to my right, move right until over [? shape]']]
		    [plan-call [plan 'move slowly until over [? shape]']]]
		
		[defplan 'attempt to grab block until gripper stops moving'
		  [call-below 'grab']
		  [wait-for-time 2]
		  [wait-for [property gripper property is-me t
				      property movement_command
				      stop]]]
		`[compile [plan 'attempt to grab block until gripper stops moving']]
		
		[defplan 'pick up a cube'
		  :matches ['pick up a [? shape]']
		   :frame [[shape cube]]
		    [plan-call [plan 'move until over [? shape]']]
		    [plan-call [plan 'attempt to grab block until gripper stops moving']]
		    [plan-call [plan 'assert that I am holding a [? shape]']]]
		
		[defplan 'test reaching and grabbing'
		  [plan-call [plan 'attempt to grab block until gripper stops moving']]]
		
		[defplan 'drop block and wait for block to fall'
		  [call-below 'drop']
		  [wait-for-time 20]]
		`[compile 'drop block and wait for block to fall']
		
		[defplan 'drop the block I am holding on a pyramid'
		  :matches ['drop the block I am holding on a [? shape]']
		   :frame [[shape pyramid]]
		    [plan-call [plan 'move until over [? shape]']]
		    [plan-call [plan 'drop block and wait for block to fall']]]
		
		[defplan 'stack a cube on a pyramid'
		  :matches ['stack a [? top_shape] on a [? bottom_shape]']
		   :frame [[top_shape    cube]
			   [bottom_shape pyramid]]
		    [plan-call [plan 'pick up a [? top_shape]']]
		    [plan-call [plan 'drop the block I am holding on a [? bottom_shape]']]
		    [plan-call [plan 'assert that a [? top_shape] is on a [? bottom_shape]']]]
		
		[defplan 'stack a cube on a pyramid'
		  [plan-call [plan 'pick up a cube']]
		  [plan-call [plan 'drop the block I am holding on a pyramid']]
		  [plan-call [plan 'assert that a cube is on a pyramid']]]
		
		[defplan 'test stack a pyramid on a cube'
		  [plan-call [plan 'stack a pyramid on a cube']]]
		
		]]
  
  [terminal_format standard-terminal '\nblocks_world_reflective_mind: creating built-in reflective plans.']
  
  'reflective plans'
  
  [have this imagine_reflective_plan_expression
	`[parog [defplan 'a plan to stack a pyramid on a cube'
		  :matches ['a plan to [? plan]']
		   :frame [[plan 'stack a pyramid on a cube']]
		    [plan-below [? plan]]]
		
		[defplan 'print a plan to stack a pyramid on a cube'
		  :matches ['print [? object]']
		   :frame [[object 'a plan to stack a pyramid on a cube']]
		    [print [plan-call [plan [? object]]]]]
		
		[defplan 'focus on a plan to stack a pyramid on a cube'
		  :matches ['focus on [? object]']
		   :frame [[object 'a plan to stack a pyramid on a cube']]
		    [call-below 'focus on object' [plan-call [? object]]]]
		
		[defplan 'execute the plan in focus'
		  [call-below 'execute plan in focus']]
		
		[defplan 'remember a plan for a current goal and execute it'
		  [call-below 'remember plan for goal']
		  [call-below 'execute plan in focus']]
		
		[defplan 'remember a plan for a current goal and execute it'
		  [call 'remember a plan for a current goal and execute it']]
		
		[defplan 'plan to remember a plan for a current goal and execute it'
		  :matches ['plan to [? plan]']
		   :frame [[plan 'remember a plan for a current goal and execute it']]
		    [plan [? plan]]]
		
		[defplan 'focus on plan to remember a plan for a current goal and execute it'
		  :matches ['focus on [? object]']
		   :frame [[object 'plan to remember a plan for a current goal and execute it']]
		    [call 'focus on object' [plan-call [? object]]]]
		
		[defplan 'choose a plan'
		  [call-below 'focus on the plan to stack a cube on a pyramid']]
		
		[defplan 'imagine executing the plan in focus'
		  [call-below 'forget all imagined events']
		  [call-below 'set imagine time to be now']
		  [call-below 'imagine current situation']
		  [call-below 'imagine executing plan in focus']]
		
		[defplan 'execute the plan in focus'
		  [call-below 'focus on the plan to stack a cube on a pyramid']
		  [call-below 'forget all imagined events']
		  [call-below 'set imagine time to be now']
		  [call-below 'imagine current situation']
		  [call-below 'imagine executing plan in focus']
		  'check if and how goal is accomplished in imagination.'
		  
		  [call-below 'forget all imagined events']
		  [call-below 'execute plan in focus']]

		[defplan 'choose a plan, imagine executing the plan, and then execute the plan'
		  :matches ['choose a plan, imagine executing the plan, and then execute the plan']
		   :frame [[first_step  'choose a plan']
			   [second_step 'imagine executing the plan']
			   [third_step  'execute the plan']]
		    [call 'focus on object' [plan-call [? object]]]]
		
		[defplan 'choose a plan, imagine executing it, and then execute it'
		  [call-below 'focus on the plan to stack a cube on a pyramid']
		  [call-below 'forget all imagined events']
		  [call-below 'set imagine time to be now']
		  [call-below 'imagine current situation']
		  [call-below 'imagine executing plan in focus']
		  'check if and how goal is accomplished in imagination.'
		  
		  [call-below 'forget all imagined events']
		  [call-below 'execute plan in focus']]
		
		]]
  
  nil]

