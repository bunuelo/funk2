'Copyright (c) 2007-2011 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'



'deliberative_physical_object_type_goal_agency'

[deframe deliberative_physical_object_type_goal_agency [agency] []
  [new []
       [construct agency `physical_object_type_goal]
       [have this add_resource [new translate_physical_knowledge_to_physical_type_knowledge_resource]]
       ]]

[deftypefunk deliberative_physical_object_type_goal_agency execute create_knowledge []
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `type_copy_of_physical_knowledge  [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `physical_type_knowledge          [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `physical_goal_knowledge          [get [get this mind] semantic_realm]]]
  ]

[deftypefunk deliberative_physical_object_type_goal_agency execute connect_knowledge_reflection []
  [have [get this mind] create_knowledge_event_stream_iterator `physical_knowledge `physical_knowledge->physical_type_knowledge]
  ]

[deftypefunk deliberative_physical_object_type_goal_agency execute create_physical_type_relationship_goal [source_physical_object_type key_type key target_physical_object_type]
  ]

[deftypefunk deliberative_physical_object_type_goal_agency execute create_physical_type_property_relationship_goal [source_type
														    source_type_property
														    source_type_property_value
														    key_type
														    key
														    target_type
														    target_type_property
														    target_type_property_value]
  [let [[resource [get this resource `translate_physical_knowledge_to_physical_type_knowledge]]]
    [let [[goal [new physical_type_property_relation_goal
		     [get this mind]
		     source_type
		     source_type_property
		     source_type_property_value
		     key_type
		     key
		     target_type
		     target_type_property
		     target_type_property_value]]]
      [have resource add_goal goal]]]]



'translate_physical_knowledge_to_physical_type_knowledge_resource'

[deframe translate_physical_knowledge_to_physical_type_knowledge_resource [traced_resource] [[semantic_physical_object_type_event_mutex [new mutex]]
											     [semantic_physical_object_copy_mutex       [new mutex]]
											     [goals                                     nil]
											     [end_of_physical_type_changes_trigger      [new fiber_trigger]]]
  [new []
       [construct traced_resource `translate_physical_knowledge_to_physical_type_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute add_goal [goal]
  `[terminal_format standard-terminal '\ndeliberative_layer: adding physical goal, "' [get goal as-string] '."']
  [= goals [cons goal goals]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute add_type_to_goal_states [event_time
													       semantic_physical_object_type_event_source
													       key_type
													       key
													       semantic_physical_object_type_event_target]
  [mapc [funk [goal]
	      [have goal add_type_event
		    event_time
		    semantic_physical_object_type_event_source
		    key_type
		    key
		    semantic_physical_object_type_event_target]]
	goals]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute remove_type_from_goal_states [event_time
														    semantic_physical_object_type_event_source
														    key_type
														    key
														    semantic_physical_object_type_event_target]
  [mapc [funk [goal]
	      [have goal remove_type_event
		    event_time
		    semantic_physical_object_type_event_source
		    key_type
		    key
		    semantic_physical_object_type_event_target]]
	goals]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_copy [phenomenal_name physical_object_type]
  [let [[semantic_physical_object nil]]
    [have semantic_physical_object_type_event_mutex lock]
    [let [[copy_phenomenal_name [get [format nil 'physical_type_copy_of_' phenomenal_name] as-symbol]]]
      [= semantic_physical_object [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame copy_phenomenal_name]]
      [if [null semantic_physical_object]
	  [prog [= semantic_physical_object [new semantic_physical_object [get [get this mind] semantic_realm]]]
		[set semantic_physical_object phenomenal_name      phenomenal_name]
		[set semantic_physical_object physical_object_type physical_object_type]
		[have [get [get this mind] semantic_knowledge_base `type_copy_of_physical_knowledge] add_semantic_frame semantic_physical_object]
		[have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame copy_phenomenal_name semantic_physical_object]
		]]
      [have semantic_physical_object_type_event_mutex unlock]
      semantic_physical_object]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_type_event [phenomenal_name]
  [let [[semantic_physical_object_type_event nil]]
    [have semantic_physical_object_copy_mutex lock]
    [= semantic_physical_object_type_event [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]
    [if [null semantic_physical_object_type_event]
	[prog [= semantic_physical_object_type_event [new semantic_physical_object_type_event [get [get this mind] semantic_realm]
							  [object_type_event-phenomenal_name phenomenal_name]
							  phenomenal_name]]
	      [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame semantic_physical_object_type_event]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_physical_object_type_event]
	      ]]
    [have semantic_physical_object_copy_mutex unlock]
    semantic_physical_object_type_event]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_type_event_with_property_type [phenomenal_name property_key property property_value]
  [let [[object_type_with_propety_phenomenal_name [semantic_object_property_type_event-phenomenal_name phenomenal_name property_key property property_value]]]
    [get this semantic_physical_object_type_event object_type_with_propety_phenomenal_name]]]

[defunk translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property [source key_type key target]
  [and [is-type `semantic_physical_object source]
       [not [and [eq `property key_type] [eq `physical_object_type key]]]
       [or [null target] [is-type `symbol target]]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get all_semantic_physical_object_type_events [semantic_physical_object]
  [let [[semantic_physical_object_type_events nil]]
    [= semantic_physical_object_type_events [cons [get this semantic_physical_object_type_event [get semantic_physical_object physical_object_type]]
					    semantic_physical_object_type_events]]
    [have semantic_physical_object map_type_key_values
	  [funk [slot_type slot_key slot_value]
		[if [translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property semantic_physical_object slot_type slot_key slot_value]
		    [= semantic_physical_object_type_events [cons [get this semantic_physical_object_type_event_with_property_type
								       [get semantic_physical_object physical_object_type]
								       slot_type
								       slot_key
								       slot_value]
								  semantic_physical_object_type_events]]]]]
    semantic_physical_object_type_events]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute add_type_relation [event_time semantic_physical_object_type_event_source key_type key semantic_physical_object_type_event_target]
  [if debug [terminal_format standard-terminal '\nadd_type_relation ' [get semantic_physical_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' [get semantic_physical_object_type_event_target phenomenal_name]]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[relation_set [have semantic_physical_object_type_event_source lookup_set compound_key [get semantic_physical_object_type_event_target phenomenal_name]]]
	  [relation     nil]]
      [if [or [null relation_set] [get relation_set is_empty]]
	  [let [[relation-phenomenal_name   [semantic_object_relation_type_event-phenomenal_name [get semantic_physical_object_type_event_source phenomenal_name]
												 key_type
												 key
												 [get semantic_physical_object_type_event_target phenomenal_name]]]
		[relation-meta_relationship [have [get [get this mind] semantic_realm] lookup_or_create_meta_relationship
						  semantic_physical_object_type_event_source
						  key_type
						  key
						  semantic_physical_object_type_event_target]]]
	    [= relation [new semantic_physical_object_type_relation_event [get [get this mind] semantic_realm]
			     relation-phenomenal_name
			     relation-meta_relationship
			     semantic_physical_object_type_event_target]]
	    [set relation absolute_start_time [new semantic_time event_time]]
	    [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame relation]
	    [have semantic_physical_object_type_event_source add compound_key [get semantic_physical_object_type_event_target phenomenal_name] relation]
	    [have this add_type_to_goal_states event_time semantic_physical_object_type_event_source key_type key semantic_physical_object_type_event_target]]
	[prog [= relation [get relation_set an_arbitrary_element]]
	      [set relation count [+ [get relation count] 1]]]]]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute remove_type_relation [event_time semantic_physical_object_type_event_source key_type key semantic_physical_object_type_event_target]
  [if debug [terminal_format standard-terminal '\nremove_type_relation ' [get semantic_physical_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' [get semantic_physical_object_type_event_target phenomenal_name]]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[relation_set [have semantic_physical_object_type_event_source lookup_set compound_key [get semantic_physical_object_type_event_target phenomenal_name]]]
	  [relation     nil]]
      [if [or [null relation_set] [get relation_set is_empty]]
	  [prog [terminal_format standard-terminal
				 '\nwarning: got remove ' [get semantic_physical_object_type_event_source phenomenal_name] ' ' compound_key ' ' [get semantic_physical_object_type_event_target phenomenal_name] ' relation, but no relation found.']
		]
	[prog [= relation [get relation_set an_arbitrary_element]]
	      [let [[relation-count [get relation count]]]
		[if [> relation-count 1]
		    [set relation count [- relation-count 1]]
		  [prog [have this remove_type_from_goal_states event_time semantic_physical_object_type_event_source key_type key semantic_physical_object_type_event_target]
			[have semantic_physical_object_type_event_source remove compound_key [get semantic_physical_object_type_event_target phenomenal_name] relation]
			`[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] remove_semantic_frame relation]
			[set relation absolute_end_time [new semantic_time event_time]]
			]]]]]]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute execute_resource_raw_funk []
  [let [[physical_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `physical_knowledge->physical_type_knowledge]]]
    [while t
      [let [[event [have physical_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [if debug `[terminal_format standard-terminal '\n  translate physical->physical_type event: ' event]]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[event-time           [get event time]]
										     [event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[and [eq event-key_type `property] [eq event-key `physical_object_type]]
											'create semantic_physical_object_type_event.'
											[let [[event-value-semantic_physical_object_type_event [get this semantic_physical_object_type_event event-value]]]
											  [set event-value-semantic_physical_object_type_event absolute_start_time [new semantic_time event-time]]]
											[have event-semantic_frame map_type_key_values
											      [funk [slot_type slot_key slot_value]
												    [if [is-type `symbol slot_value]
													[let [[event-semantic_frame-slot_value-semantic_physical_object_type_event_with_property_type [get this semantic_physical_object_type_event_with_property_type event-value slot_type slot_key slot_value]]]
													  [set event-semantic_frame-slot_value-semantic_physical_object_type_event_with_property_type absolute_start_time [new semantic_time event-time]]]]]]
											]
										       [[is-type `semantic_physical_object event-semantic_frame]
											[let [[event-semantic_frame-copy [get this semantic_physical_object_copy [get event-semantic_frame phenomenal_name] [get event-semantic_frame physical_object_type]]]
											      [event-value-copy          [if [is-type `semantic_physical_object event-value]
															     [get this semantic_physical_object_copy [get event-value phenomenal_name] [get event-value physical_object_type]]
															   event-value]]]
											  [if debug [terminal_format standard-terminal
														     '\nadding physical type ' [get event-semantic_frame-copy phenomenal_name]
														     ' '                       event-key_type
														     ' '                       event-key
														     ' '                       [if [is-type `semantic_physical_object event-value-copy]
																		   [get event-value-copy phenomenal_name]
																		 event-value-copy]]]
											  [have event-semantic_frame-copy add event-key_type event-key event-value-copy]
											  'should use copy after this point'
											  
											  [cond [[translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property event-semantic_frame-copy event-key_type event-key event-value-copy]
												 [let [[event-semantic_physical_object_type_event [get this semantic_physical_object_type_event_with_property_type
																		 [get event-semantic_frame-copy physical_object_type]
																		 event-key_type
																		 event-key
																		 event-value-copy]]]
												   
												   [have event-semantic_frame-copy map_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [if [is-type `semantic_physical_object slot_value]
														   [mapc [funk [forward_semantic_physical_object_type_event]
															       [have this add_type_relation event-time event-semantic_physical_object_type_event slot_type slot_key forward_semantic_physical_object_type_event]]
															 [get this all_semantic_physical_object_type_events slot_value]]]]]
												   
												   [have event-semantic_frame-copy map_reverse_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [if [is-type `semantic_physical_object slot_value]
														   [mapc [funk [backward_semantic_physical_object_type_event]
															       [have this add_type_relation event-time backward_semantic_physical_object_type_event slot_type slot_key event-semantic_physical_object_type_event]]
															 [get this all_semantic_physical_object_type_events slot_value]]]]]
												   
												   ]]
												[[and [eq event-key_type `preposition] [is-type `semantic_physical_object event-value-copy]]
												 [let []
												   [mapc [funk [event-semantic_physical_object_type_event]
													       [mapc [funk [event-value-semantic_physical_object_type_event]
															   [have this add_type_relation event-time event-semantic_physical_object_type_event event-key_type event-key event-value-semantic_physical_object_type_event]]
														     [get this all_semantic_physical_object_type_events event-value-copy]]]
													 [get this all_semantic_physical_object_type_events event-semantic_frame-copy]]
												   ]]
												]
											  ]]
										       ]
										 ]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `remove]]                       [let [[event-time           [get event time]]
										     [event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[is-type `semantic_physical_object event-semantic_frame]
											[let [[event-semantic_frame-copy [get this semantic_physical_object_copy [get event-semantic_frame phenomenal_name] [get event-semantic_frame physical_object_type]]]
											      [event-value-copy          [if [is-type `semantic_physical_object event-value]
															     [get this semantic_physical_object_copy [get event-value phenomenal_name] [get event-value physical_object_type]]
															   event-value]]]
											  'should use copy after this point'

											  [cond [[translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property event-semantic_frame-copy event-key_type event-key event-value-copy]
												 [let [[event-semantic_physical_object_type_event [get this semantic_physical_object_type_event_with_property_type
																		 [get event-semantic_frame-copy physical_object_type]
																		 event-key_type
																		 event-key
																		 event-value-copy]]]
												   
												   [have event-semantic_frame-copy map_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [if [is-type `semantic_physical_object slot_value]
														   [mapc [funk [forward_semantic_physical_object_type_event]
															       [have this remove_type_relation event-time event-semantic_physical_object_type_event slot_type slot_key forward_semantic_physical_object_type_event]]
															 [get this all_semantic_physical_object_type_events slot_value]]]]]
												   
												   [have event-semantic_frame-copy map_reverse_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [if [is-type `semantic_physical_object slot_value]
														   [mapc [funk [backward_semantic_physical_object_type_event]
															       [have this remove_type_relation event-time backward_semantic_physical_object_type_event slot_type slot_key event-semantic_physical_object_type_event]]
															 [get this all_semantic_physical_object_type_events slot_value]]]]]
												   
												   ]]
												[[and [eq event-key_type `preposition] [is-type `semantic_physical_object event-value-copy]]
												 [let []
												   [mapc [funk [event-semantic_physical_object_type_event]
													       [mapc [funk [event-value-semantic_physical_object_type_event]
															   [have this remove_type_relation event-time event-semantic_physical_object_type_event event-key_type event-key event-value-semantic_physical_object_type_event]]
														     [get this all_semantic_physical_object_type_events event-value-copy]]]
													 [get this all_semantic_physical_object_type_events event-semantic_frame-copy]]
												   ]]
												]
											  
											  'remove from event-semantic_frame-copy'
											  [if debug
											      [terminal_format standard-terminal
													       '\nremoving physical type ' [get event-semantic_frame-copy phenomenal_name]
													       ' '                         event-key_type
													       ' '                         event-key
													       ' '                         [if [is-type `semantic_physical_object event-value-copy]
																	       [get event-value-copy phenomenal_name]
																	     event-value-copy]]]
											  [have event-semantic_frame-copy remove event-key_type event-key event-value-copy]
											  ]]
										       ]
										 ]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_physical_changes]]      [prog [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
												      'end_of_physical_changes found: added end_of_physical_type_changes to physical_type_knowledge trace events.']
										     [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_type_changes nil]]
										     [have end_of_physical_type_changes_trigger trigger]
										     nil]]
			  ]]]]
	[have physical_knowledge_iterator increment]]]]]



