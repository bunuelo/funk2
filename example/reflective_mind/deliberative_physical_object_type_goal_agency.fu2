'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'



'deliberative_physical_object_type_goal_agency'

[deframe deliberative_physical_object_type_goal_agency [agency] []
  [new []
       [construct agency `physical_object_type_goal]
       [have this add_resource [new translate_physical_knowledge_to_physical_type_knowledge_resource]]
       ]]

[deftypefunk deliberative_physical_object_type_goal_agency execute create_knowledge []
  [have [get this mind] add_semantic_knowledge_base [new forgetful_semantic_event_knowledge_base `type_copy_of_physical_knowledge        [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new forgetful_semantic_event_knowledge_base `physical_type_knowledge                [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new forgetful_semantic_event_knowledge_base `physical_goal_knowledge                [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new forgetful_semantic_event_knowledge_base `physical_type_counterfactual_knowledge [get [get this mind] semantic_realm]]]
  ]

[deftypefunk deliberative_physical_object_type_goal_agency execute connect_knowledge_reflection []
  [have [get this mind] create_knowledge_event_stream_iterator `physical_knowledge `physical_knowledge->physical_type_knowledge]
  ]

[deftypefunk deliberative_physical_object_type_goal_agency get physical_type_knowledge_reflective_timer []
  [get [get this resource `translate_physical_knowledge_to_physical_type_knowledge] physical_type_knowledge_reflective_timer]]

[deftypefunk deliberative_physical_object_type_goal_agency get knowledge_timer []
  [get this physical_type_knowledge_reflective_timer]]

[deftypefunk deliberative_physical_object_type_goal_agency execute add_remember_token [remember_token]
  [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_remember_token remember_token]]

[deftypefunk deliberative_physical_object_type_goal_agency execute remove_remember_token [remember_token]
  [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] remove_remember_token remember_token]]

[deftypefunk deliberative_physical_object_type_goal_agency execute wait_until_time_represented [time]
  [have [get this knowledge_timer] wait_until time]]

[deftypefunk deliberative_physical_object_type_goal_agency execute wait_until_after_time_represented [time]
  [have [get this knowledge_timer] wait_until_after time]]

[deftypefunk deliberative_physical_object_type_goal_agency execute create_physical_type_property_relationship_goal [source_type
														    source_key_type
														    source_key
														    source_value
														    key_type
														    key
														    target_type
														    target_key_type
														    target_key
														    target_value]
  [let [[resource [get this resource `translate_physical_knowledge_to_physical_type_knowledge]]]
    [let [[goal [new physical_type_property_relation_goal
		     [get this mind]
		     source_type
		     source_key_type
		     source_key
		     source_value
		     key_type
		     key
		     target_type
		     target_key_type
		     target_key
		     target_value]]]
      [have resource add_goal goal]
      [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
		       'agency, ' name ', adding physical goal "' [get goal as-declarative_string] '."']
      ]]]



'translate_physical_knowledge_to_physical_type_knowledge_resource'

[deframe translate_physical_knowledge_to_physical_type_knowledge_resource [vital_resource] [[semantic_reflective_object_type_event_mutex [new mutex]]
											    [semantic_reflective_object_copy_mutex       [new mutex]]
											    [goals                                       nil]
											    [end_of_physical_type_changes_trigger        [new fiber_trigger]]
											    [physical_type_knowledge_reflective_timer    [new reflective_timer [new semantic_time `before]]]]
  [new []
       [construct vital_resource `translate_physical_knowledge_to_physical_type_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       nil]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute add_goal [goal]
  `[terminal_format standard-terminal '\ndeliberative_layer: adding physical goal, "' [get goal as-string] '."']
  [= goals [cons goal goals]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute add_type_to_goal_states [event_time
													       semantic_reflective_object_type_event_source
													       key_type
													       key
													       semantic_reflective_object_type_event_target]
  [mapc [funk [goal]
	      [have goal add_type_event
		    event_time
		    semantic_reflective_object_type_event_source
		    key_type
		    key
		    semantic_reflective_object_type_event_target]]
	goals]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute remove_type_from_goal_states [event_time
														    semantic_reflective_object_type_event_source
														    key_type
														    key
														    semantic_reflective_object_type_event_target]
  [mapc [funk [goal]
	      [have goal remove_type_event
		    event_time
		    semantic_reflective_object_type_event_source
		    key_type
		    key
		    semantic_reflective_object_type_event_target]]
	goals]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_reflective_object_copy [phenomenal_name reflective_object_type]
  [let [[semantic_reflective_object nil]]
    [have semantic_reflective_object_type_event_mutex lock]
    [let [[copy_phenomenal_name [get [format nil 'physical_type_copy_of_' phenomenal_name] as-symbol]]]
      [= semantic_reflective_object [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame copy_phenomenal_name]]
      [if [null semantic_reflective_object]
	  [prog [= semantic_reflective_object [new semantic_reflective_object [get [get this mind] semantic_realm]]]
		[set semantic_reflective_object phenomenal_name        phenomenal_name]
		[set semantic_reflective_object reflective_object_type reflective_object_type]
		[have [get [get this mind] semantic_knowledge_base `type_copy_of_physical_knowledge] add_semantic_frame semantic_reflective_object]
		[have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame copy_phenomenal_name semantic_reflective_object]
		]]
      [have semantic_reflective_object_type_event_mutex unlock]
      semantic_reflective_object]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_reflective_object_type_event [phenomenal_name]
  [let [[semantic_reflective_object_type_event nil]]
    [have semantic_reflective_object_copy_mutex lock]
    [= semantic_reflective_object_type_event [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]
    [if [null semantic_reflective_object_type_event]
	[prog [= semantic_reflective_object_type_event [new semantic_reflective_object_type_event [get [get this mind] semantic_realm]
							  [object_type_event-phenomenal_name phenomenal_name]
							  phenomenal_name]]
	      `[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame semantic_reflective_object_type_event]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_reflective_object_type_event]
	      ]]
    [have semantic_reflective_object_copy_mutex unlock]
    semantic_reflective_object_type_event]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_reflective_object_type_event_with_property_type [phenomenal_name property_key property property_value]
  [let [[object_type_with_propety_phenomenal_name [semantic_object_property_type_event-phenomenal_name phenomenal_name property_key property property_value]]]
    [get this semantic_reflective_object_type_event object_type_with_propety_phenomenal_name]]]

[defunk translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property [source key_type key target]
  [and [is-type `semantic_reflective_object source]
       [not [and [eq `property key_type] [eq `physical_object_type key]]]
       [or [null target] [is-type `symbol target]]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get all_semantic_reflective_object_type_events [semantic_reflective_object]
  [let [[semantic_reflective_object_type_events nil]]
    [= semantic_reflective_object_type_events [cons [get this semantic_reflective_object_type_event [get semantic_reflective_object reflective_object_type]]
					    semantic_reflective_object_type_events]]
    [have semantic_reflective_object map_type_key_values
	  [funk [slot_type slot_key slot_value]
		[if [translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property semantic_reflective_object slot_type slot_key slot_value]
		    [= semantic_reflective_object_type_events [cons [get this semantic_reflective_object_type_event_with_property_type
								       [get semantic_reflective_object reflective_object_type]
								       slot_type
								       slot_key
								       slot_value]
								  semantic_reflective_object_type_events]]]]]
    semantic_reflective_object_type_events]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute add_type_relation [event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]
  [if debug [terminal_format standard-terminal '\nadd_type_relation ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' [get semantic_reflective_object_type_event_target phenomenal_name]]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[relation_set [have semantic_reflective_object_type_event_source lookup_set compound_key [get semantic_reflective_object_type_event_target phenomenal_name]]]
	  [relation     nil]]
      [if [or [null relation_set] [get relation_set is_empty]]
	  [let [[relation-phenomenal_name   [semantic_object_relation_type_event-phenomenal_name [get semantic_reflective_object_type_event_source phenomenal_name]
												 key_type
												 key
												 [get semantic_reflective_object_type_event_target phenomenal_name]]]
		[relation-meta_relationship [have [get [get this mind] semantic_realm] lookup_or_create_meta_relationship
						  semantic_reflective_object_type_event_source
						  key_type
						  key
						  semantic_reflective_object_type_event_target]]]
	    [= relation [new semantic_reflective_object_type_relation_event [get [get this mind] semantic_realm]
			     relation-phenomenal_name
			     relation-meta_relationship
			     semantic_reflective_object_type_event_target]]
	    [set relation absolute_start_time [new semantic_time event_time]]
	    [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame relation]
	    [have semantic_reflective_object_type_event_source add compound_key [get semantic_reflective_object_type_event_target phenomenal_name] relation]
	    [have this add_type_to_goal_states event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]]
	[prog [= relation [get relation_set an_arbitrary_element]]
	      [set relation count [+ [get relation count] 1]]]]]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute remove_type_relation [event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]
  [if debug [terminal_format standard-terminal '\nremove_type_relation ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' [get semantic_reflective_object_type_event_target phenomenal_name]]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[relation_set [have semantic_reflective_object_type_event_source lookup_set compound_key [get semantic_reflective_object_type_event_target phenomenal_name]]]
	  [relation     nil]]
      [if [or [null relation_set] [get relation_set is_empty]]
	  [prog [terminal_format standard-terminal
				 '\ndeliberative warning: got remove ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' compound_key ' ' [get semantic_reflective_object_type_event_target phenomenal_name] ' relation, but no relation found.']
		]
	[prog [= relation [get relation_set an_arbitrary_element]]
	      [let [[relation-count [get relation count]]]
		[if [> relation-count 1]
		    [set relation count [- relation-count 1]]
		  [prog [have this remove_type_from_goal_states event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]
			[have semantic_reflective_object_type_event_source remove compound_key [get semantic_reflective_object_type_event_target phenomenal_name] relation]
			`[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] remove_semantic_frame relation]
			[set relation absolute_end_time [new semantic_time event_time]]
			]]]]]]]]


[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute add_type_property [event_time semantic_reflective_object_type_event_source key_type key target_property_name]
  [if debug [terminal_format standard-terminal '\nadd_type_property ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' target_property_name]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[property_set [have semantic_reflective_object_type_event_source lookup_set compound_key target_property_name]]
	  [property     nil]]
      [if [or [null property_set] [get property_set is_empty]]
	  [let [[property-phenomenal_name   [semantic_object_property_type_event-phenomenal_name [get semantic_reflective_object_type_event_source phenomenal_name]
												 key_type
												 key
												 target_property_name]]
		[property-meta_relationship [have [get [get this mind] semantic_realm] lookup_or_create_meta_relationship
						  semantic_reflective_object_type_event_source
						  key_type
						  key
						  target_property_name]]]
	    [= property [new semantic_reflective_object_type_property_event [get [get this mind] semantic_realm]
			     property-phenomenal_name
			     property-meta_relationship
			     target_property_name]]
	    [set property absolute_start_time [new semantic_time event_time]]
	    [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame property]
	    [have semantic_reflective_object_type_event_source add compound_key target_property_name property]
	    `[have this add_type_to_goal_states event_time semantic_reflective_object_type_event_source key_type key target_property_name]
	    ]
	[prog [= property [get property_set an_arbitrary_element]]
	      [set property count [+ [get property count] 1]]]]]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute remove_type_property [event_time semantic_reflective_object_type_event_source key_type key target_property_name]
  [if debug [terminal_format standard-terminal '\nremove_type_property ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' target_property_name]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[property_set [have semantic_reflective_object_type_event_source lookup_set compound_key target_property_name]]
	  [property     nil]]
      [if [or [null property_set] [get property_set is_empty]]
	  [prog [terminal_format standard-terminal
				 '\ndeliberative warning: got remove ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' compound_key ' ' target_property_name ' property, but no property found.']
		]
	[prog [= property [get property_set an_arbitrary_element]]
	      [let [[property-count [get property count]]]
		[if [> property-count 1]
		    [set property count [- property-count 1]]
		  [prog `[have this remove_type_from_goal_states event_time semantic_reflective_object_type_event_source key_type key target_property_name]
			[have semantic_reflective_object_type_event_source remove compound_key target_property_name property]
			`[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] remove_semantic_frame property]
			[set property absolute_end_time [new semantic_time event_time]]
			]]]]]]]]


[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute execute_resource_raw_funk []
  [let [[physical_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `physical_knowledge->physical_type_knowledge]]
	[old_remember_token          nil]]
    [while t
      [let* [[event          [have physical_knowledge_iterator wait_for_current]]
	     [remember_token [new remember_token [new semantic_time [get event time]]]]]
	[have [get this agency] add_remember_token remember_token]
	[if old_remember_token
	    [have [get this agency] remove_remember_token old_remember_token]]
	[if [not [null event]]
	    [prog [if debug [terminal_format standard-terminal '\ntranslate_physical_knowledge_to_physical_type_knowledge_resource event: ' event]]
		  [let [[event_type [get event event_type]]
			[event-time [get event time]]]
		    [cond [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[is-type `semantic_reflective_object event-semantic_frame]
											[let [[event-semantic_frame-copy [get this semantic_reflective_object_copy [get event-semantic_frame phenomenal_name] [get event-semantic_frame reflective_object_type]]]
											      [event-value-copy          [if [is-type `semantic_reflective_object event-value]
															     [get this semantic_reflective_object_copy [get event-value phenomenal_name] [get event-value reflective_object_type]]
															   event-value]]]
											  [if debug [terminal_format standard-terminal
														     '\nadding physical type ' [get event-semantic_frame-copy phenomenal_name]
														     ' '                       event-key_type
														     ' '                       event-key
														     ' '                       [if [is-type `semantic_reflective_object event-value-copy]
																		   [get event-value-copy phenomenal_name]
																		 event-value-copy]]]
											  [have event-semantic_frame-copy add event-key_type event-key event-value-copy]
											  'should use copy after this point'
											  
											  [cond [[translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property event-semantic_frame-copy event-key_type event-key event-value-copy]
												 [let [[event-semantic_reflective_object_type_event [get this semantic_reflective_object_type_event_with_property_type
																			 [get event-semantic_frame-copy reflective_object_type]
																			 event-key_type
																			 event-key
																			 event-value-copy]]]
												   
												   [mapc [funk [event-semantic_reflective_object_type_event]
													       [have this add_type_property event-time event-semantic_reflective_object_type_event event-key_type event-key event-value-copy]]
													 [get this all_semantic_reflective_object_type_events event-semantic_frame-copy]]
												   
												   [have event-semantic_frame-copy map_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [cond [[is-type `semantic_reflective_object slot_value]
														      [mapc [funk [forward_semantic_reflective_object_type_event]
																  [have this add_type_relation event-time event-semantic_reflective_object_type_event slot_type slot_key forward_semantic_reflective_object_type_event]]
															    [get this all_semantic_reflective_object_type_events slot_value]]]]]]
												   
												   [have event-semantic_frame-copy map_reverse_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [cond [[is-type `semantic_reflective_object slot_value]
														      [mapc [funk [backward_semantic_reflective_object_type_event]
																  [have this add_type_relation event-time backward_semantic_reflective_object_type_event slot_type slot_key event-semantic_reflective_object_type_event]]
															    [get this all_semantic_reflective_object_type_events slot_value]]]]]]
												   
												   ]]
												[[is-type `semantic_reflective_object event-value-copy]
												 [mapc [funk [event-semantic_reflective_object_type_event]
													     [mapc [funk [event-value-semantic_reflective_object_type_event]
															 [have this add_type_relation event-time event-semantic_reflective_object_type_event event-key_type event-key event-value-semantic_reflective_object_type_event]]
														   [get this all_semantic_reflective_object_type_events event-value-copy]]]
												       [get this all_semantic_reflective_object_type_events event-semantic_frame-copy]]]
												]
											  ]]
										       ]
										 ]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `remove]]                       [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[is-type `semantic_reflective_object event-semantic_frame]
											[let [[event-semantic_frame-copy [get this semantic_reflective_object_copy [get event-semantic_frame phenomenal_name] [get event-semantic_frame reflective_object_type]]]
											      [event-value-copy          [if [is-type `semantic_reflective_object event-value]
															     [get this semantic_reflective_object_copy [get event-value phenomenal_name] [get event-value reflective_object_type]]
															   event-value]]]
											  'should use copy after this point'
											  
											  [cond [[translate_physical_knowledge_to_physical_type_knowledge_resource-edge_is_type_property event-semantic_frame-copy event-key_type event-key event-value-copy]
												 [let [[event-semantic_reflective_object_type_event [get this semantic_reflective_object_type_event_with_property_type
																		       [get event-semantic_frame-copy reflective_object_type]
																		       event-key_type
																		       event-key
																		       event-value-copy]]]
												   
												   [mapc [funk [event-semantic_reflective_object_type_event]
													       [have this remove_type_property event-time event-semantic_reflective_object_type_event event-key_type event-key event-value-copy]]
													 [get this all_semantic_reflective_object_type_events event-semantic_frame-copy]]
												   
												   [have event-semantic_frame-copy map_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [cond [[is-type `semantic_reflective_object slot_value]
														      [mapc [funk [forward_semantic_reflective_object_type_event]
																  [have this remove_type_relation event-time event-semantic_reflective_object_type_event slot_type slot_key forward_semantic_reflective_object_type_event]]
															    [get this all_semantic_reflective_object_type_events slot_value]]]]]]
												   
												   [have event-semantic_frame-copy map_reverse_type_key_values
													 [funk [slot_type slot_key slot_value]
													       [if [is-type `semantic_reflective_object slot_value]
														   [mapc [funk [backward_semantic_reflective_object_type_event]
															       [have this remove_type_relation event-time backward_semantic_reflective_object_type_event slot_type slot_key event-semantic_reflective_object_type_event]]
															 [get this all_semantic_reflective_object_type_events slot_value]]]]]
												   
												   ]]
												[[is-type `semantic_reflective_object event-value-copy]
												 [mapc [funk [event-semantic_reflective_object_type_event]
													     [mapc [funk [event-value-semantic_reflective_object_type_event]
															 [have this remove_type_relation event-time event-semantic_reflective_object_type_event event-key_type event-key event-value-semantic_reflective_object_type_event]]
														   [get this all_semantic_reflective_object_type_events event-value-copy]]]
												       [get this all_semantic_reflective_object_type_events event-semantic_frame-copy]]]
												]
											  
											  'remove from event-semantic_frame-copy'
											  [if debug
											      [terminal_format standard-terminal
													       '\nremoving physical type ' [get event-semantic_frame-copy phenomenal_name]
													       ' '                         event-key_type
													       ' '                         event-key
													       ' '                         [if [is-type `semantic_reflective_object event-value-copy]
																	       [get event-value-copy phenomenal_name]
																	     event-value-copy]]]
											  [have event-semantic_frame-copy remove event-key_type event-key event-value-copy]
											  ]]
										       ]
										 ]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_physical_changes]]      [prog [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
												      'end_of_physical_changes found: added end_of_physical_type_changes to physical_type_knowledge trace events.']
										     [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_type_changes nil]]
										     [have end_of_physical_type_changes_trigger trigger]
										     nil]]
			  ]
		    'Now that event has been processed, we update the knowledge timer.'
		    [set physical_type_knowledge_reflective_timer current_time [new semantic_time event-time]]
		    ]]]
	[= old_remember_token remember_token]
	[have physical_knowledge_iterator increment]]]]]





