'Copyright (c) 2007-2011 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'learned_reactive_physical_knowledge_agency'

[deframe learned_reactive_physical_knowledge_agency [agency] []
  [new []
       [construct agency `physical_knowledge]
       [have this add_resource [new translate_visual_knowledge_to_physical_knowledge_resource]]
       [have this add_resource [new translate_physical_knowledge_to_physical_type_knowledge_resource]]
       this]]


[deftypefunk learned_reactive_physical_knowledge_agency execute create_knowledge []
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `physical_knowledge              [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `type_copy_of_physical_knowledge [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `physical_type_knowledge         [get [get this mind] semantic_realm]]]
  ]

[deftypefunk learned_reactive_physical_knowledge_agency execute connect_knowledge_reflection []
  [have [get this mind] create_knowledge_event_stream_iterator `visual_knowledge   `visual_knowledge->physical_knowledge]
  [have [get this mind] create_knowledge_event_stream_iterator `physical_knowledge `physical_knowledge->physical_type_knowledge]
  ]


'translate_visual_knowledge_to_physical_knowledge_resource'

[deframe translate_visual_knowledge_to_physical_knowledge_resource [traced_resource] [[semantic_physical_object_mutex [new mutex]]]
  [new []
       [construct traced_resource `translate_visual_knowledge_to_physical_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_visual_knowledge_to_physical_knowledge_resource get semantic_physical_object [phenomenal_name physical_object_type]
  [let [[semantic_physical_object nil]]
    [have semantic_physical_object_mutex lock]
    [= semantic_physical_object [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]
    [if [null semantic_physical_object]
	[prog [= semantic_physical_object [new semantic_physical_object [get [get this mind] semantic_realm]]]
	      [set semantic_physical_object phenomenal_name      phenomenal_name]
	      [set semantic_physical_object physical_object_type physical_object_type]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_physical_object]
	      ]]
    [have semantic_physical_object_mutex unlock]
    semantic_physical_object]]

[deftypefunk translate_visual_knowledge_to_physical_knowledge_resource execute execute_resource_raw_funk []
  [let [[visual_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `visual_knowledge->physical_knowledge]]]
    [semantic_physical_object_type_relation-core_extension-ping]
    [while t
      `[print 'translate_visual_knowledge_to_physical_knowledge_resource waiting for visual_knowledge_iterator.']
      [let [[event [have visual_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [have this-resource think_to_self 'translate visual->physical visual event: ' event]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `add_semantic_frame]]           [let [[semantic_frame [get event semantic_frame]]]
										 [if [is-type `semantic_visual_object semantic_frame]
										     [let [[phenomenal_name      [get semantic_frame phenomenal_name]]
											   [physical_object_type [get semantic_frame physical_object_type]]]
										       [let [[semantic_physical_object [get this semantic_physical_object phenomenal_name physical_object_type]]]
											 [have [get [get this mind] semantic_knowledge_base `physical_knowledge] add_semantic_frame semantic_physical_object]
											 ]]]]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `remove_semantic_frame]]        [let [[semantic_frame [get event semantic_frame]]]
										 [if [is-type `semantic_visual_object semantic_frame]
										     [let [[phenomenal_name      [get semantic_frame phenomenal_name]]
											   [physical_object_type [get semantic_frame physical_object_type]]]
										       [let [[semantic_physical_object [get this semantic_physical_object phenomenal_name physical_object_type]]]
											 [have [get [get this mind] semantic_knowledge_base `physical_knowledge] remove_semantic_frame semantic_physical_object]
											 ]]]]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[key_type [get event key_type]]
										     [key      [get event key]]]
										 `[terminal_format standard-terminal '\nvisual->physical relation add event: ' key_type ' ' key]
										 [cond [[eq key_type `property]    [let [[subject  [get event semantic_frame]]
															 [property [get event value]]]
														     [let [[subject-phenomenal_name      [get subject phenomenal_name]]
															   [subject-physical_object_type [get subject physical_object_type]]]
														       [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name subject-physical_object_type]]]
															 [have subject-semantic_physical_object assure_exists key_type key property]]]]]
										       [[eq key_type `preposition] [let [[subject [get event semantic_frame]]
															 [object  [get event value]]]
														     [if object
															 [let [[subject-phenomenal_name      [get subject phenomenal_name]]
															       [subject-physical_object_type [get subject physical_object_type]]
															       [object-phenomenal_name       [get object  phenomenal_name]]
															       [object-physical_object_type  [get object  physical_object_type]]]
															   [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name subject-physical_object_type]]
																 [object-semantic_physical_object  [get this semantic_physical_object object-phenomenal_name  object-physical_object_type]]]
															     [have subject-semantic_physical_object assure_exists `preposition key object-semantic_physical_object]]]]]]
										       ]]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `remove]]                       [let [[key_type [get event key_type]]
										     [key      [get event key]]]
										 `[terminal_format standard-terminal '\nvisual->physical relation remove event: ' key_type ' ' key]
										 [cond [[eq key_type `property]    [let [[subject  [get event semantic_frame]]
															 [property [get event value]]]
														     [let [[subject-phenomenal_name      [get subject phenomenal_name]]
															   [subject-physical_object_type [get subject physical_object_type]]]
														       [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name subject-physical_object_type]]]
															 [have subject-semantic_physical_object remove key_type key property]]]]]
										       [[eq key_type `preposition] [let [[subject [get event semantic_frame]]
															 [object  [get event value]]]
														     [if object
															 [let [[subject-phenomenal_name      [get subject phenomenal_name]]
															       [subject-physical_object_type [get subject physical_object_type]]
															       [object-phenomenal_name       [get object  phenomenal_name]]
															       [object-physical_object_type  [get object  physical_object_type]]]
															   [let [[subject-semantic_physical_object [get this semantic_physical_object subject-phenomenal_name subject-physical_object_type]]
																 [object-semantic_physical_object  [get this semantic_physical_object object-phenomenal_name  object-physical_object_type]]]
															     [have subject-semantic_physical_object remove `preposition key object-semantic_physical_object]]]]]]
										       ]]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_visual_changes]]        [prog [have [get [get this mind] semantic_knowledge_base `physical_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_changes nil]]
										     nil]]
			  ]]]]
	[have visual_knowledge_iterator increment]]]]]



'translate_physical_knowledge_to_physical_type_knowledge_resource'

[deframe translate_physical_knowledge_to_physical_type_knowledge_resource [traced_resource] [[semantic_physical_object_type_mutex [new mutex]]
											     [semantic_physical_object_copy_mutex [new mutex]]]
  [new []
       [construct traced_resource `translate_physical_knowledge_to_physical_type_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_copy [phenomenal_name physical_object_type]
  [let [[semantic_physical_object nil]]
    [have semantic_physical_object_type_mutex lock]
    [let [[copy_phenomenal_name [get [format nil 'physical_type_copy_of_' phenomenal_name] as-symbol]]]
      [= semantic_physical_object [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame copy_phenomenal_name]]
      [if [null semantic_physical_object]
	  [prog [= semantic_physical_object [new semantic_physical_object [get [get this mind] semantic_realm]]]
		[set semantic_physical_object phenomenal_name      phenomenal_name]
		[set semantic_physical_object physical_object_type physical_object_type]
		[have [get [get this mind] semantic_knowledge_base `type_copy_of_physical_knowledge] add_semantic_frame semantic_physical_object]
		[have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame copy_phenomenal_name semantic_physical_object]
		]]
      [have semantic_physical_object_type_mutex unlock]
      semantic_physical_object]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_type [phenomenal_name]
  [let [[semantic_physical_object_type nil]]
    [have semantic_physical_object_copy_mutex lock]
    [= semantic_physical_object_type [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]
    [if [null semantic_physical_object_type]
	[prog [= semantic_physical_object_type [new semantic_physical_object_type [get [get this mind] semantic_realm]]]
	      [set semantic_physical_object_type phenomenal_name phenomenal_name]
	      [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame semantic_physical_object_type]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_physical_object_type]
	      ]]
    [have semantic_physical_object_copy_mutex unlock]
    semantic_physical_object_type]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource get semantic_physical_object_type_with_property_type [phenomenal_name property_key property property_value]
  [let [[object_type_with_propety_phenomenal_name [get [format nil phenomenal_name '_' property_key '_' property '_' property_value] as-symbol]]]
    [get this semantic_physical_object_type object_type_with_propety_phenomenal_name]]]

[deftypefunk translate_physical_knowledge_to_physical_type_knowledge_resource execute execute_resource_raw_funk []
  [let [[physical_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `physical_knowledge->physical_type_knowledge]]]
    [while t
      [let [[event [have physical_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [if [get this debug] [terminal_format standard-terminal '\n  translate physical->physical_type event: ' event]]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[and [eq event-key_type `property] [eq event-key `physical_object_type]]
											'create semantic_physical_object_type.'
											[get this semantic_physical_object_type event-value]
											[have event-semantic_frame map_type_key_values
											      [funk [slot_type slot_key slot_value]
												    [if [is-type `symbol slot_value]
													[get this semantic_physical_object_type_with_property_type event-value slot_type slot_key slot_value]]]]
											]
										       [[is-type `semantic_physical_object event-semantic_frame]
											[let [[event-semantic_frame-copy [get this semantic_physical_object_copy [get event-semantic_frame phenomenal_name] [get event-semantic_frame physical_object_type]]]
											      [event-value-copy          [if [is-type `semantic_physical_object event-value]
															     [get this semantic_physical_object_copy [get event-value phenomenal_name] [get event-value physical_object_type]]
															   event-value]]
											      [compound_key              [get [format nil [get event-key_type as-string] '_' [get event-key as-string]] as-symbol]]]
											  [terminal_format standard-terminal
													   '\nadding ' [get event-semantic_frame-copy phenomenal_name]
													   ' '         event-key_type
													   ' '         event-key
													   ' '         [if [is-type `semantic_physical_object event-value-copy]
															   [get event-value-copy phenomenal_name]
															 event-value-copy]]
											  [have event-semantic_frame-copy add event-key_type event-key event-value-copy]
											  'should use copy after this point'
											  [let [[event-semantic_frame-semantic_physical_object_types nil]
												[event-value-semantic_physical_object_types          nil]]
											    
											    [= event-semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type [get event-semantic_frame-copy physical_object_type]]
																			 event-semantic_frame-semantic_physical_object_types]]
											    [if [is-type `semantic_physical_object event-value-copy]
												[prog [= event-value-semantic_physical_object_types [cons [get this semantic_physical_object_type [get event-value-copy physical_object_type]]
																			  event-value-semantic_physical_object_types]]
												      [have event-value-copy map_type_key_values
													    [funk [slot_type slot_key slot_value]
														  `[terminal_format standard-terminal '\n---> ' slot_type ' ' slot_key ' ' slot_value]
														  [if [and [not [and [eq `property slot_type] [eq `physical_object_type slot_key]]]
															   [is-type `symbol slot_value]]
														      [= event-value-semantic_physical_object_types [cons [get this semantic_physical_object_type_with_property_type
																					       [get event-value-copy physical_object_type]
																					       slot_type
																					       slot_key
																					       slot_value]
																					  event-value-semantic_physical_object_types]]]]]]]
											    [if [is-type `symbol event-value-copy]
												[= event-semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type_with_property_type
																				  [get event-semantic_frame-copy physical_object_type]
																				  event-key_type
																				  event-key
																				  event-value-copy]
																			     event-semantic_frame-semantic_physical_object_types]]]
											    [if [is-type `symbol event-value-copy]
												[have event-semantic_frame-copy map_reverse_type_key_values
												      [funk [slot_type slot_key slot_value]
													    [let [[reverse_compound_key [get [format nil [get slot_type as-string] '_' [get slot_key as-string]] as-symbol]]]
													      [let [[event-reverse_semantic_frame-semantic_physical_object_types nil]]
														[if [is-type `semantic_physical_object slot_value]
														    [prog [= event-reverse_semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type [get slot_value physical_object_type]]
																							       event-reverse_semantic_frame-semantic_physical_object_types]]
															  `[terminal_format standard-terminal '\n<--- ' slot_type ' ' slot_key ' ' slot_value]
															  [= event-reverse_semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type_with_property_type
																								    [get slot_value physical_object_type]
																								    slot_type
																								    slot_key
																								    event-semantic_frame-copy]
																							       event-reverse_semantic_frame-semantic_physical_object_types]]
															  ]]]]]]]
											    [mapc [funk [event-semantic_frame-semantic_physical_object_type]
													[mapc [funk [event-value-semantic_physical_object_type]
														    [terminal_format standard-terminal
																     '\nadding relation ' [get event-semantic_frame-semantic_physical_object_type phenomenal_name]
																     ' '                  compound_key
																     ' '                  [get event-value-semantic_physical_object_type phenomenal_name]]
														    [let [[relation_set [have event-semantic_frame-semantic_physical_object_type lookup_set compound_key [get event-value-semantic_physical_object_type phenomenal_name]]]
															  [relation     nil]]
														      [if [or [null relation_set] [get relation_set is_empty]]
															  [prog [= relation [new semantic_physical_object_type_relation [get [get this mind] semantic_realm] event-value-semantic_physical_object_type]]
																[set relation phenomenal_name [get [string-concat [get [get event-semantic_frame-semantic_physical_object_type phenomenal_name] as-string]
																						  '_'
																						  [get compound_key as-string]
																						  '_'
																						  [get [get event-value-semantic_physical_object_type phenomenal_name] as-string]
																						  '_physical_object_type_relation']
																				   as-symbol]]
																[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_semantic_frame relation]
																[have event-semantic_frame-semantic_physical_object_type add compound_key [get event-value-semantic_physical_object_type phenomenal_name] relation]]
															[prog [= relation [get relation_set an_arbitrary_element]]
															      [set relation count [+ [get relation count] 1]]]]]]
													      event-value-semantic_physical_object_types]]
												  event-semantic_frame-semantic_physical_object_types]]]]
										       ]
										 ]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `remove]]                       [let [[event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[is-type `semantic_physical_object event-semantic_frame]
											[let [[event-semantic_frame-copy [get this semantic_physical_object_copy [get event-semantic_frame phenomenal_name] [get event-semantic_frame physical_object_type]]]
											      [event-value-copy          [if [is-type `semantic_physical_object event-value]
															     [get this semantic_physical_object_copy [get event-value phenomenal_name] [get event-value physical_object_type]]
															   event-value]]
											      [compound_key              [get [format nil [get event-key_type as-string] '_' [get event-key as-string]] as-symbol]]]
											  'should use copy after this point'
											  [let [[event-semantic_frame-semantic_physical_object_types nil]
												[event-value-semantic_physical_object_types          nil]]
											    [= event-semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type [get event-semantic_frame-copy physical_object_type]]
																			 event-semantic_frame-semantic_physical_object_types]]
											    [have event-semantic_frame-copy map_type_key_values
												  [funk [slot_type slot_key slot_value]
													[if [and [not [and [eq `property slot_type] [eq `physical_object_type slot_key]]]
														 [is-type `symbol slot_value]]
													    [= event-semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type_with_property_type
																					      [get event-semantic_frame-copy physical_object_type]
																					      slot_type
																					      slot_key
																					      slot_value]
																					 event-semantic_frame-semantic_physical_object_types]]]]]
											    [if [is-type `semantic_physical_object event-value]
												[prog [= event-value-semantic_physical_object_types [cons [get this semantic_physical_object_type [get event-value-copy physical_object_type]]
																			  event-value-semantic_physical_object_types]]
												      [have event-value-copy map_type_key_values
													    [funk [slot_type slot_key slot_value]
														  [if [and [not [and [eq `property slot_type] [eq `physical_object_type slot_key]]]
															   [is-type `symbol slot_value]]
														      [= event-value-semantic_physical_object_types [cons [get this semantic_physical_object_type_with_property_type
																					       [get event-value-copy physical_object_type]
																					       slot_type
																					       slot_key
																					       slot_value]
																					  event-value-semantic_physical_object_types]]]]]]]
											    [if [is-type `symbol event-value-copy]
												[= event-semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type_with_property_type
																				  [get event-semantic_frame-copy physical_object_type]
																				  event-key_type
																				  event-key
																				  event-value-copy]
																			     event-semantic_frame-semantic_physical_object_types]]]
											    [if [is-type `symbol event-value-copy]
												[have event-semantic_frame-copy map_reverse_type_key_values
												      [funk [slot_type slot_key slot_value]
													    [let [[reverse_compound_key [get [format nil [get slot_type as-string] '_' [get slot_key as-string]] as-symbol]]]
													      [let [[event-reverse_semantic_frame-semantic_physical_object_types nil]]
														[if [is-type `semantic_physical_object slot_value]
														    [prog [= event-reverse_semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type [get slot_value physical_object_type]]
																							       event-reverse_semantic_frame-semantic_physical_object_types]]
															  [= event-reverse_semantic_frame-semantic_physical_object_types [cons [get this semantic_physical_object_type_with_property_type
																								    [get slot_value physical_object_type]
																								    slot_type
																								    slot_key
																								    event-semantic_frame-copy]
																							       event-reverse_semantic_frame-semantic_physical_object_types]]
															  ]]]]]]]
											    [mapc [funk [event-semantic_frame-semantic_physical_object_type]
													[mapc [funk [event-value-semantic_physical_object_type]
														    [terminal_format standard-terminal
																     '\nremoving relation ' [get event-semantic_frame-semantic_physical_object_type phenomenal_name]
																     ' '                    compound_key
																     ' '                    [get event-value-semantic_physical_object_type phenomenal_name]]
														    [let [[relation_set [have event-semantic_frame-semantic_physical_object_type lookup_set compound_key [get event-value-semantic_physical_object_type phenomenal_name]]]
															  [relation     nil]]
														      [if [or [null relation_set] [get relation_set is_empty]]
															  [prog [terminal_format standard-terminal
																		 '\nwarning: got remove ' [get event-semantic_frame-semantic_physical_object_type phenomenal_name] ' ' compound_key ' ' [get event-value-semantic_physical_object_type phenomenal_name] ' relation, but no relation found.'
																		 '\n         ' event-semantic_frame-semantic_physical_object_type]
																]
															[prog [= relation [get relation_set an_arbitrary_element]]
															      [let [[relation-count [get relation count]]]
																[if [> relation-count 1]
																    [set relation count [- relation-count 1]]
																  [prog [have event-semantic_frame-semantic_physical_object_type remove compound_key [get event-value-semantic_physical_object_type phenomenal_name] relation]
																	[have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] remove_semantic_frame relation]
																	]]]]]]]
													      event-value-semantic_physical_object_types]]
												  event-semantic_frame-semantic_physical_object_types]]
											  'remove from event-semantic_frame-copy'
											  [terminal_format standard-terminal
													   '\nremoving ' [get event-semantic_frame-copy phenomenal_name]
													   ' '           event-key_type
													   ' '           event-key
													   ' '           [if [is-type `semantic_physical_object event-value-copy]
															     [get event-value-copy phenomenal_name]
															   event-value-copy]]
											  [have event-semantic_frame-copy remove event-key_type event-key event-value-copy]
											  ]]
										       ]
										 ]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_physical_changes]]      [prog [have [get [get this mind] semantic_knowledge_base `physical_type_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_physical_type_changes nil]]
										     nil]]
			  ]]]]
	[have physical_knowledge_iterator increment]]]]]



