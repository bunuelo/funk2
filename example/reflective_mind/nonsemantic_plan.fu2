'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[defunk name_expression-as-string [this]
  [cond [[is-type `string this] this]
	[t                      [get this as-string]]]]

[defunk name_expression-as-symbol [this]
  [get [name_expression-as-string this] as-symbol]]

[defunk nonsemantic_plan-unique_name_from_name_expression [name_expression]
  [name_expression-as-symbol name_expression]]








'nonsemantic_plan'

[deframe nonsemantic_plan [frame] [mental_layer
				   name_expression
				   name_patterns
				   variables
				   expression
				   [internal-default_variable_frame  nil]
				   [internal-unique_name             nil]
				   [internal-semantic_plan_object    nil]
				   [internal-compiled_funk           nil]
				   [internal-compiled_imagine_funk   nil]
				   [internal-natural_language_string nil]]
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [= mental_layer    initial-mental_layer]
       [= name_expression initial-name_expression]
       [= name_patterns   initial-name_patterns]
       [= variables       initial-variables]
       [= expression      initial-expression]
       [let [[semantic_plan_object [get this semantic_plan_object]]]
	 `[set semantic_plan_object plan_object_type `physical]
	 [have [get this mental_layer] add_semantic_plan semantic_plan_object]]]]

[deframe nonsemantic_condition [nonsemantic_plan] []
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [construct nonsemantic_plan
		  initial-mental_layer
		  initial-name_expression
		  initial-name_patterns
		  initial-variables
		  initial-expression]]]

[deframe nonsemantic_object [nonsemantic_plan] []
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [construct nonsemantic_plan
		  initial-mental_layer
		  initial-name_expression
		  initial-name_patterns
		  initial-variables
		  initial-expression]]]

[deftypefunk nonsemantic_plan get mental_layer_below []
  [get mental_layer mental_layer_below]]

[deftypefunk nonsemantic_plan get __default_variable_frame []
  [let [[default_variable_frame [new frame]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first variable_definition]]
		      [variable_value [second variable_definition]]]
		  [have default_variable_frame add variable_name variable_value]]]
	  variables]
    default_variable_frame]]

[deftypefunk nonsemantic_plan get default_variable_frame []
  [if [null internal-default_variable_frame]
      [= internal-default_variable_frame [get this __default_variable_frame]]]
  internal-default_variable_frame]

[deftypefunk nonsemantic_plan get new_copy_given_variable_frame [variable_frame]
  [let [[new_name_expressions nil]
	[new_variable_frame   [get variable_frame new_copy]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first  variable_definition]]
		      [variable_value [second variable_definition]]]
		  [if [get variable_frame contains variable_name]
		      [have new_variable_frame add variable_name [have variable_frame lookup variable_name]]
		    [have new_variable_frame add variable_name variable_value]]]]
	  variables]
    [let [[new_variables [mapcar [funk [variable_name]
				       `[,variable_name ,[have new_variable_frame lookup variable_name]]]
				 [get new_variable_frame keys]]]]
      [mapc [funk [name_pattern]
		  [let [[used_variable_frame [new frame]]]
		    [let [[new_name_expression [get name_pattern pattern_evaluation
						    [funk [variable_name]
							  [have used_variable_frame add variable_name t]
							  [if [get new_variable_frame contains variable_name]
							      [have new_variable_frame lookup variable_name]
							    [error bug_name     new_copy_given_variable_frame-could_not_find_variable_match_in_default_frame
								   this         this
								   name_pattern name_pattern]]]]]]
		      [let [[used_all_nondefault_variables t]]
			[mapc [funk [nondefault_variable_name]
				    [if [not [have used_variable_frame lookup nondefault_variable_name]]
					[= used_all_nondefault_variables nil]]]
			      [get variable_frame keys]]
			[if used_all_nondefault_variables
			    [= new_name_expressions [cons new_name_expression new_name_expressions]]]]]]]
	    name_patterns]
      [if [null new_name_expressions]
	  [error bug_name `nonsemantic_plan-new_copy_given_variable_frame-could_not_generate_new_name
		 this     this
		 variable_frame variable_frame]
	[let [[new_name_expression [car [reverse new_name_expressions]]]]
	  [new nonsemantic_plan
	       mental_layer
	       new_name_expression
	       name_patterns
	       new_variables
	       expression]]]]]]

[deftypefunk nonsemantic_plan get unique_name []
  [if [null internal-unique_name]
      [= internal-unique_name [nonsemantic_plan-unique_name_from_name_expression [get this name_expression]]]]
  internal-unique_name]

[deftypefunk nonsemantic_plan get mind []
  [get mental_layer mind]]

[deftypefunk nonsemantic_plan get name_pattern_match_pairs [expression]
  [let [[name_pattern_matches nil]]
    [mapc [funk [name_pattern]
		[let [[matches [string_pattern-match name_pattern expression]]]
		  [mapc [funk [match]
			      [= name_pattern_matches [cons [cons name_pattern match]
							    name_pattern_matches]]]
			matches]]]
	  name_patterns]
    name_pattern_matches]]

[deftypefunk nonsemantic_plan get sorted_name_pattern_matches [expression]
  [let* [[name_pattern_match_pairs [get this name_pattern_match_pairs expression]]]
    [mapcar [funk [name_pattern_match_pair]
		  [let [[match [cdr name_pattern_match_pair]]]
		    match]]
	    [mapcar [funk [pair]
			  [car pair]]
		    [have [mapcar [funk [name_pattern_match_pair]
					[let [[match [cdr name_pattern_match_pair]]]
					  [cons name_pattern_match_pair [length [get match keys]]]]]
				  name_pattern_match_pairs]
			  sort [funk [x y]
				     [< [cdr x] [cdr y]]]]]]]]

[deftypefunk nonsemantic_plan get expression-as_natural_language_string [expression]
  [cond [[is-type `symbol expression] expression]
	[[is-type `string expression] expression]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[eval-expression [elt arguments 0]]]
												  `[eval]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[quote-expression [elt arguments 0]]]
												  [cons quote-expression nil]]]]
						[[or [eq `list                       command]
						     [eq `backquote-list             command]] [stringlist-intersperse [mapcar [funk [argument]
																     [get this expression-as_natural_language_string argument]]
															       arguments]
														       ' ']]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[print-expression [elt arguments 0]]]
												  [get this expression-as_natural_language_string print-expression]]]]
						[[eq `prog                           command] [stringlist-concat [cons 'do the following in serial: '
														       [let [[step_number 1]]
															 [mapcar [funk [argument]
																       [let [[argument-result [stringlist-concat `[,[get step_number as-string] '. '
																						   ,[get this expression-as_natural_language_string argument]
																						   ,[if [not [== step_number arguments-length]]
																							', '
																						      '']]]]]
																	 [++ step_number]
																	 argument-result]]
																 arguments]]]]]
						[[eq `parog                          command] [apply &append
												     [append `[[do the following in parallel punctuation-colon]]
													     [let [[step_number 1]]
													       [mapcar [funk [argument]
															     [let [[argument-result [stringlist-concat `['*. '
																					 ,[get this expression-as_natural_language_string argument]
																					 ,[if [not [eq step_number arguments-length]]
																					      ', '
																					    '']]]]]
															       argument-result]]
														       arguments]]]]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[time_to_wait [elt arguments 0]]]
												  [append `[wait for]
													  `[,time_to_wait]]]]]
						[[eq `call-below                     command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[action_name      [get this expression-as_natural_language_string [elt arguments 0]]]
												      [action_arguments [mapcar [funk [argument]
																      [get this expression-as_natural_language_string arguments]]
																[cdr arguments]]]]
												  [stringlist-concat `['call action in layer below to ' ,action_name ' with arguments, ' @action_arguments]]]]]
						[[eq `call                           command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[action_name      [get this expression-as_natural_language_string [elt arguments 0]]]
												      [action_arguments [mapcar [funk [argument]
																      [get this expression-as_natural_language_string arguments]]
																[cdr arguments]]]]
												  [stringlist-concat `['call action to ' ,action_name ' with arguments, ' @action_arguments]]]]]
						[[eq `plan                           command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[plan_name [get this expression-as_natural_language_string [elt arguments 0]]]]
												  [stringlist-concat `['plan to ' ,plan_name]]]]]
						[[eq `plan-below                     command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[plan_name [get this expression-as_natural_language_string [elt arguments 0]]]]
												  [stringlist-concat `['plan in layer below to ' ,plan_name]]]]]
						[[eq `plan-call-below                command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[plan_name [get this expression-as_natural_language_string [elt arguments 0]]]]
												  [stringlist-concat `['call plan in layer below to ' ,plan_name]]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[plan_name [get this expression-as_natural_language_string [elt arguments 0]]]]
												  [stringlist-concat `['call plan to ' ,plan_name]]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[exists-expression [elt arguments 0]]]
												  [get this expression-as_natural_language_string exists-expression]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[partial_state [get this expression-as_natural_language_string [elt arguments 0]]]]
												  [stringlist-concat `['wait for ' ,partial_state]]]]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[if-condition    [get this expression-as_natural_language_string [elt arguments 0]]]
												      [if-true_branch  [get this expression-as_natural_language_string [elt arguments 1]]]
												      [if-false_branch [if [== arguments-length 3]
															   [get this expression-as_natural_language_string [elt arguments 2]]]]]
												  [stringlist-concat `['if '
														       ,if-condition
														       ', '
														       ,if-true_branch
														       [if if-false_branch
															   [stringlist-concat `['otherwise '
																		,if-false_branch]]
															 '']]]]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[assert-expression [get this expression-as_natural_language_string [elt arguments 0]]]]
												  [stringlist-concat `['assert that ' ,assert-expression]]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[variable-symbol [elt arguments 0]]]
												  `[? ,variable-symbol]]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[source_type     [get this expression-as_natural_language_string [elt arguments 0]]]
												      [source_key_type [get this expression-as_natural_language_string [elt arguments 1]]]
												      [source_key      [get this expression-as_natural_language_string [elt arguments 2]]]
												      [source_value    [get this expression-as_natural_language_string [elt arguments 3]]]
												      [key_type        [get this expression-as_natural_language_string [elt arguments 4]]]
												      [key             [get this expression-as_natural_language_string [elt arguments 5]]]
												      [value           [get this expression-as_natural_language_string [elt arguments 6]]]]
												  [get [new semantic_partial_state_property [get [get this mind] semantic_realm]
													    source_type
													    source_key_type
													    source_key
													    source_value
													    key_type
													    key
													    value]
												       as-declarative_natural_language_string]]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[source_type     [get this expression-as_natural_language_string [elt arguments 0]]]
												      [source_key_type [get this expression-as_natural_language_string [elt arguments 1]]]
												      [source_key      [get this expression-as_natural_language_string [elt arguments 2]]]
												      [source_value    [get this expression-as_natural_language_string [elt arguments 3]]]
												      [key_type        [get this expression-as_natural_language_string [elt arguments 4]]]
												      [key             [get this expression-as_natural_language_string [elt arguments 5]]]
												      [target_type     [get this expression-as_natural_language_string [elt arguments 6]]]
												      [target_key_type [get this expression-as_natural_language_string [elt arguments 7]]]
												      [target_key      [get this expression-as_natural_language_string [elt arguments 8]]]
												      [target_value    [get this expression-as_natural_language_string [elt arguments 9]]]]
												  [get [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
													    source_type
													    source_key_type
													    source_key
													    source_value
													    key_type
													    key
													    target_type
													    target_key_type
													    target_key
													    target_value]
												       as-declarative_natural_language_string]]]]
						[[eq `defplan                        command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  nil]]]
						[[eq `defcondition                   command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  nil]]]
						[[eq `defobject                      command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  nil]]]
						[t                                            `[error ,[flatten_constree expression]]]]]]]
	[t                            `[error punctuation-colon ,[flatten_constree expression]]]]]

[deftypefunk nonsemantic_plan get as-natural_language_string []
  [if [eq `uninitialized internal-natural_language_string]
      [= internal-natural_language_string [get this expression-as_natural_language_string expression]]]
  internal-natural_language_string]

[deftypefunk nonsemantic_plan get as-string []
  [get this as-natural_language_string]]

[deftypefunk nonsemantic_plan get as-graphviz_label []
  [string-concat '<' [get [get this unique_name] as-string] '>']]



[deftypefunk nonsemantic_plan execute expression-syntax_check [expression]
  [cond [[is-type `symbol expression] `[quote ,expression]]
	[[is-type `string expression] [let [[parse_result [shelter [string_pattern-as-conslist_pattern expression]]]]
					[if [is-type `bug parse_result]
					    [error bug_name                 `plan_syntax_error-could_not_parse_string_pattern
						   expression               expression
						   string_pattern_parse_bug parse_result]
					  expression]]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `eval
													 expression expression]
												[let [[eval-expression `[quote ,[elt arguments 0]]]]
												  `cannot_determine_syntax]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `quote
													 expression expression]
												[let [[quote-expression [elt arguments 0]]]
												  `[quote ,quote-expression]]]]
						[[or [eq `list                       command]
						     [eq `backquote-list             command]] [mapc [funk [argument]
													   [have this expression-syntax_check argument]]
												     arguments]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `print
													 expression expression]
												[let [[print-expression [elt arguments 0]]]
												  [have this expression-syntax_check print-expression]]]]
						[[eq `prog                           command] [let [[last_argument nil]]
												[mapc [funk [argument]
													    [= last_argument [have this expression-syntax_check argument]]]
												      arguments]
												last_argument]]
						[[eq `parog                          command] [prog [mapc [funk [argument]
														[have this expression-syntax_check argument]]
													  arguments]
												    nil]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-for-time
													 expression expression]
												[let [[time_to_wait [elt arguments 0]]]
												  [if [not [is-type `integer time_to_wait]]
												      [terminal_format standard-terminal '\nplan syntax warning: time_to_wait is not an integer (' time_to_wait ').']]
												  nil]]]
						[[eq `call-below                     command] [if [not [>= arguments-length 1]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `call-below
													 expression expression]
												[let [[action_name      [elt arguments 0]]
												      [action_arguments [cdr arguments]]]
												  [have this expression-syntax_check action_name]
												  [mapc [funk [action_argument]
													      [have this expression-syntax_check action_argument]]
													action_arguments]]]]
						[[eq `call                           command] [if [not [>= arguments-length 1]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `call
													 expression expression]
												[let [[action_name      [elt arguments 0]]
												      [action_arguments [cdr arguments]]]
												  [have this expression-syntax_check action_name]
												  [mapc [funk [action_argument]
													      [have this expression-syntax_check action_argument]]
													action_arguments]]]]
						[[eq `plan                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `plan
													 expression expression]
												[let [[plan_name [elt arguments 0]]]
												  [have this expression-syntax_check plan_name]]]]
						[[eq `plan-below                     command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `plan-below
													 expression expression]
												[let [[plan_name [elt arguments 0]]]
												  [have this expression-syntax_check plan_name]]]]
						[[eq `plan-call-below                command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `plan-call-below
													 expression expression]
												[let [[plan_name [elt arguments 0]]]
												  [have this expression-syntax_check plan_name]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `plan-call
													 expression expression]
												[let [[plan_name [elt arguments 0]]]
												  [have this expression-syntax_check plan_name]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `exists
													 expression expression]
												[let [[exists-expression [elt arguments 0]]]
												  [have this expression-syntax_check exists-expression]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-for
													 expression expression]
												`cannot_determine_syntax]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `if
													 expression expression]
												[let [[if-condition    [have this expression-syntax_check [elt arguments 0]]]
												      [if-true_branch  [have this expression-syntax_check [elt arguments 1]]]
												      [if-false_branch [if [== arguments-length 3]
															   [have this expression-syntax_check [elt arguments 2]]]]]
												  `cannot_determine_syntax]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `assert
													 expression expression]
												[let [[assert-expression [elt arguments 0]]]
												  [have this expression-syntax_check assert-expression]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `?
													 expression expression]
												[let [[variable-symbol `[quote ,[elt arguments 0]]]]
												  `cannot_determine_syntax]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `property
													 expression expression]
												[let [[source_type     [have this expression-syntax_check [elt arguments 0]]]
												      [source_key_type [have this expression-syntax_check [elt arguments 1]]]
												      [source_key      [have this expression-syntax_check [elt arguments 2]]]
												      [source_value    [have this expression-syntax_check [elt arguments 3]]]
												      [key_type        [have this expression-syntax_check [elt arguments 4]]]
												      [key             [have this expression-syntax_check [elt arguments 5]]]
												      [value           [have this expression-syntax_check [elt arguments 6]]]]
												  `cannot_determine_syntax]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `relationship
													 expression expression]
												[let [[source_type     [have this expression-syntax_check [elt arguments 0]]]
												      [source_key_type [have this expression-syntax_check [elt arguments 1]]]
												      [source_key      [have this expression-syntax_check [elt arguments 2]]]
												      [source_value    [have this expression-syntax_check [elt arguments 3]]]
												      [key_type        [have this expression-syntax_check [elt arguments 4]]]
												      [key             [have this expression-syntax_check [elt arguments 5]]]
												      [target_type     [have this expression-syntax_check [elt arguments 6]]]
												      [target_key_type [have this expression-syntax_check [elt arguments 7]]]
												      [target_key      [have this expression-syntax_check [elt arguments 8]]]
												      [target_value    [have this expression-syntax_check [elt arguments 9]]]]
												  `cannot_determine_syntax]]]
						[[eq `defplan                        command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  nil]]]
						[[eq `defcondition                   command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  nil]]]
						[[eq `defobject                      command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  nil]]]
						[t                                            [error bug_name   `nonsemantic_plan_syntax_error-invalid_command
												     command    command
												     expression expression]]]]]]
	[t                            [error bug_name   `nonsemantic_plan_syntax_error-bad_type
					     expression expression]]]]

[deftypefunk nonsemantic_plan execute syntax_check []
  [have this expression-syntax_check expression]]


[deftypefunk nonsemantic_plan execute check_exists [semantic_partial_state]
  [have [get this mental_layer] check_exists semantic_partial_state]]

[deftypefunk nonsemantic_plan execute imagine_check_exists [semantic_partial_state]
  [have [get this mental_layer] imagine_check_exists semantic_partial_state]]

[deftypefunk nonsemantic_plan execute wait_for [semantic_partial_state]
  [have [get this mental_layer] wait_for semantic_partial_state]]

[deftypefunk nonsemantic_plan execute assert [semantic_partial_state]
  [have [get this mental_layer] assert semantic_partial_state]]

[deftypefunk nonsemantic_plan execute imagine_asserting [semantic_partial_state]
  [have [get this mental_layer] imagine_assuring semantic_partial_state]]


[deftypefunk nonsemantic_plan execute __execute_funk_as_thought_in_semantic_planner [semantic_planner variable_frame funk args]
  `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.']
  [let [[result [shelter [let* [[semantic_knowledge_base_set [have semantic_planner lookup `semantic_knowledge_base_set]]
				[semantic_knowledge_bases    [get semantic_knowledge_base_set elements]]]
			   [if [null semantic_knowledge_bases]
			       [error funkname `semantic_planner-new_semantic_thought
				      bug_name `semantic_knowledge_bases-is-nil]]
			   
			   [let* [[execute_now-conditionlock   [new conditionlock]]
				  [execute_now                 nil]
				  [thought_fiber               [fiber [funk []
									    
									    [have execute_now-conditionlock lock]
									    [while [not execute_now]
									      [have execute_now-conditionlock wait]]
									    [have execute_now-conditionlock unlock]
									    
									    [cause-define cause-name [get this unique_name]]
									    [apply funk args]]
								      []]]
				  [semantic_thought            [let [[this [new semantic_thought [get semantic_planner semantic_realm]]]]
								 [set this fiber thought_fiber]
								 this]]]
			     
			     [let [[semantic_environment [new semantic_environment [get semantic_planner semantic_realm]]]]
			       [have [get this semantic_plan_object] add_default_frame_to_environment semantic_environment]
			       [mapc [funk [variable_name]
					   [let [[default_variable_value_set [semantic-lookup_set semantic_environment variable variable_name]]]
					     [mapc [funk [default_variable_value]
							 [semantic-remove semantic_environment variable variable_name default_variable_value]]
						   [if default_variable_value_set
						       [get default_variable_value_set elements]
						     nil]]]
					   [semantic-add semantic_environment variable variable_name [have variable_frame lookup variable_name]]]
				     [get variable_frame keys]]
			       [set semantic_thought environment semantic_environment]
			       
			       [mapc [funk [semantic_knowledge_base]
					   [have semantic_knowledge_base add_semantic_frame semantic_environment]
					   [have semantic_knowledge_base add_semantic_frame semantic_thought]]
				     semantic_knowledge_bases]
			       [semantic-add semantic_planner thought semantic_thought]
			       
			       [have [get thought_fiber cause_reg] define `cause-semantic_thought semantic_thought]
			       
			       `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (telling thought_fiber to execute now)']
			       
			       [have execute_now-conditionlock lock]
			       [=    execute_now t]
			       [have execute_now-conditionlock signal]
			       [have execute_now-conditionlock unlock]
			       
			       [let [[fiber_result [fiber-sheltered_join thought_fiber]]]
				 `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (joined thought_fiber)']
				 
				 [semantic-remove semantic_planner thought semantic_thought]
				 [mapc [funk [semantic_knowledge_base]
					     [have semantic_knowledge_base remove_semantic_frame semantic_environment]
					     [have semantic_knowledge_base remove_semantic_frame semantic_thought]]
				       semantic_knowledge_bases]
				 
				 fiber_result]]]]]]]
    [if [is-type `bug result]
	[terminal_format standard-terminal '\nnonsemantic_plan: returning bug ' result]]
    result]]


[deframe decision_point [frame] [possible_values]
  [new [initial-possible_values]
       [= possible_values initial-possible_values]]]


[defunk nonsemantic_plan-expression-unwrapped_compile [expression]
  [cond [[is-type `symbol expression] [eval `[funk [this]
						   [quote ,expression]]]]
	[[is-type `string expression] [eval `[funk [this]
						   [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
						     [have semantic_thought evaluate_string ,expression]]]]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `eval
													 expression expression]
												[let [[eval-expression `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [eval ,eval-expression]]]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `quote
													 expression expression]
												[let [[quote-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [quote ,quote-expression]
													       ]]]]]
						[[or [eq `list                       command]
						     [eq `backquote-list             command]] [eval `[funk [this]
													    [conslist @[mapcar [funk [argument]
																     `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
															       arguments]]]]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `print
													 expression expression]
												[let [[print-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-print-expression [funkall ,[nonsemantic_plan-expression-compile print-expression] this]]]
														 [terminal_format standard-terminal '\nplan printing expression: ' eval-print-expression]
														 eval-print-expression]]]]]]
						[[eq `prog                           command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan evaluating serial process.']
													   @[mapcar [funk [argument]
															  `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
														    arguments]]]]
						[[eq `parog                          command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan evaluating parallel process.']
													   [parog @[mapcar [funk [argument]
																 `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
															   arguments]]
													   nil]]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-for-time
													 expression expression]
												[let [[time_to_wait [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[time_to_wait ,time_to_wait]]
														 [dotimes [i [+ time_to_wait 1]]
														   `[terminal_format standard-terminal '\nplan waiting for time step ' i `/ time_to_wait '.']
														   [wait-for-trigger [get [get [get this mind] body] time_step_trigger]]]
														 ]]]]]]
						[[eq `call-below                     command] [if [not [>= arguments-length 1]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `call-below
													 expression expression]
												[let [[action_name      `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]
												      [action_arguments [mapcar [funk [action_argument]
																      `[funkall ,[nonsemantic_plan-expression-compile action_argument] this]]
																[cdr arguments]]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action_below ,action_name]]]
														 [if [null action]
														     [error bug_name    `nonsemantic_plan-call_below-no_such_action
															    action_name ,action_name]
														   [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
															 [have action wait_to_call @action_arguments]
															 ]]]]]]]]
						[[eq `call                           command] [if [not [>= arguments-length 1]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `call
													 expression expression]
												[let [[action_name      `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]
												      [action_arguments [mapcar [funk [action_argument]
																      `[funkall ,[nonsemantic_plan-expression-compile action_argument] this]]
																[cdr arguments]]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action ,action_name]]]
														 [if [null action]
														     [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
															    action_name ,action_name]
														   [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
															 [have action wait_to_call @action_arguments]
															 ]]]]]]]]
						[[eq `plan                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `plan
													 expression expression]
												[let [[plan_name `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer] lookup_semantic_plan_matches plan_name]]]
														       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] 'nonsemantic_plan: semantic_plan_matches = ' semantic_plan_matches]
														       [let [[semantic_plans [mapcar [funk [semantic_plan_match]
																			   [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
																				 [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
																				 [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
																			     [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
																			     [if [null match-semantic_plan_object]
																				 [error bug_name    `nonsemantic_plan-plan-no_such_plan
																					action_name semantic_plan_object-phenomenal_name]
																			       [let [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]]
																				 [let [[new_nonsemantic_plan [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]]
																				   [get new_nonsemantic_plan semantic_plan_object]]]]]]
																		     semantic_plan_matches]]]
															 [if semantic_plans
															     [car semantic_plans]
															   [error bug_name   could_not_find_matching_semantic_plans
																  funkname   `plan
																  expression expression]]]]]]]]]]]
						[[eq `plan-below                     command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `plan-below
													 expression expression]
												[let [[plan_name `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer_below] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer_below] lookup_semantic_plan_matches plan_name]]]
														       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] 'nonsemantic_plan: semantic_plan_matches = ' semantic_plan_matches]
														       [let [[semantic_plans [mapcar [funk [semantic_plan_match]
																			   [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
																				 [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
																				 [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
																			     [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
																			     [if [null semantic_plan_object]
																				 [error bug_name    `nonsemantic_plan-plan-no_such_plan
																					action_name semantic_plan_object-phenomenal_name]
																			       [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
																				 [let [[new_nonsemantic_plan [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]]
																				   [get new_nonsemantic_plan semantic_plan_object]]]]]]
																		     semantic_plan_matches]]]
															 [if semantic_plans
															     [car semantic_plans]
															   [error bug_name   could_not_find_matching_semantic_plans
																  funkname   `plan
																  expression expression]]]]]]]]]]]
						[[eq `plan-call-below                command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `plan-call-below
													 expression expression]
												[let [[plan_name `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer_below] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer_below] lookup_semantic_plan_matches plan_name]]]
														       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] 'nonsemantic_plan: semantic_plan_matches = ' semantic_plan_matches]
														       [if semantic_plan_matches
															   [let [[semantic_plan_match [car semantic_plan_matches]]]
															     [prog [= semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
																   [= variable_frame       [have semantic_plan_match lookup `variable_frame]]]]]]]
														 [terminal_format standard-terminal '\nfound plan with variable frame! ' variable_frame]
														 [if [null semantic_plan_object]
														     [error bug_name    `nonsemantic_plan-plan-no_such_plan
															    action_name semantic_plan_object-phenomenal_name]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
														     `[terminal_format standard-terminal '\nexecuting plan in layer below: "' [get semantic_plan_object-phenomenal_name as-string] '."']
														     [have nonsemantic_plan execute_as_thought_in_semantic_planner semantic_planner variable_frame]]]]]]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `plan-call
													 expression expression]
												[let [[plan_name `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer] lookup_semantic_plan_matches plan_name]]]
														       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] 'nonsemantic_plan: semantic_plan_matches = ' semantic_plan_matches]
														       [if semantic_plan_matches
															   [let [[semantic_plan_match [car semantic_plan_matches]]]
															     [prog [= semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
																   [= variable_frame       [have semantic_plan_match lookup `variable_frame]]]]]]]
														 [terminal_format standard-terminal '\nexecuting plan with variable frame: ' variable_frame]
														 [if [null semantic_plan_object]
														     [error bug_name    `nonsemantic_plan-plan_call-no_such_plan
															    action_name semantic_plan_object-phenomenal_name]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]
															 [semantic_planner [get [get [get this mental_layer] agency `plan] semantic_planner]]]
														     `[terminal_format standard-terminal '\nexecuting plan: "' [get semantic_plan_object-phenomenal_name as-string] '."']
														     [have nonsemantic_plan execute_as_thought_in_semantic_planner semantic_planner variable_frame]
														     ]]]]]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `exists
													 expression expression]
												[let [[exists-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-exists-expression [funkall ,[nonsemantic_plan-expression-compile exists-expression] this]]]
														 [have this check_exists eval-exists-expression]
														 ]]]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-for
													 expression expression]
												[let [[partial_state `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[partial_state ,partial_state]]
														 [terminal_format standard-terminal '\nplan waiting for: "' [get partial_state as-declarative_natural_language_string] '."']
														 [have this wait_for partial_state]]
													       ]]]]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `if
													 expression expression]
												[let [[if-condition    `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]
												      [if-true_branch  `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]
												      [if-false_branch [if [== arguments-length 3]
															   `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]]]
												  [eval `[funk [this]
													       [if ,if-condition
														   ,if-true_branch
														 ,if-false_branch]]]]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `assert
													 expression expression]
												[let [[assert-expression `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[assert-expression ,assert-expression]]
														 [if [not assert-expression]
														     [error bug_name    `assertion-failed
															    is_plan_bug t
															    description [conslist `assert [quote ,assert-expression]]]]]]]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `?
													 expression expression]
												[let [[variable-symbol `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
														 [terminal_format standard-terminal '\nplan looking up variable value, ' ,variable-symbol '.']
														 [have semantic_thought lookup_a_variable_value ,variable-symbol]
														 ]]]]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `property
													 expression expression]
												[let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												      [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]]
												      [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]]
												      [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 3]] this]]]
												      [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 4]] this]]]
												      [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 5]] this]]]
												      [value           `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 6]] this]]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,value]
													       ]]]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `relationship
													 expression expression]
												[let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												      [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]]
												      [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]]
												      [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 3]] this]]]
												      [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 4]] this]]]
												      [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 5]] this]]]
												      [target_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 6]] this]]]
												      [target_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 7]] this]]]
												      [target_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 8]] this]]]
												      [target_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 9]] this]]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,target_type
														    ,target_key_type
														    ,target_key
														    ,target_value]
													       ]]]]]
						[[eq `defplan                        command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  [eval `[funk [this]
													       [new nonsemantic_plan [get this mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]
													       ]]]]]
						[[eq `defcondition                   command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  [eval `[funk [this]
													       [new nonsemantic_condition [get this mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]]
													]]]]
						[[eq `defobject                      command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  [eval `[funk [this]
													       [new nonsemantic_object [get this mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]]
													]]]]
						[t                                            [error bug_name   `nonsemantic_plan_compile_error-invalid_command
												     command    command
												     expression expression
												     ]]]]]]
	[t                            [error bug_name        `nonsemantic_plan_compile_error-invalid_expression_type
					     expression-type [type expression]
					     expression      expression]]]]

[defunk nonsemantic_plan-expression-compile [expression]
  [eval `[funk [this]
	       [terminal_format standard-terminal '\nnonsemantic_plan executing compiled expression: ' [quote ,expression]]
	       [let [[result [shelter [funkall ,[nonsemantic_plan-expression-unwrapped_compile expression] this]]]]
		 [if [is-type `bug result]
		     [let [[bug result]]
		       [if [have [get bug frame] lookup `is_plan_bug]
			   bug
			 [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
			   [terminal_format standard-terminal '\nnonsemantic_plan-expression_encountered_bug: ' [quote ,expression]]
			   [error bug_name         `nonsemantic_plan-expression_encountered_bug
				  expression       [quote ,expression]
				  semantic_thought semantic_thought
				  subbug           bug]]]]
		   [prog [terminal_format standard-terminal '\nnonsemantic_plan done executing compiled expression: ' [quote ,expression]]
			 result]]]]]]


[deftypefunk nonsemantic_plan get __compiled_funk []
  [nonsemantic_plan-expression-compile expression]]

[deftypefunk nonsemantic_plan get compiled_funk []
  [if [null internal-compiled_funk]
      [= internal-compiled_funk [let [[result [shelter [get this __compiled_funk]]]]
				  [if [is-type `bug result]
				      [let [[bug result]]
					[error bug_name nonsemantic_plan-error_compiling_execute_funk
					       subbug   bug
					       this     this]]
				    result]]]]
  internal-compiled_funk]

[deftypefunk nonsemantic_plan execute eval []
  [funkall [get this compiled_funk] this]]

[deftypefunk nonsemantic_plan execute execute_as_thought_in_semantic_planner [semantic_planner variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: executing "' [get this name_expression] '" with ' variable_frame '.']
  [let [[result [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
		      [funk []
			    [have this eval]]
		      []]]]
    [terminal_format standard-terminal '\nnonsemantic_plan: done executing "' [get this name_expression] '".']
    result]]



[deftypefunk nonsemantic_plan execute lookup_action_below [action_name_expression]
  [have mental_layer lookup_action_below action_name_expression]]

[deftypefunk nonsemantic_plan execute lookup_action [action_name_expression]
  [have mental_layer lookup_action action_name_expression]]


[defunk nonsemantic_plan-expression-unwrapped_compile_imagine [expression]
  [cond [[is-type `symbol expression] [eval `[funk []
						   [quote ,expression]]]]
	[[is-type `string expression] [eval `[funk [this]
						   [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
						     [have semantic_thought evaluate_string ,expression]]]]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `eval
													 expression expression]
												[let [[eval-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-expression [quote ,eval-expression]]]
														 [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' eval_expression '.']
														 ]]]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `quote
													 expression expression]
												[let [[quote-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [quote ,quote-expression]
													       ]]]]]
						[[or [eq `list                       command]
						     [eq `backquote-list             command]] [eval `[funk [this]
													    [conslist @[mapcar [funk [argument]
																     `[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
															       arguments]]]]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `print
													 expression expression]
												[let [[print-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-print-expression [funkall ,[nonsemantic_plan-expression-compile_imagine print-expression] this]]]
														 [terminal_format standard-terminal '\nplan imagine printing expression: ' eval-print-expression]
														 eval-print-expression]]]]]]
						[[eq `prog                           command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan imagining serial process.']
													   @[mapcar [funk [argument]
															  `[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
														    arguments]]]]
						[[eq `parog                          command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan imagining parallel process.']
													   [parog @[mapcar [funk [argument]
																 `[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
															   arguments]]
													   nil]]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `wait-for-time
													 expression expression]
												[let [[time_to_wait [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[time_to_wait ,time_to_wait]]
														 'no imaginative effects'
														 ]]]]]]
						[[eq `call-below                     command] [if [not [>= arguments-length 1]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `call-below
													 expression expression]
												[let [[action_name      `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]
												      [action_arguments [mapcar [funk [action_argument]
																      `[funkall ,[nonsemantic_plan-expression-compile_imagine action_argument] this]]
																[cdr arguments]]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action_below ,action_name]]]
														 [if [null action]
														     [error bug_name    `nonsemantic_plan-call_below-no_such_action
															    action_name ,action_name]
														   [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
															 [have action imagine_waiting_to_call @action_arguments]
															 ]]]]]]]]
						[[eq `call                           command] [if [not [>= arguments-length 1]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `call
													 expression expression]
												[let [[action_name      `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]
												      [action_arguments [mapcar [funk [action_argument]
																      `[funkall ,[nonsemantic_plan-expression-compile_imagine action_argument] this]]
																[cdr arguments]]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action ,action_name]]]
														 [if [null action]
														     [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															    action_description ,action_name]
														   [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
															 [have action imagine_waiting_to_call @action_arguments]
															 ]]]]]]]]
						[[eq `plan                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `plan
													 expression expression]
												[let* [[plan_name `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer] lookup_semantic_plan_matches plan_name]]]
														       [if semantic_plan_matches
															   [let [[semantic_plan_match [car semantic_plan_matches]]]
															     [= semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
															     [= variable_frame       [have semantic_plan_match lookup `variable_frame]]]]]]
														 [terminal_format standard-terminal '\nimagination found plan with variable frame! ' variable_frame]
														 [if [null semantic_plan_object]
														     [error bug_name    `nonsemantic_plan-plan-no_such_plan
															    action_name semantic_plan_object-phenomenal_name]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
														     [let [[new_nonsemantic_plan [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]]
														       [get new_nonsemantic_plan semantic_plan_object]]]]]]]]]]
						[[eq `plan-below                     command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `plan-below
													 expression expression]
												[let* [[plan_name `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer_below] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer_below] lookup_semantic_plan_matches plan_name]]]
														       [if semantic_plan_matches
															   [let [[semantic_plan_match [car semantic_plan_matches]]]
															     [= semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
															     [= variable_frame       [have semantic_plan_match lookup `variable_frame]]]]]]
														 [terminal_format standard-terminal '\nimagination found plan with variable frame! ' variable_frame]
														 [if [null semantic_plan_object]
														     [error bug_name    `nonsemantic_plan-plan-no_such_plan
															    action_name semantic_plan_object-phenomenal_name]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
														     [let [[new_nonsemantic_plan [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]]
														       [get new_nonsemantic_plan semantic_plan_object]]]]]]]]]]
						[[eq `plan-call-below                command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `plan-call-below
													 expression expression]
												[let* [[plan_name `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer_below] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer_below] lookup_semantic_plan_matches plan_name]]]
														       [if semantic_plan_matches
															   [let [[semantic_plan_match [car semantic_plan_matches]]]
															     [= semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
															     [= variable_frame       [have semantic_plan_match lookup `variable_frame]]]]]]
														 [terminal_format standard-terminal '\nimagining executing plan in layer below with variable frame: ' variable_frame]
														 [if [null semantic_plan_object]
														     [error bug_name    `nonsemantic_plan-plan_call-no_such_plan
															    action_name semantic_plan_object-phenomenal_name]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]
															 [semantic_planner [get [get [get this mental_layer_below] agency `plan] semantic_planner]]]
														     [terminal_format standard-terminal '\nimagining executing plan in layer below: "' [get semantic_plan_object-phenomenal_name as-string] '."']
														     [have nonsemantic_plan imagine_as_thought_in_semantic_planner semantic_planner variable_frame]
														     ]]]]]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `plan-call
													 expression expression]
												[let* [[plan_name `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_matches [have [get this mental_layer] lookup_semantic_plan_matches plan_name]]]
														       [if semantic_plan_matches
															   [let [[semantic_plan_match [car semantic_plan_matches]]]
															     [= semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
															     [= variable_frame       [have semantic_plan_match lookup `variable_frame]]]]]]
														 [terminal_format standard-terminal '\nimagining executing plan with variable frame: ' variable_frame]
														 [if [null semantic_plan_object]
														     [error bug_name    `nonsemantic_plan-plan_call-no_such_plan
															    action_name semantic_plan_object-phenomenal_name]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]
															 [semantic_planner [get [get [get this mental_layer] agency `plan] semantic_planner]]]
														     [terminal_format standard-terminal '\nimagining executing plan: "' [get semantic_plan_object-phenomenal_name as-string] '."']
														     [have nonsemantic_plan imagine_as_thought_in_semantic_planner semantic_planner variable_frame]
														     ]]]]]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `exists
													 expression expression]
												[let [[exists-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-exists-expression [funkall ,[nonsemantic_plan-expression-compile_imagine exists-expression] this]]]
														 [have this imagine_check_exists eval-exists-expression]
														 ]]]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `wait-for
													 expression expression]
												[let [[partial_state `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[partial_state ,partial_state]]
														 [terminal_format standard-terminal '\nplan imagining waiting for: "'
																  [get partial_state as-declarative_natural_language_string] '."']
														 [have this wait_for partial_state]
														 ]
													       ]]]]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `if
													 expression expression]
												[let [[if-condition    `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]
												      [if-true_branch  `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]
												      [if-false_branch [if [== arguments-length 3]
															   `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]]]
												  [eval `[funk [this]
													       [if ,if-condition
														   ,if-true_branch
														 ,if-false_branch]]]]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `assert
													 expression expression]
												[let [[assert-expression `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[assert-expression ,assert-expression]]
														 [if [not assert-expression]
														     [error bug_name    `assertion-failed
															    is_plan_bug t
															    description [conslist `imagine_asserting [quote ,assert-expression]]]]]]]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `?
													 expression expression]
												[let [[variable-symbol `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
														 [terminal_format standard-terminal '\nplan imagining looking up variable value, ' ,variable-symbol '.']
														 [have semantic_thought lookup_a_variable_value ,variable-symbol]
														 ]]]]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `property
													 expression expression]
												[let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												      [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]]
												      [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]]
												      [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 3]] this]]]
												      [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 4]] this]]]
												      [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 5]] this]]]
												      [value           `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 6]] this]]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,value]
													       ]]]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  [error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
													 funkname   `relationship
													 expression expression]
												[let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												      [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]]
												      [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]]
												      [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 3]] this]]]
												      [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 4]] this]]]
												      [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 5]] this]]]
												      [target_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 6]] this]]]
												      [target_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 7]] this]]]
												      [target_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 8]] this]]]
												      [target_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 9]] this]]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,target_type
														    ,target_key_type
														    ,target_key
														    ,target_value]
													       ]]]]]
						[[eq `defplan                        command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  [eval `[funk [this]
													       ]]]]]
						[[eq `defcondition                   command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  [eval `[funk [this]
													       ]]]]]
						[[eq `defobject                      command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  [eval `[funk [this]
													       ]]]]]
						[t                                            [error bug_name `nonsemantic_plan_compile_imagine_error]]]]]]
	[t                          [error bug_name `nonsemantic_plan_compile_imagine_error]]]]

[defunk nonsemantic_plan-expression-compile_imagine [expression]
  [eval `[funk [this]
	       [let [[result [shelter [funkall ,[nonsemantic_plan-expression-unwrapped_compile_imagine expression] this]]]]
		 [if [is-type `bug result]
		     [let [[bug result]]
		       [if [have [get bug frame] lookup `is_plan_bug]
			   result
			 [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
			   [terminal_format standard-terminal '\nnonsemantic_plan-expression_encountered_bug: ' [quote ,expression]]
			   [error bug_name         `nonsemantic_plan-expression_encountered_bug
				  expression       [quote ,expression]
				  semantic_thought semantic_thought
				  subbug           bug]]]]
		   result]]]]]

[deftypefunk nonsemantic_plan get __compiled_imagine_funk []
  [nonsemantic_plan-expression-compile_imagine expression]]

[deftypefunk nonsemantic_plan get compiled_imagine_funk []
  [if [null internal-compiled_imagine_funk]
      [= internal-compiled_imagine_funk [let [[result [shelter [get this __compiled_imagine_funk]]]]
					  [if [is-type `bug result]
					      [let [[bug result]]
						[error bug_name `nonsemantic_plan-error_compiling_imagine_funk
						       subbug   bug
						       this     this]]
					    result]]]]
  internal-compiled_imagine_funk]

[deftypefunk nonsemantic_plan execute imagine_eval []
  [funkall [get this compiled_imagine_funk] this]]

[deftypefunk nonsemantic_plan execute imagine_as_thought_in_semantic_planner [semantic_planner variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: imagining executing "' [get this name_expression] '" with ' variable_frame '.']
  [let [[result [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
		      [funk []
			    [have this imagine_eval]]
		      []]]]
    [terminal_format standard-terminal '\nnonsemantic_plan: done imagining executing "' [get this name_expression] '".']
    result]]




[defunk semantic_plan_operator_activation-new_with_resource_dependency [semantic_realm resource_activation_dependency]
  [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]
	[semantic_counterfactual_transframe [new semantic_counterfactual_transframe semantic_realm]]]
    [set semantic_counterfactual_transframe resource_activation_dependency resource_activation_dependency]
    [set semantic_plan_operator_activation counterfactual_transframe semantic_counterfactual_transframe]
    semantic_plan_operator_activation]]

[defunk nonsemantic_plan-expression-semantic_compile [expression semantic_realm]
  [cond [[is-type `symbol expression] [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
					expression]]
	[[is-type `string expression] expression]
	[[is-type `cons expression] [let [[command   [car expression]]
					  [arguments [cdr expression]]]
				      [let [[arguments-length [length arguments]]]
					[cond [[eq `eval                           command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `eval
												       expression expression]
											      [let [[eval-expression [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `eval]]]]
					      [[eq `quote                          command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `quote
												       expression expression]
											      [let [[quote-expression [elt arguments 0]]]
												nil]]]
					      [[or [eq `list                       command]
						   [eq `backquote-list             command]] [mapcar [funk [argument]
													   [nonsemantic_plan-expression-semantic_compile argument semantic_realm]]
												     arguments]]
					      [[eq `print                          command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `print
												       expression expression]
											      [let [[print-expression [elt arguments 0]]]
												[nonsemantic_plan-expression-semantic_compile print-expression semantic_realm]]]]
					      [[eq `prog                           command] [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]]
											      semantic_plan_operator_activation]]
					      [[eq `parog                          command] [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]]
											      semantic_plan_operator_activation]]
					      [[eq `wait-for-time                  command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `wait-for-time
												       expression expression]
											      [let [[time_to_wait [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-for-time]]]]
					      [[eq `call-below                     command] [if [not [>= arguments-length 1]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `call-below
												       expression expression]
											      [let [[action_name      [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]
												    [action_arguments [mapcar [funk [action_argument]
																    [nonsemantic_plan-expression-semantic_compile action_argument semantic_realm]]
															      [cdr arguments]]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `call-below]]]]
					      [[eq `call                           command] [if [not [>= arguments-length 1]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `call
												       expression expression]
											      [let [[action_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]
												    [action_arguments [mapcar [funk [action_argument]
																    [nonsemantic_plan-expression-semantic_compile action_argument semantic_realm]]
															      [cdr arguments]]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `call]]]]
					      [[eq `plan                           command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan
												       expression expression]
											      [let [[plan_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]]
												nil]]]
					      [[eq `plan-below                     command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan-below
												       expression expression]
											      [let [[plan_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]]
												nil]]]
					      [[eq `plan-call-below                command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan-call-below
												       expression expression]
											      [let [[plan_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]]
												nil]]]
					      [[eq `plan-call                      command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan-call
												       expression expression]
											      [let [[plan_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]]
												nil]]]
					      [[eq `exists                         command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `exists
												       expression expression]
											      [let [[exists-expression [elt arguments 0]]]
												[nonsemantic_plan-expression-semantic_compile exists-expression semantic_realm]]]]
					      [[eq `wait-for                       command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `wait-for
												       expression expression]
											      [let [[partial_state [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-for]]]]
					      [[eq `if                             command] [if [not [or [== arguments-length 2]
													 [== arguments-length 3]]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `if
												       expression expression]
											      nil]]
					      [[eq `assert                         command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `assert
												       expression expression]
											      [let [[assert-expression [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `assert]]]]
					      [[eq `?                              command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `?
												       expression expression]
											      [let [[variable-symbol [elt arguments 0]]]
												`[? ,variable-symbol]]]]
					      [[eq `property                       command] [if [not [== 7 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `property
												       expression expression]
											      [let [[source_type     [elt arguments 0]]
												    [source_key_type [elt arguments 1]]
												    [source_key      [elt arguments 2]]
												    [source_value    [elt arguments 3]]
												    [key_type        [elt arguments 4]]
												    [key             [elt arguments 5]]
												    [value           [elt arguments 6]]]
												nil]]]
					      [[eq `relationship                   command] [if [not [== 10 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `relationship
												       expression expression]
											      [let [[source_type     [elt arguments 0]]
												    [source_key_type [elt arguments 1]]
												    [source_key      [elt arguments 2]]
												    [source_value    [elt arguments 3]]
												    [key_type        [elt arguments 4]]
												    [key             [elt arguments 5]]
												    [target_type     [elt arguments 6]]
												    [target_key_type [elt arguments 7]]
												    [target_key      [elt arguments 8]]
												    [target_value    [elt arguments 9]]]
												nil]]]
					      [[eq `defplan                        command] [if [not [>= arguments-length 1]]
												`[error punctuation-colon ,[flatten_constree expression]]
											      [let [[name                       [elt arguments 0]]
												    [matches                    nil]
												    [frame_variable_definitions nil]]
												[let [[argument_iter                   [cdr arguments]]
												      [done_reading_optional_arguments nil]]
												  [while [not done_reading_optional_arguments]
												    [let [[optional_argument_key [car argument_iter]]]
												      [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			[= matches       [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			[= frame_variable_definitions [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [t                                    [= done_reading_optional_arguments t]]]]
												    ]]
												nil]]]
					      [[eq `defcondition                   command] [if [not [>= arguments-length 1]]
												`[error punctuation-colon ,[flatten_constree expression]]
											      [let [[name                       [elt arguments 0]]
												    [matches                    nil]
												    [frame_variable_definitions nil]]
												[let [[argument_iter                   [cdr arguments]]
												      [done_reading_optional_arguments nil]]
												  [while [not done_reading_optional_arguments]
												    [let [[optional_argument_key [car argument_iter]]]
												      [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			[= matches       [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			[= frame_variable_definitions [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [t                                    [= done_reading_optional_arguments t]]]]
												    ]]
												nil]]]
					      [[eq `defobject                      command] [if [not [>= arguments-length 1]]
												`[error punctuation-colon ,[flatten_constree expression]]
											      [let [[name                       [elt arguments 0]]
												    [matches                    nil]
												    [frame_variable_definitions nil]]
												[let [[argument_iter                   [cdr arguments]]
												      [done_reading_optional_arguments nil]]
												  [while [not done_reading_optional_arguments]
												    [let [[optional_argument_key [car argument_iter]]]
												      [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			[= matches       [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			[= frame_variable_definitions [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [t                                    [= done_reading_optional_arguments t]]]]
												    ]]
												nil]]]
					      [t                                            [error bug_name `nonsemantic_plan_compile_error]]]]]]
	[t                          [error bug_name `nonsemantic_plan_compile_error]]]]

[deftypefunk nonsemantic_plan get __semantic_plan_object []
  [let [[semantic_plan_object [new semantic_plan_object [get [get this mind] semantic_realm] [get this unique_name] this]]
	[start_plan_operator  [nonsemantic_plan-expression-semantic_compile expression [get [get this mind] semantic_realm]]]]
    [set semantic_plan_object start_plan_operator start_plan_operator]
    [mapc [funk [variable_definition]
		[cond [[is-type `symbol variable_definition] [semantic-add semantic_plan_object default_variable variable_definition nil]]
		      [[is-type `cons   variable_definition] [if [== [length variable_definition] 2]
								 [let [[variable   [first  variable_definition]]
								       [definition [second variable_definition]]]
								   [semantic-add semantic_plan_object default_variable variable definition]]
							       [error bug_name   `invalid_plan_variable_definition
								      expression variable_definition]]]
		      [t                                     [error bug_name `invalid_plan_variable_definitions
								    expression expression]]]]
	  [get this variables]]
    semantic_plan_object]]

[deftypefunk nonsemantic_plan get semantic_plan_object []
  [if [null internal-semantic_plan_object]
      [= internal-semantic_plan_object [get this __semantic_plan_object]]]
  internal-semantic_plan_object]

