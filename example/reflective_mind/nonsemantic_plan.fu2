'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[defunk name_expression-as-string [this]
  [cond [[is-type `string this] this]
	[t                      [get this as-string]]]]

[defunk name_expression-as-symbol [this]
  [get [name_expression-as-string this] as-symbol]]

[defunk nonsemantic_plan-unique_name_from_name_expression [name_expression]
  [name_expression-as-symbol name_expression]]



'semantic_plan_operator_activation'

[defunk semantic_plan_operator_activation-new_with_resource_dependency [semantic_realm resource_activation_dependency]
  [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]
	[semantic_counterfactual_transframe [new semantic_counterfactual_transframe semantic_realm]]]
    [set semantic_counterfactual_transframe resource_activation_dependency resource_activation_dependency]
    [set semantic_plan_operator_activation counterfactual_transframe semantic_counterfactual_transframe]
    semantic_plan_operator_activation]]



[deframe nonsemantic_plan_truth_value [frame] [value
					       [partial_state_existence_dependency_set [new set]]]
  [new [initial-value]
       [= value initial-value]]]

[deftypefunk nonsemantic_plan_truth_value execute add_partial_state_existence_dependency [partial_state]
  [have partial_state_existence_dependency_set add partial_state]]


'value_dependency'

[deframe value_dependency [frame] [multiple_possible_values
				   value]
  [new [initial-multiple_possible_values
	initial-value]
       [= multiple_possible_values initial-multiple_possible_values]
       [= value                    initial-value]]]


'multiple_possible_values'

[deframe multiple_possible_values [frame] [[mutate_mutex                 [new mutex]]
					   [good_value_set               [new set]]
					   [bug_value_ptypehash          [new ptypehash]]
					   [dependencies_value_ptypehash [new ptypehash]]]
  [new [values]
       [mapc [funk [value]
		   [have good_value_set add value]]
	     values]]]

[deftypefunk multiple_possible_values get good_value_count []
  [get good_value_set key_count]]

[deftypefunk multiple_possible_values get good_values []
  [get good_value_set elements]]

[deftypefunk multiple_possible_values get good_value []
  [have mutate_mutex lock]
  [let [[good_values [get good_value_set elements]]]
    [if good_values
	[let [[result [car good_values]]]
	  [have mutate_mutex unlock]
	  result]
      [prog [have mutate_mutex unlock]
	    [error bug_name `multiple_possible_values-get-good_value-no_good_values_exist
		   this     this]]]]]

[deftypefunk multiple_possible_values execute add_value_bug [value bug]
  [have mutate_mutex lock]
  [if [get good_value_set contains value]
      [have good_value_set remove value]]
  [let [[current_value_bugs [have bug_value_ptypehash lookup value]]]
    [have bug_value_ptypehash add value [cons bug current_value_bugs]]
    [have mutate_mutex unlock]]]

[deftypefunk multiple_possible_values execute add_value [value]
  [have mutate_mutex lock]
  [have good_value_set add value]
  [have mutate_mutex unlock]]

[deftypefunk multiple_possible_values execute add_value_with_dependency [value dependency]
  [have mutate_mutex lock]
  [have good_value_set               add value]
  [have dependencies_value_ptypehash add value [cons dependency [have dependencies_value_ptypehash lookup value]]]
  [have mutate_mutex unlock]]

[deftypefunk multiple_possible_values get value_dependencies [value]
  [have dependencies_value_ptypehash lookup value]]


'nonsemantic_plan'

[deframe nonsemantic_plan [frame] [mental_layer
				   name_expression
				   name_patterns
				   variables
				   expression
				   [internal-default_variable_frame  nil]
				   [internal-unique_name             nil]
				   [internal-semantic_plan_object    nil]
				   [internal-compiled_funk           nil]
				   [internal-compiled_imagine_funk   nil]
				   [internal-natural_language_string nil]
				   [internal-constant_variable_frame nil]]
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [= mental_layer    initial-mental_layer]
       [= name_expression initial-name_expression]
       [= name_patterns   initial-name_patterns]
       [= variables       initial-variables]
       [= expression      initial-expression]]]

[deframe nonsemantic_condition [nonsemantic_plan] []
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [construct nonsemantic_plan
		  initial-mental_layer
		  initial-name_expression
		  initial-name_patterns
		  initial-variables
		  initial-expression]]]

[deframe nonsemantic_object [nonsemantic_plan] []
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [construct nonsemantic_plan
		  initial-mental_layer
		  initial-name_expression
		  initial-name_patterns
		  initial-variables
		  initial-expression]]]

[deftypefunk nonsemantic_plan get mental_layer_below []
  [get mental_layer mental_layer_below]]

[deftypefunk nonsemantic_plan get __default_variable_frame []
  [let [[default_variable_frame [new frame]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first variable_definition]]
		      [variable_value [second variable_definition]]]
		  [have default_variable_frame add variable_name variable_value]]]
	  variables]
    default_variable_frame]]

[deftypefunk nonsemantic_plan get default_variable_frame []
  [if [null internal-default_variable_frame]
      [= internal-default_variable_frame [get this __default_variable_frame]]]
  internal-default_variable_frame]

[deftypefunk nonsemantic_plan get new_copy_given_variable_frame [variable_frame]
  [let [[new_name_expressions nil]
	[new_variable_frame   [get variable_frame new_copy]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first  variable_definition]]
		      [variable_value [second variable_definition]]]
		  [if [get variable_frame contains variable_name]
		      [have new_variable_frame add variable_name [have variable_frame lookup variable_name]]
		    [have new_variable_frame add variable_name variable_value]]]]
	  variables]
    [let [[new_variables [mapcar [funk [variable_name]
				       `[,variable_name ,[have new_variable_frame lookup variable_name]]]
				 [get new_variable_frame keys]]]]
      [mapc [funk [name_pattern]
		  [let [[used_variable_frame [new frame]]]
		    [let [[new_name_expression [get name_pattern pattern_evaluation
						    [funk [variable_name]
							  [have used_variable_frame add variable_name t]
							  [if [get new_variable_frame contains variable_name]
							      [have new_variable_frame lookup variable_name]
							    [error bug_name     new_copy_given_variable_frame-could_not_find_variable_match_in_default_frame
								   this         this
								   name_pattern name_pattern]]]]]]
		      [let [[used_all_nondefault_variables t]]
			[mapc [funk [nondefault_variable_name]
				    [if [not [have used_variable_frame lookup nondefault_variable_name]]
					[= used_all_nondefault_variables nil]]]
			      [get variable_frame keys]]
			[if used_all_nondefault_variables
			    [= new_name_expressions [cons new_name_expression new_name_expressions]]]]]]]
	    name_patterns]
      [if [null new_name_expressions]
	  [error bug_name `nonsemantic_plan-new_copy_given_variable_frame-could_not_generate_new_name
		 this     this
		 variable_frame variable_frame]
	[let [[new_name_expression [car [reverse new_name_expressions]]]]
	  [new nonsemantic_plan
	       mental_layer
	       new_name_expression
	       name_patterns
	       new_variables
	       expression]]]]]]

[deftypefunk nonsemantic_plan get unique_name []
  [if [null internal-unique_name]
      [= internal-unique_name [nonsemantic_plan-unique_name_from_name_expression [get this name_expression]]]]
  internal-unique_name]

[deftypefunk nonsemantic_plan get mind []
  [get mental_layer mind]]

[deftypefunk nonsemantic_plan get name_pattern_match_pairs [expression]
  [let [[name_pattern_matches nil]]
    [mapc [funk [name_pattern]
		[let [[matches [string_pattern-match name_pattern expression]]]
		  [mapc [funk [match]
			      [= name_pattern_matches [cons [cons name_pattern match]
							    name_pattern_matches]]]
			matches]]]
	  name_patterns]
    name_pattern_matches]]

[deftypefunk nonsemantic_plan get sorted_name_pattern_matches [expression]
  [let* [[name_pattern_match_pairs [get this name_pattern_match_pairs expression]]]
    [mapcar [funk [name_pattern_match_pair]
		  [let [[match [cdr name_pattern_match_pair]]]
		    match]]
	    [mapcar [funk [pair]
			  [car pair]]
		    [have [mapcar [funk [name_pattern_match_pair]
					[let [[match [cdr name_pattern_match_pair]]]
					  [cons name_pattern_match_pair [length [get match keys]]]]]
				  name_pattern_match_pairs]
			  sort [funk [x y]
				     [< [cdr x] [cdr y]]]]]]]]


[deftypefunk nonsemantic_plan get expression-as_natural_language_string [expression]
  [let [[compile_option_frame [frame mode `natural_language]]]
    [get this expression-compile expression compile_option_frame]]]

[deftypefunk nonsemantic_plan get as-natural_language_string []
  [if [null internal-natural_language_string]
      [= internal-natural_language_string [get this expression-as_natural_language_string expression]]]
  internal-natural_language_string]

[deftypefunk nonsemantic_plan get as-string []
  [get this as-natural_language_string]]

[deftypefunk nonsemantic_plan get as-graphviz_label []
  [string-concat '<' [get [get this unique_name] as-string] '>']]

[deftypefunk nonsemantic_plan execute expression-syntax_check [expression]
  [let [[compile_option_frame [frame mode `syntax_check]]]
    [get this expression-compile expression compile_option_frame]]]


[deftypefunk nonsemantic_plan execute syntax_check []
  [have this expression-syntax_check expression]]


[deftypefunk nonsemantic_plan execute check_exists [semantic_partial_state]
  [let* [[truth_value                  [have [get this mental_layer] check_exists semantic_partial_state]]
	 [nonsemantic_plan_truth_value [new nonsemantic_plan_truth_value truth_value]]]
    [have nonsemantic_plan_truth_value add_partial_state_existence_dependency semantic_partial_state]
    nonsemantic_plan_truth_value]]

[deftypefunk nonsemantic_plan execute imagine_check_exists [semantic_partial_state]
  [let [[found_event [have [get this mental_layer] imagine_check_exists semantic_partial_state]]]
    [cond [[null found_event]                              [prog [terminal_format standard-terminal '\nnonsemantic_plan: did not find existence event, so using current actual physical knowledge.']
								 [let* [[simple_truth_value [have [get this mental_layer] check_exists semantic_partial_state]]
								        [nonsemantic_plan_truth_value [new nonsemantic_plan_truth_value simple_truth_value]]]
								   [have nonsemantic_plan_truth_value add_partial_state_existence_dependency semantic_partial_state]
								   nonsemantic_plan_truth_value]]]
	  [[is-type `multiple_possible_values found_event] [let [[multiple_possible_values        found_event]
								 [result_multiple_possible_values [new multiple_possible_values nil]]]
							     [mapc [funk [one_found_event]
									 [let* [[simple_truth_value           [not [get one_found_event is_negative_knowledge]]]
										[nonsemantic_plan_truth_value [new nonsemantic_plan_truth_value simple_truth_value]]]
									   [have nonsemantic_plan_truth_value add_partial_state_existence_dependency semantic_partial_state]
									   [have result_multiple_possible_values add_value_with_dependency nonsemantic_plan_truth_value [new value_dependency one_found_event multiple_possible_values]]]]
								   [get multiple_possible_values good_values]]
							     result_multiple_possible_values]]
	  [t                                               [let* [[simple_truth_value           [not [get found_event is_negative_knowledge]]]
								  [nonsemantic_plan_truth_value [new nonsemantic_plan_truth_value simple_truth_value]]]
							     [have nonsemantic_plan_truth_value add_partial_state_existence_dependency semantic_partial_state]
							     nonsemantic_plan_truth_value]]]]]

[deftypefunk nonsemantic_plan execute wait_for [semantic_partial_state]
  [have [get this mental_layer] wait_for semantic_partial_state]]

[deftypefunk nonsemantic_plan execute __execute_funk_as_thought_in_semantic_planner [semantic_planner variable_frame funk args]
  `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.']
  [let [[result [shelter [let* [[semantic_knowledge_base_set [have semantic_planner lookup `semantic_knowledge_base_set]]
				[semantic_knowledge_bases    [get semantic_knowledge_base_set elements]]]
			   [if [null semantic_knowledge_bases]
			       [error funkname `semantic_planner-new_semantic_thought
				      bug_name `semantic_knowledge_bases-is-nil]]
			   
			   [let* [[execute_now-conditionlock   [new conditionlock]]
				  [execute_now                 nil]
				  [thought_fiber               [fiber [funk []
									    
									    [have execute_now-conditionlock lock]
									    [while [not execute_now]
									      [have execute_now-conditionlock wait]]
									    [have execute_now-conditionlock unlock]
									    
									    [cause-define cause-name [get this unique_name]]
									    [apply funk args]]
								      []]]
				  [semantic_thought            [let [[this [new semantic_thought [get semantic_planner semantic_realm]]]]
								 [set this fiber thought_fiber]
								 this]]]
			     
			     [let [[semantic_environment [new semantic_environment [get semantic_planner semantic_realm]]]]
			       [have [get this semantic_plan_object] add_default_frame_to_environment semantic_environment]
			       [mapc [funk [variable_name]
					   [let [[default_variable_value_set [semantic-lookup_set semantic_environment variable variable_name]]]
					     [mapc [funk [default_variable_value]
							 [semantic-remove semantic_environment variable variable_name default_variable_value]]
						   [if default_variable_value_set
						       [get default_variable_value_set elements]
						     nil]]]
					   [semantic-add semantic_environment variable variable_name [have variable_frame lookup variable_name]]]
				     [get variable_frame keys]]
			       [set semantic_thought environment semantic_environment]
			       
			       [mapc [funk [semantic_knowledge_base]
					   [have semantic_knowledge_base add_semantic_frame semantic_environment]
					   [have semantic_knowledge_base add_semantic_frame semantic_thought]]
				     semantic_knowledge_bases]
			       [semantic-add semantic_planner thought semantic_thought]
			       
			       [have [get thought_fiber cause_reg] define `cause-semantic_thought semantic_thought]
			       
			       `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (telling thought_fiber to execute now)']
			       
			       [have execute_now-conditionlock lock]
			       [=    execute_now t]
			       [have execute_now-conditionlock signal]
			       [have execute_now-conditionlock unlock]
			       
			       [let [[fiber_result [fiber-sheltered_join thought_fiber]]]
				 `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (joined thought_fiber)']
				 
				 [semantic-remove semantic_planner thought semantic_thought]
				 [mapc [funk [semantic_knowledge_base]
					     [have semantic_knowledge_base remove_semantic_frame semantic_environment]
					     [have semantic_knowledge_base remove_semantic_frame semantic_thought]]
				       semantic_knowledge_bases]
				 
				 fiber_result]]]]]]]
    [if [is-type `bug result]
	[terminal_format standard-terminal '\nnonsemantic_plan: returning bug ' result]]
    result]]


[deftypefunk nonsemantic_plan execute lookup_action_below [action_name_expression]
  [have mental_layer lookup_action_below action_name_expression]]

[deftypefunk nonsemantic_plan execute lookup_action [action_name_expression]
  [have mental_layer lookup_action action_name_expression]]





[deftypefunk nonsemantic_plan get expression-compile-symbol [expression compile_option_frame]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog ]]
	  [[eq compile-mode `execute]          [eval `[funk [this]
							    [quote ,expression]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [this]
							    [quote ,expression]]]]
	  [[eq compile-mode `natural_language] [get expression as-string]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[deftypefunk nonsemantic_plan get expression-compile-string [expression compile_option_frame]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [let [[parse_result [shelter [string_pattern-as-conslist_pattern expression]]]]
						 [if [is-type `bug parse_result]
						     [error bug_name                 `plan_syntax_error-could_not_parse_string_pattern
							    expression               expression
							    string_pattern_parse_bug parse_result]]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [have semantic_thought evaluate_string ,expression]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [have semantic_thought evaluate_string ,expression]]]]]
	  [[eq compile-mode `natural_language] expression]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[deftypefunk nonsemantic_plan get expression-compile-multiple_possible_values [expression compile_option_frame]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [value]
							   [get nonsemantic_plan expression-compile value compile_option_frame]]
						     [get expression good_values]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
							      [prog @[mapcar [funk [value]
										   `[let [[result [shelter [funkall ,[get nonsemantic_plan expression-compile value compile_option_frame] nonsemantic_plan]]]]
										      [if [is-type `bug result]
											  [let [[bug result]]
											    [if [have [get bug frame] lookup `is_plan_bug]
												[bug bug]
											      [have result_multiple_possible_values add_value_with_dependency result [new value_dependency [quote ,value] [quote ,expression]]]]]]]]
									     [get expression good_values]]]
							      result_multiple_possible_values]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
							      [prog @[mapcar [funk [value]
										   `[let [[result [shelter [funkall ,[get nonsemantic_plan expression-compile value compile_option_frame] nonsemantic_plan]]]]
										      [if [is-type `bug result]
											  [let [[bug result]]
											    [if [have [get bug frame] lookup `is_plan_bug]
												[bug bug]
											      [have result_multiple_possible_values add_value_with_dependency result [new value_dependency [quote ,value] [quote ,expression]]]]]]]]
									     [get expression good_values]]]
							      result_multiple_possible_values results]]]]
	  [[eq compile-mode `natural_language] [string-concat '(' [stringlist-intersperse [mapcar [funk [value]
													[get nonsemantic_plan expression-compile value compile_option_frame]]
												  [get expression good_values]]
											  ', or '] ')']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[globalize nonsemantic_plan-command_frame [new frame]]

[deframe nonsemantic_plan_command [frame] [name
					   arguments
					   body
					   arguments_contain_rest
					   minimum_argument_count
					   maximum_argument_count
					   compiled_funk]
  [new [initial-name
	initial-arguments
	initial-body]
       [= name      initial-name]
       [= arguments initial-arguments]
       [= body      initial-body]
       [mapc [funk [argument]
		   [if [eq argument `:rest]
		       [= arguments_contain_rest t]]]
	     arguments]
       [if arguments_contain_rest
	   [prog [= minimum_argument_count [- [length arguments] 2]]
		 [= maximum_argument_count nil]]
	 [prog [= minimum_argument_count [length arguments]]
	       [= maximum_argument_count minimum_argument_count]]]
       [= compiled_funk [eval `[funk [nonsemantic_plan compile_option_frame arguments]
				     [apply [funk ,`[nonsemantic_plan compile_option_frame @arguments]
						  @body]
					    `[,nonsemantic_plan ,compile_option_frame @arguments]]]]]
       ]]

[deftypefunk nonsemantic_plan_command execute compile [nonsemantic_plan compile_option_frame arguments]
  [let [[result [shelter [let [[arguments-length [length arguments]]]
			   [if [or [< arguments-length minimum_argument_count]
				   [and [not [null maximum_argument_count]]
					[> arguments-length maximum_argument_count]]]
			       [error bug_name                      `nonsemantic_plan_compile-wrong_number_of_arguments
				      minimum_argument_count        minimum_argument_count
				      maximum_argument_count        maximum_argument_count
				      nonsemantic_plan_command-name name
				      arguments                     arguments
				      compile_option_frame          compile_option_frame]
			     [apply compiled_funk `[,nonsemantic_plan ,compile_option_frame ,arguments]]]]]]]
    [if [is-type `bug result]
	[let [[bug result]]
	  [error bug_name         `nonsemantic_plan_command-error_compiling_command
		 subbug           bug
		 this             this
		 nonsemantic_plan nonsemantic_plan
		 arguments        arguments]]
      result]]]


[defmetro defplancommand [name arguments :rest body]
  [terminal_format standard-terminal '\n' `[defplancommand ,name ,arguments]]
  [have nonsemantic_plan-command_frame add name [new nonsemantic_plan_command
						     name
						     arguments
						     body]]
  nil]

[defplancommand eval [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[eval ,expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog ]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    ,expression]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[expression [quote ,expression]]]
							      [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' expression '.']
							      ]]]]
	  [[eq compile-mode `natural_language] 'evaluate funk expression']
	  [[eq compile-mode `semantic]         [semantic_plan_operator_activation-new_with_resource_dependency [get [get nonsemantic_plan mind] semantic_realm] `eval]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand quote [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[quote ,expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog ]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [quote ,expression]
							    ]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [quote ,quote-expression]
							    ]]]
	  [[eq compile-mode `natural_language] [get expression as-string]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand list [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[list @expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expression]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'a list of '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [let [[separator [if [== index 0]
													       ''
													     [if [== index [- expressions-length 1]]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [mapcar [funk [expression]
							     [get nonsemantic_plan expression-compile expression compile_option_frame]]
						       expressions]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand backquote-list [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[backquote-list @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expression]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'a list of '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [let [[separator [if [== index 0]
													       ''
													     [if [== index [- expressions-length 1]]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [mapcar [funk [expression]
							     [get nonsemantic_plan expression-compile expression compile_option_frame]]
						       expressions]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand print [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[print expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile expression compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[eval-expression [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
							      [terminal_format standard-terminal '\nplan printing expression: ' eval-expression]
							      eval-expression]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[eval-expression [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
							      [terminal_format standard-terminal '\nimagined plan printing expression: ' eval-expression]
							      eval-expression]]]]
	  [[eq compile-mode `natural_language] [string-concat 'print ' [get nonsemantic_plan expression-compile expression compile_option_frame]]] 
	  [[eq compile-mode `semantic]         [get nonsemantic_plan expression-compile expression compile_option_frame]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand prog [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[prog @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating serial process.']
							    @[mapcar [funk [expression]
									   `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
								     expressions]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating serial process.']
							    [let* [[index            0]
								   [expression_funks [conslist @[mapcar [funk [expression]
													      [eval `[funk [nonsemantic_plan]
															   [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]]
													expressions]]]
								   [imagine_time_array [new array [length expression_funks]]]]
							      [let [[expression_funk_iter expression_funks]
								    [prog_value           nil]]
								[while expression_funk_iter
								  [let [[expression_funk [car expression_funk_iter]]]
								    [set imagine_time_array elt index cause-imagine_time]
								    [let [[result [shelter [funkall expression_funk nonsemantic_plan]]]]
								      [if [is-type `bug result]
									  [let [[bug result]]
									    [if [not [have [get bug frame] lookup `is_plan_bug]]
										[bug bug]
									      [if [eq [have [get bug frame] lookup `bug_name] `assertion-failed]
										  [let* [[assertion_failed_bug                   bug]
											 [nonsemantic_plan_truth_value           [have [get assertion_failed_bug frame] lookup `nonsemantic_plan_truth_value]]
											 [partial_state_existence_dependency_set [get nonsemantic_plan_truth_value partial_state_existence_dependency_set]]]
										    [have cause-imagine_potential_effect_partial_state_set_mutex lock]
										    [= cause-imagine_potential_effect_partial_state_set [get cause-imagine_potential_effect_partial_state_set union partial_state_existence_dependency_set]]
										    [have cause-imagine_potential_effect_partial_state_set_mutex unlock]
										    [terminal_format standard-terminal
												     '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan assertion-failed at index=' index ' in prog for truth value:'
												     '\n  ' nonsemantic_plan_truth_value]
										    
										    [if [== index 0]
											[bug bug]
										      [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
											[let [[partial_state_assertion_failure_set [have [get semantic_thought imagine_frame] lookup `partial_state_assertion_failure_set]]]
											  [if [null partial_state_assertion_failure_set]
											      [= partial_state_assertion_failure_set partial_state_existence_dependency_set]
											    [= partial_state_assertion_failure_set [get partial_state_assertion_failure_set union partial_state_existence_dependency_set]]]
											  [have [get semantic_thought imagine_frame] add `partial_state_assertion_failure_set partial_state_assertion_failure_set]]
											
											[let [[scan_backwards_index    1]
											      [fixed_assertion_failure nil]]
											  
											  [while [not fixed_assertion_failure]
											    
											    [terminal_format standard-terminal
													     '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan scanning backwards to try to learn from assertion-failed.'
													     '\n  index=' index ' in prog (scan_backwards_index=' scan_backwards_index ').']
											    
											    'scan backwards undoing resource activations to add partial_state dependencies to concept_version_spaces of one of them if possible.'
											    
											    [= cause-imagine_time [get imagine_time_array elt [- index scan_backwards_index]]]
											    
											    [let [[possible_remove_events [get cause-imagine_semantic_event_tree events_overlapping_range cause-imagine_time [new semantic_time `after]]]]
											      [if [is-type `list possible_remove_events]
												  [= possible_remove_events [get possible_remove_events cons_cells]]]
											      [mapc [funk [possible_remove_event]
													  [if [get cause-imagine_semantic_event_tree contains possible_remove_event]
													      [if [> [get possible_remove_event absolute_start_time] cause-imagine_time]
														  [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: removing event from cause-imagine_semantic_event_tree.']
															[have cause-imagine_semantic_event_tree                                       remove                possible_remove_event]
															[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: removing event from cause-imagine_semantic_event_tree.  (success!)']
															[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: removing event from counterfactual_knowledge_base.']
															[have [get [get nonsemantic_plan mental_layer] counterfactual_knowledge_base] remove_semantic_frame possible_remove_event]
															[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: removing event from counterfactual_knowledge_base.  (success!)']]]]]
												    possible_remove_events]]
											    
											    [let [[scan_backwards_expression_funk_iter [restn expression_funks [- index scan_backwards_index]]]]
											      [while scan_backwards_expression_funk_iter
												[let [[scan_backwards_expression_funk [car scan_backwards_expression_funk_iter]]]
												  [let [[result [funkall scan_backwards_expression_funk nonsemantic_plan]]]
												    [if [is-type `bug result]
													[let [[bug result]]
													  [if [eq [have [get bug frame] lookup `bug_name] `assertion-failed]
													      [prog [= scan_backwards_index [+ scan_backwards_index 1]]
														    [if [> scan_backwards_index index]
															[bug bug]]
														    [= scan_backwards_expression_funk_iter nil]]]]]]]
												[if [eq scan_backwards_expression_funk_iter expression_funk_iter]
												    [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: fixed assertion failure!']
													  [= fixed_assertion_failure             t]
													  [= scan_backwards_expression_funk_iter nil]]
												  [if scan_backwards_expression_funk_iter
												      [= scan_backwards_expression_funk_iter [cdr scan_backwards_expression_funk_iter]]]]]]]]]]]
										[bug bug]]]]
									[= prog_value result]]]]
								  [if expression_funk_iter
								      [prog [= index                [+ index 1]]
									    [= expression_funk_iter [cdr expression_funk_iter]]]]]
								prog_value]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'do the following in serial: '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [= index [+ index 1]]
											  [let [[separator [if [== index 1]
													       ''
													     [if [== index expressions-length]
														 ', and finally '
													       ', ']]]]
											    [string-concat separator
													   '(' [get index as-string] ') '
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand parog [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[parog @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating parallel process.']
							    [parog @[mapcar [funk [expression]
										  `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									    expressions]]
							    nil]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating parallel process.']
							    [parog @[mapcar [funk [expression]
										  `[with-new-cause [cause-define cause-imagine_time                                     cause-imagine_time]
												   [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
												   [cause-define cause-imagine_potential_effect_partial_state_set_mutex [new mutex]]
												   [cause-define cause-imagine_potential_effect_partial_state_set       [new set]]
												   [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
									    expressions]]
							    nil]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'do the following at the same time: '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [= index [+ index 1]]
											  [let [[separator [if [== index 1]
													       ''
													     [if [== index expressions-length]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   '(' [get index as-string] ') '
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand wait-for-time [time_to_wait]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[wait-for-time ,time_to_wait]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [if [not [is-type `integer time_to_wait]]
						   [error bug_name     `nonsemantic_plan-wait_for_time-time_must_be_integer
							  time_to_wait time_to_wait]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[time_to_wait ,time_to_wait]
								  [time_step    [get [get nonsemantic_plan mind] time_step]]]
							      [dotimes [i [+ time_to_wait 1]]
								[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan waiting for time step ' i `/ time_to_wait '.']
								[= time_step [have [get nonsemantic_plan mind] wait_for_time_step [+ time_step 1]]]]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[time_to_wait ,time_to_wait]]
							      [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan imagining waiting for ' time_to_wait 'time steps.']
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat 'wait for ' [get time_to_wait as-string] ' physical world steps']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand call-below [action_name :rest action_arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[call-below ,action_name @action_arguments]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile action_name compile_option_frame]
						     [mapc [funk [action_argument]
								 [get nonsemantic_plan expression-compile action_argument compile_option_frame]]
							   action_arguments]]]
	  [[eq compile-mode `execute]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action_below ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-call_below-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
									[have action wait_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `imagine]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    [cdr arguments]]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action_below ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-call_below-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
									[have action imagine_waiting_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'activate "' [get nonsemantic_plan expression-compile action_name compile_option_frame] '" resource in layer below']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand call [action_name :rest action_arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[call ,action_name @action_arguments]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile action_name compile_option_frame]
						     [mapc [funk [action_argument]
								 [get nonsemantic_plan expression-compile action_argument compile_option_frame]]
							   action_arguments]]]
	  [[eq compile-mode `execute]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
									[have action wait_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `imagine]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan imagining waiting to call: "' [get action as-string] '."']
									[have action imagine_waiting_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'activate "' [get nonsemantic_plan expression-compile action_name compile_option_frame] '" resource in this layer']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan [plan_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan ,plan_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan_name compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null match-semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value new_semantic_plan_object]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `imagine]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null match-semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan   [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value new_semantic_plan_object]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'a plan in this layer to ' [get nonsemantic_plan expression-compile plan_name compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan-below [plan_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan-below ,plan_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan_name compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value new_semantic_plan_object]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan-below
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `imagine]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]]
									    semantic_plan_matches]
								      [mapc [funk [semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value new_semantic_plan_object]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan-below
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'a plan in the layer below to ' [get nonsemantic_plan expression-compile plan_name compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan-call [plan]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan-call ,plan]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[plan [funkall ,[get nonsemantic_plan expression-compile plan compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `semantic_plan_object     plan] [let* [[semantic_plan_object plan]
														     [nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
														[terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
														[have nonsemantic_plan execute_as_thought [frame]]]]
								    [[is-type `multiple_possible_values plan] [let* [[multiple_possible_values        plan]
														     [semantic_plan_objects           [get multiple_possible_values good_values]]
														     [result_multiple_possible_values [new multiple_possible_values nil]]]
														[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call ' [length semantic_plan_objects] ' possible plans.']
														[let [[index 0]]
														  [mapc [funk [semantic_plan_object]
															      [= index [+ index 1]]
															      [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call possible plan '
																	       index '/' [length semantic_plan_objects] '.']
															      [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
																[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to execute plan: "' [get nonsemantic_plan as-string] '"']
																[let [[result [shelter [have nonsemantic_plan execute_as_thought [frame]]]]]
																  [if [is-type `bug result]
																      [let [[bug result]]
																	[if [not [have [get bug frame] lookup `is_plan_bug]]
																	    [bug bug]
																	  [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: found bug executing plan: '
																				 '\n  ' bug]
																		[have multiple_possible_values add_value_bug semantic_plan_object bug]]]]
																    [have result_multiple_possible_values add_value_with_dependency result [new value_dependency semantic_plan_object multiple_possible_values]]]]]]
															semantic_plan_objects]]
														[if [!= [get result_multiple_possible_values good_value_count] 0]
														    result_multiple_possible_values
														  [error bug_name         `nonsemantic_plan-plan_call-no_possible_results
															 is_plan_bug      t
															 nonsemantic_plan nonsemantic_plan
															 plan             plan]]]]
								    [t                                        [error bug_name `nonsemantic_plan-plan_call-invalid_argument_type
														     correct_type `[or `semantic_plan_object multiple_possible_values]
														     actual_type  [type plan]
														     plan         plan]]]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[plan [funkall ,[get nonsemantic_plan expression-compile plan compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `semantic_plan_object     plan] [let* [[semantic_plan_object plan]
														     [nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
														[terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
														[have nonsemantic_plan imagine_as_thought [frame]]]]
								    [[is-type `multiple_possible_values plan] [let* [[multiple_possible_values        plan]
														     [semantic_plan_objects           [get multiple_possible_values good_values]]
														     [result_multiple_possible_values [new multiple_possible_values nil]]]
														[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call ' [length semantic_plan_objects] ' possible plans.']
														[let [[index 0]]
														  [mapc [funk [semantic_plan_object]
															      [= index [+ index 1]]
															      [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call possible plan '
																	       index '/' [length semantic_plan_objects] '.']
															      [let [[nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
																[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to execute plan: "' [get nonsemantic_plan as-string] '"']
																[let [[result [shelter [have nonsemantic_plan imagine_as_thought [frame]]]]]
																  [if [is-type `bug result]
																      [let [[bug result]]
																	[if [not [have [get bug frame] lookup `is_plan_bug]]
																	    [bug bug]
																	  [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: found bug executing plan: '
																				 '\n  ' bug]
																		[have multiple_possible_values add_value_bug semantic_plan_object bug]]]]
																    [have result_multiple_possible_values add_value_with_dependency result [new value_dependency semantic_plan_object multiple_possible_values]]]]]]
															semantic_plan_objects]]
														[if [!= [get result_multiple_possible_values good_value_count] 0]
														    result_multiple_possible_results
														  [error bug_name         `nonsemantic_plan-plan_call-no_possible_results
															 is_plan_bug      t
															 nonsemantic_plan nonsemantic_plan
															 plan             plan]]]]
								    [t                                        [error bug_name `nonsemantic_plan-plan_call-invalid_argument_type
														     correct_type `[or `semantic_plan_object multiple_possible_values]
														     actual_type  [type plan]
														     plan         plan]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'call ' [get nonsemantic_plan expression-compile plan compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand exists [partial_state]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[exists ,partial_state]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile partial_state compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[partial_state [funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
							      [have nonsemantic_plan check_exists partial_state]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[partial_state [funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
							      [have nonsemantic_plan imagine_check_exists partial_state]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat [get nonsemantic_plan expression-compile partial_state compile_option_frame] ' exists']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand wait-for [partial_state]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[wait-for ,partial_state]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile partial_state compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[partial_state-eval `[funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[partial_state ,partial_state-eval]]
								[terminal_format standard-terminal '\nplan waiting for: "' [get partial_state as-declarative_natural_language_string] '."']
								[have nonsemantic_plan wait_for partial_state]]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[partial_state-eval `[funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[partial_state ,partial_state-eval]]
								[terminal_format standard-terminal '\nplan imagining waiting for: "' [get partial_state as-declarative_natural_language_string] '."  (not yet implemented)']
								`[have nonsemantic_plan wait_for partial_state]]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat 'wait for ' [get nonsemantic_plan expression-compile partial_state compile_option_frame] ' to exist']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand if [condition true_expression :rest false_expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[if ,condition ,true_expression @false_expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile condition       compile_option_frame]
						     [get nonsemantic_plan expression-compile true_expression compile_option_frame]
						     [mapc [funk [false_expression]
								 [get nonsemantic_plan expression-compile false_expression compile_option_frame]]
							   false_expressions]]]
	  [[eq compile-mode `execute]          [let [[condition-eval         `[funkall ,[get nonsemantic_plan expression-compile condition       compile_option_frame] nonsemantic_plan]]
						     [true_expression-eval   `[funkall ,[get nonsemantic_plan expression-compile true_expression compile_option_frame] nonsemantic_plan]]
						     [false_expressions-eval [mapcar [funk [false_expression]
											   `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]
										     false_expressions]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[condition ,condition-eval]]
								[if [not [is-type `nonsemantic_plan_truth_value condition]]
								    [error bug_name        `nonsemantic_plan-if-truth_value_must_be_of_type_nonsemantic_plan_truth_value
									   condition       condition
									   quote-condition [quote ,condition]]
								  [if [get condition value]
								      ,true_expression-eval
								    @false_expressions-eval]]]]]]]
	  [[eq compile-mode `imagine]          [let [[condition-eval         `[funkall ,[get nonsemantic_plan expression-compile condition       compile_option_frame] nonsemantic_plan]]
						     [true_expression-eval   `[funkall ,[get nonsemantic_plan expression-compile true_expression compile_option_frame] nonsemantic_plan]]
						     [false_expressions-eval [mapcar [funk [false_expression]
											   `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]
										     false_expressions]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[condition ,condition-eval]]
								[cond [[is-type `nonsemantic_plan_truth_value condition] [if [get condition value]
															     ,true_expression-eval
															   @false_expressions-eval]]
								      [[is-type `multiple_possible_values     condition] [let [[multiple_possible_values        condition]
															       [result_multiple_possible_values [new multiple_possible_values nil]]]
															   [mapc [funk [one_condition]
																       [if one_condition
																	   [let [[true_result [shelter ,true_expression-eval]]]
																	     [if [is-type `bug true_result]
																		 [let [[bug true_result]]
																		   [if [not [have [get bug frame] lookup `is_plan_bug]]
																		       [bug bug]
																		     [have multiple_possible_values add_value_bug one_condition bug]]]
																	       [have result_multiple_possible_values add_value_with_dependency true_result [new value_dependency one_condition multiple_possible_values]]]]
																	 [let [[false_result [shelter @false_expressions-eval]]]
																	   [if [is-type `bug false_result]
																	       [let [[bug false_result]]
																		 [if [not [have [get bug frame] lookup `is_plan_bug]]
																		     [bug bug]
																		   [have multiple_possible_values add_value_bug one_condition bug]]]
																	     [have result_multiple_possible_values add_value_with_dependency false_result [new value_dependency one_condition multiple_possible_values]]]]]]
																 [get multiple_possible_values good_values]]
															   [if [== [get result_multiple_possible_values good_value_count] 0]
															       [error bug_name    `if-no_possible_good_results
																      is_plan_bug t
																      expression `[if ,condition ,true_expression @false_expressions]]
															     result_multiple_possible_values]]]
								      [t                                                 [error bug_name        `nonsemantic_plan-if-truth_value_must_be_of_type_nonsemantic_plan_truth_value
																condition       condition
																quote-condition [quote ,condition]]]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'if ' [get nonsemantic_plan expression-compile condition       compile_option_frame]
							      ', '  [get nonsemantic_plan expression-compile true_expression compile_option_frame]
							      [if false_expressions
								  [string-concat ', otherwise '
										 [stringlist-concat [let [[false_expressions-length [length false_expressions]]
													  [index                    0]]
												      [mapcar [funk [false_expression]
														    [= index [+ index 1]]
														    [let [[separator [if [== index 1]
																	 ''
																       [if [== index false_expressions-length]
																	   ', and '
																	 ', ']]]]
														      [string-concat separator
																     [get nonsemantic_plan expression-compile false_expression compile_option_frame]]]]
													      false_expressions]]]]
								'']]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand assert [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[assert ,expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile expression compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[expression-eval `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[expression ,expression-eval]]
								[if [not [is-type `nonsemantic_plan_truth_value expression]]
								    [error bug_name         `nonsemantic_plan-assert-truth_value_must_be_of_type_nonsemantic_plan_truth_value
									   expression       expression
									   quote-expression [quote ,expression]]
								  [if [not [get expression value]]
								      [error bug_name                     `assertion-failed
									     nonsemantic_plan_truth_value expression
									     is_plan_bug                  t
									     description                  [conslist `assert [quote ,expression]]]]]]]]]]
	  [[eq compile-mode `imagine]          [let [[expression-eval `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[expression ,expression-eval]]
								[cond [[is-type `nonsemantic_plan_truth_value expression] [if [not [get expression value]]
															      [error bug_name                     `assertion-failed
																     nonsemantic_plan_truth_value expression
																     is_plan_bug                  t
																     plan_expression              [quote ,expression]
																     description                  [conslist `assert [quote ,expression]]]]]
								      [[is-type `multiple_possible_values     expression] [let* [[multiple_possible_values        expression]
																 [expressions                     [get multiple_possible_values good_values]]
																 [result_multiple_possible_values [new multiple_possible_values nil]]]
															    [mapc [funk [one_expression]
																	[if [get one_expression value]
																	    [have result_multiple_possible_values add_value_with_dependency nil one_expression multiple_possible_values]
																	  [let [[assertion_bug [shelter [error bug_name                     `assertion-failed
																					       nonsemantic_plan_truth_value one_expression
																					       is_plan_bug                  t
																					       plan_expression              [quote ,expression]
																					       description                  [conslist `assert [quote ,expression]]]]]]
																	    [have expression add_value_bug one_expression assertion_bug]]]]
																  expressions]
															    [if [== [get result_multiple_possible_values good_value_count] 0]
																[error bug_name                     `assertion-failed
																       nonsemantic_plan_truth_value expression
																       is_plan_bug                  t
																       plan_expression              [quote ,expression]
																       description                  [conslist `assert [quote ,expression]]]
															      result_multiple_possible_values]]]
								      [t                                                  [error bug_name         `nonsemantic_plan-assert-truth_value_must_be_of_type_nonsemantic_plan_truth_value
																 expression       expression
																 quote-expression [quote ,expression]]]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'assert that ' [get nonsemantic_plan expression-compile expression compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand ? [variable_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[? ,variable_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [if [not [is-type `symbol variable_name]]
						   [error bug_name      `nonsemantic_plan-?-variable_name_must_be_symbol
							  variable_name variable_name]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
							      [have semantic_thought lookup_a_variable_value [quote ,variable_name]]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
							      [have semantic_thought lookup_a_variable_value [quote ,variable_name]]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat '[? ' [get variable_name as-string] ']']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand property [source_type
			  source_key_type
			  source_key
			  source_value
			  key_type
			  key
			  value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[property ,source_type
											,source_key_type
											,source_key
											,source_value
											,key_type
											,key
											,value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile source_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile source_value    compile_option_frame]
						     [get nonsemantic_plan expression-compile key_type        compile_option_frame]
						     [get nonsemantic_plan expression-compile key             compile_option_frame]
						     [get nonsemantic_plan expression-compile value           compile_option_frame]]]
	  [[eq compile-mode `execute]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [value-eval           `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile value           compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,value-eval]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [value-eval           `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile value           compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,value-eval]
							      ]]]]
	  [[eq compile-mode `natural_language] [let [[source_type-eval     [get nonsemantic_plan expression-compile source_type     compile_option_frame]]
						     [source_key_type-eval [get nonsemantic_plan expression-compile source_key_type compile_option_frame]]
						     [source_key-eval      [get nonsemantic_plan expression-compile source_key      compile_option_frame]]
						     [source_value-eval    [get nonsemantic_plan expression-compile source_value    compile_option_frame]]
						     [key_type-eval        [get nonsemantic_plan expression-compile key_type        compile_option_frame]]
						     [key-eval             [get nonsemantic_plan expression-compile key             compile_option_frame]]
						     [value-eval           [get nonsemantic_plan expression-compile value           compile_option_frame]]]
						 [get [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
							   source_type-eval0
							   source_key_type-eval
							   source_key-eval
							   source_value-eval
							   key_type-eval
							   key-eval
							   value-eval] as-natural_language_string]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand relationship [source_type
			      source_key_type
			      source_key
			      source_value
			      key_type
			      key
			      target_type
			      target_key_type
			      target_key
			      target_value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[relationship ,source_type
											    ,source_key_type
											    ,source_key
											    ,source_value
											    ,key_type
											    ,key
											    ,target_type
											    ,target_key_type
											    ,target_key
											    ,target_value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile source_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile source_value    compile_option_frame]
						     [get nonsemantic_plan expression-compile key_type        compile_option_frame]
						     [get nonsemantic_plan expression-compile key             compile_option_frame]
						     [get nonsemantic_plan expression-compile target_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile target_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile target_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile target_value    compile_option_frame]]]
	  [[eq compile-mode `execute]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [target_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_type     compile_option_frame] nonsemantic_plan]]]
						     [target_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key_type compile_option_frame] nonsemantic_plan]]]
						     [target_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key      compile_option_frame] nonsemantic_plan]]]
						     [target_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_value    compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,target_type-eval
								   ,target_key_type-eval
								   ,target_key-eval
								   ,target_value-eval]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [target_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_type     compile_option_frame] nonsemantic_plan]]]
						     [target_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key_type compile_option_frame] nonsemantic_plan]]]
						     [target_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key      compile_option_frame] nonsemantic_plan]]]
						     [target_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_value    compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,target_type-eval
								   ,target_key_type-eval
								   ,target_key-eval
								   ,target_value-eval]
							      ]]]]
	  [[eq compile-mode `natural_language] [let [[source_type-eval     [get nonsemantic_plan expression-compile source_type     compile_option_frame]]
						     [source_key_type-eval [get nonsemantic_plan expression-compile source_key_type compile_option_frame]]
						     [source_key-eval      [get nonsemantic_plan expression-compile source_key      compile_option_frame]]
						     [source_value-eval    [get nonsemantic_plan expression-compile source_value    compile_option_frame]]
						     [key_type-eval        [get nonsemantic_plan expression-compile key_type        compile_option_frame]]
						     [key-eval             [get nonsemantic_plan expression-compile key             compile_option_frame]]
						     [target_type-eval     [get nonsemantic_plan expression-compile target_type     compile_option_frame]]
						     [target_key_type-eval [get nonsemantic_plan expression-compile target_key_type compile_option_frame]]
						     [target_key-eval      [get nonsemantic_plan expression-compile target_key      compile_option_frame]]
						     [target_value-eval    [get nonsemantic_plan expression-compile target_value    compile_option_frame]]]
						 [get [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
							   source_type-eval
							   source_key_type-eval
							   source_key-eval
							   source_value-eval
							   key_type-eval
							   key-eval
							   target_type-eval
							   target_key_type-eval
							   target_key-eval
							   target_value-eval] as-natural_language_string]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand defplan [name_expression :rest arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[defplan ,name_expression @arguments]]
  [let [[name_patterns        nil]
	[variable_definitions nil]
	[plan_body_expression nil]]
    [let [[argument_iter                   arguments]
	  [done_reading_optional_arguments nil]]
      [while [not done_reading_optional_arguments]
	[let [[optional_argument_key [car argument_iter]]]
	  [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
							    [= name_patterns [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
							    [= variable_definitions [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[t                                    [= done_reading_optional_arguments t]]]]]
      [if [== [length argument_iter] 1]
	  [= plan_body_expression [car argument_iter]]
	[= plan_body_expression `[prog @argument_iter]]]]
    [let [[compile-mode [have compile_option_frame lookup `mode]]]
      [cond [[eq compile-mode `syntax_check]     [prog ]]
	    [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							      [terminal_format standard-terminal '\n' [conslist `defplan [quote ,name_expression]]]
							      [let* [[new_nonsemantic_plan [new nonsemantic_plan [get nonsemantic_plan mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]]
								     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
								[have [get nonsemantic_plan mental_layer] add_semantic_plan new_semantic_plan_object]]]]]
	    [[eq compile-mode `imagine]          [prog ]]
	    [[eq compile-mode `natural_language] [string-concat 'define a plan to ' [if [is-type `string name_expression]
											name_expression
										      [get name_expression as-string]]]]
	    [[eq compile-mode `semantic]         [prog ]]
	    [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
							compile-mode compile-mode]]]]]]



[deftypefunk nonsemantic_plan get expression-compile-cons [expression compile_option_frame]
  [let [[command   [car expression]]
	[arguments [cdr expression]]]
    [let [[nonsemantic_plan_command [have nonsemantic_plan-command_frame lookup command]]]
      [if [not [null nonsemantic_plan_command]]
	  [have nonsemantic_plan_command compile this compile_option_frame arguments]
	[error bug_name   `nonsemantic_plan_compile_error-invalid_command
	       expression expression
	       command    command]]]]]

[deftypefunk nonsemantic_plan get expression-compile [expression compile_option_frame]
  [let [[unwrapped_compile_result [cond [[is-type `symbol expression]                   [get this expression-compile-symbol                   expression compile_option_frame]]
					[[is-type `string expression]                   [get this expression-compile-string                   expression compile_option_frame]]
					[[is-type `cons   expression]                   [get this expression-compile-cons                     expression compile_option_frame]]
					[[is-type `multiple_possible_values expression] [get this expression-compile-multiple_possible_values expression compile_option_frame]]
					[t                                              [error bug_name        `nonsemantic_plan_compile_error-invalid_expression_type
											       expression-type [type expression]
											       expression      expression]]]]]
    [let [[compile-mode [have compile_option_frame lookup `mode]]]
      [cond [[eq compile-mode `syntax_check]     unwrapped_compile_result]
	    [[eq compile-mode `execute]          [eval `[funk [this]
							      [terminal_format standard-terminal '\nnonsemantic_plan executing compiled expression: ' [quote ,expression]]
							      [let [[result [shelter [funkall ,unwrapped_compile_result this]]]]
								[if [is-type `bug result]
								    [let [[bug result]]
								      [if [have [get bug frame] lookup `is_plan_bug]
									  [bug bug]
									[let [[semantic_thought [cause-lookup cause-semantic_thought]]]
									  [terminal_format standard-terminal '\nnonsemantic_plan-expression_encountered_bug: ' [quote ,expression]]
									  [error bug_name         `nonsemantic_plan-expression_encountered_bug
										 expression       [quote ,expression]
										 semantic_thought semantic_thought
										 subbug           bug]]]]
								  [prog [terminal_format standard-terminal '\nnonsemantic_plan done executing compiled expression: ' [quote ,expression]]
									result]]]]]]
	    [[eq compile-mode `imagine]          [eval `[funk [this]
							      [terminal_format standard-terminal '\nnonsemantic_plan imagining executing compiled expression: ' [quote ,expression]]
							      [let [[result [shelter [funkall ,unwrapped_compile_result this]]]]
								[if [is-type `bug result]
								    [let [[bug result]]
								      [if [have [get bug frame] lookup `is_plan_bug]
									  [bug bug]
									[let [[semantic_thought [cause-lookup cause-semantic_thought]]]
									  [terminal_format standard-terminal '\nnonsemantic_plan-expression_encountered_bug: ' [quote ,expression]]
									  [error bug_name         `nonsemantic_plan-expression_encountered_bug
										 expression       [quote ,expression]
										 semantic_thought semantic_thought
										 subbug           bug]]]]
								  [prog [terminal_format standard-terminal '\nnonsemantic_plan done imagining executing compiled expression: ' [quote ,expression]]
									result]]]]]]
	    [[eq compile-mode `natural_language] unwrapped_compile_result]
	    [[eq compile-mode `semantic]         unwrapped_compile_result]
	    [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
							compile-mode compile-mode]]]]]]

[deftypefunk nonsemantic_plan get __compiled_funk []
  [let [[compile_option_frame [frame mode `execute]]]
    [get this expression-compile expression compile_option_frame]]]

[deftypefunk nonsemantic_plan get compiled_funk []
  [if [null internal-compiled_funk]
      [= internal-compiled_funk [let [[result [shelter [get this __compiled_funk]]]]
				  [if [is-type `bug result]
				      [let [[bug result]]
					[error bug_name `nonsemantic_plan-error_compiling_execute_funk
					       subbug   bug
					       this     this]]
				    result]]]]
  internal-compiled_funk]

[deftypefunk nonsemantic_plan execute eval []
  [funkall [get this compiled_funk] this]]

[deftypefunk nonsemantic_plan execute execute_as_thought [variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: executing "' [get this name_expression] '" with ' variable_frame '.']
  [let* [[semantic_planner [get [get this mental_layer] semantic_planner]]
	 [result           [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
				 [funk []
				       [have this eval]]
				 []]]]
    [terminal_format standard-terminal '\nnonsemantic_plan: done executing "' [get this name_expression] '".']
    result]]



[deftypefunk nonsemantic_plan get __compiled_imagine_funk []
  [let [[compile_option_frame [frame mode `imagine]]]
    [get this expression-compile expression compile_option_frame]]]

[deftypefunk nonsemantic_plan get compiled_imagine_funk []
  [if [null internal-compiled_imagine_funk]
      [= internal-compiled_imagine_funk [let [[result [shelter [get this __compiled_imagine_funk]]]]
					  [if [is-type `bug result]
					      [let [[bug result]]
						[error bug_name `nonsemantic_plan-error_compiling_imagine_funk
						       subbug   bug
						       this     this]]
					    result]]]]
  internal-compiled_imagine_funk]

[deftypefunk nonsemantic_plan execute imagine_eval []
  [funkall [get this compiled_imagine_funk] this]]

[deftypefunk nonsemantic_plan execute imagine_as_thought [variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: imagining executing "' [get this name_expression] '" with ' variable_frame '.']
  [with-new-cause [if [null [cause-lookup cause-imagine_time]]
		      [prog [cause-define cause-imagine_time                                     [new semantic_time [time]]]
			    [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
			    [cause-define cause-imagine_potential_effect_partial_state_set_mutex [new mutex]]
			    [cause-define cause-imagine_potential_effect_partial_state_set       [new set]]]]
		  [let [[remember_token [new remember_token cause-imagine_time]]]
		    [have [get [get this mental_layer] counterfactual_knowledge_base] add_remember_token remember_token]
		    [let* [[semantic_planner [get [get this mental_layer] semantic_planner]]
			   [result           [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
						   [funk []
							 [have this imagine_eval]]
						   []]]]
		      [terminal_format standard-terminal '\nnonsemantic_plan: done imagining executing "' [get this name_expression] '".']
		      [have [get [get this mental_layer] counterfactual_knowledge_base] remove_remember_token remember_token]
		      result]]]]




[deftypefunk nonsemantic_plan get __semantic_plan_object []
  [let [[semantic_plan_object [new semantic_plan_object [get [get this mind] semantic_realm] [get this unique_name] this]]
	[start_plan_operator  [let [[compile_option_frame [frame mode `semantic]]]
				[get this expression-compile expression compile_option_frame]]]]
    [set semantic_plan_object start_plan_operator start_plan_operator]
    [mapc [funk [variable_definition]
		[cond [[is-type `symbol variable_definition] [semantic-add semantic_plan_object default_variable variable_definition nil]]
		      [[is-type `cons   variable_definition] [if [== [length variable_definition] 2]
								 [let [[variable   [first  variable_definition]]
								       [definition [second variable_definition]]]
								   [semantic-add semantic_plan_object default_variable variable definition]]
							       [error bug_name   `invalid_plan_variable_definition
								      expression variable_definition]]]
		      [t                                     [error bug_name `invalid_plan_variable_definitions
								    expression expression]]]]
	  [get this variables]]
    semantic_plan_object]]

[deftypefunk nonsemantic_plan get semantic_plan_object []
  [if [null internal-semantic_plan_object]
      [= internal-semantic_plan_object [get this __semantic_plan_object]]]
  internal-semantic_plan_object]

