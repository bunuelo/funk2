'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[defunk name_expression-as-string [this]
  [cond [[is-type `string this] this]
	[[is-type `cons   this] [conslist-as-english_string [have this flatten]]]
	[t                      [get this as-string]]]]

[defunk name_expression-as-symbol [this]
  [get [name_expression-as-string this] as-symbol]]

[defunk nonsemantic_plan-unique_name_from_name_expression [name_expression]
  [name_expression-as-symbol name_expression]]


[defunk firstn [n exp]
  [if [< n 0]
      [error bug_name first_n-n_must_be_nonnegative
	     n        n
	     exp      exp]
    [if [== n 0]
	nil
      [let* [[exp_iter [cdr exp]]
	     [new_exp  [cons [car exp] nil]]
	     [iter     new_exp]]
	[dotimes [i [- n 1]]
	  [set iter cdr [cons [car exp_iter] nil]]
	  [= iter       [cdr iter]]
	  [= exp_iter   [cdr exp_iter]]]
	new_exp]]]]

[defunk restn [n exp]
  [if [< n 0]
      [error bug_name first_n-n_must_be_nonnegative
	     n        n
	     exp      exp]
    [if [== n 0]
	exp
      [dotimes [i n]
	[= exp [cdr exp]]]
      exp]]]

[defunk pattern-match_with_frame [pattern expression frame]
  `[terminal_format standard-terminal
		    '\n'
		    '\npattern    = ' pattern
		    '\nexpression = ' expression]
  [if [and [null pattern]
	   [null expression]]
      [cons frame nil]
    [if [or [null pattern]
	    [null expression]]
	nil
      [let [[pattern-car [car pattern]]]
	[if [eq pattern-car [car expression]]
	    [pattern-match_with_frame [cdr pattern] [cdr expression] frame]
	  [if [is-type `cons pattern-car]
	      [let [[command [car pattern-car]]]
		[cond [[eq command `?] [let [[variable_name  [elt pattern-car 1]]
					     [variable_value nil]]
					 [let [[expression_length [length expression]]
					       [done              nil]
					       [parses            nil]]
					   [dotimes [index expression_length]
					     [let [[subframe     [get frame new_copy]]
						   [match_length [+ index 1]]]
					       [have subframe add variable_name [firstn match_length expression]]
					       [let [[subparses [pattern-match_with_frame [cdr pattern] [restn match_length expression] subframe]]]
						 [= parses [append parses
								   subparses]]]]]
					   parses]]]
		      [t               [error bug_name `pattern-invalid_command]]]]
	    nil]]]]]]


[defunk pattern-match [pattern expression]
  [pattern-match_with_frame pattern expression [new frame]]]

[defunk pattern-test [expression]
  [let [[patterns `[[a  [? object] has [? property]]
		    [an [? object] has [? property]]]]
	[parses   nil]]
    [mapc [funk [pattern]
		[let [[pattern_parses [pattern-match pattern expression]]]
		  [= parses [append parses
				    pattern_parses]]]]
	  patterns]
    parses]]



'nonsemantic_plan'

[deframe nonsemantic_plan [frame] [mental_layer
				   name_expression
				   name_patterns
				   variables
				   expression
				   [internal-unique_name           nil]
				   [internal-semantic_plan_object  nil]
				   [internal-compiled_funk         nil]
				   [internal-compiled_imagine_funk nil]
				   [internal-english_conslist      `uninitialized]
				   [internal-english_string        nil]]
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [= mental_layer    initial-mental_layer]
       [= name_expression initial-name_expression]
       [= name_patterns   initial-name_patterns]
       [= variables       initial-variables]
       [= expression      initial-expression]
       ]]

[deftypefunk nonsemantic_plan get unique_name []
  [if [null internal-unique_name]
      [= internal-unique_name [nonsemantic_plan-unique_name_from_name_expression [get this name_expression]]]]
  internal-unique_name]

[deftypefunk nonsemantic_plan get mind []
  [get mental_layer mind]]

[deftypefunk nonsemantic_plan get name_pattern_match_pairs [expression]
  [let [[name_pattern_matches nil]]
    [mapc [funk [name_pattern]
		[let [[matches [pattern-match name_pattern expression]]]
		  [mapc [funk [match]
			      [= name_pattern_matches [cons [cons name_pattern match]
							    name_pattern_matches]]]
			matches]]]
	  name_patterns]
    name_pattern_matches]]

[deftypefunk nonsemantic_plan get best_name_pattern_match [expression]
  [let [[name_pattern_match_pairs [get this name_pattern_match_pairs expression]]
	[best_name_pattern_match  nil]
	[best_variable_count      nil]]
    [mapc [funk [name_pattern_match_pair]
		[let [[name_pattern [car name_pattern_match_pair]]
		      [match        [cdr name_pattern_match_pair]]]
		  [let [[variable_count [length [get match keys]]]]
		    [if [or [null best_name_pattern_match]
			    [< variable_count best_variable_count]]
			[= best_name_pattern_match match]]]]]
	  name_pattern_match_pairs]
    best_name_pattern_match]]

[deftypefunk nonsemantic_plan get expression-as_english_conslist [expression]
  [cond [[is-type `symbol expression] expression]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[eval-expression [elt arguments 0]]]
												  `[eval]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[quote-expression [elt arguments 0]]]
												  [cons quote-expression nil]]]]
						[[or [eq `list                       command]
						     [eq `backquote-list             command]] [apply &append [mapcar [funk [argument]
															    [get this expression-as_english_conslist argument]]
														      arguments]]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[print-expression [elt arguments 0]]]
												  [get this expression-as_english_conslist print-expression]]]]
						[[eq `prog                           command] [apply &append
												     [append `[[do the following in serial punctuation-colon]]
													     [let [[step_number 1]]
													       [mapcar [funk [argument]
															     [let [[argument-result [append `[,[get step_number as-symbol] punctuation-period]
																			    [get this expression-as_english_conslist argument]
																			    [if [not [eq step_number arguments-length]]
																				`[punctuation-comma]]]]]
															       [++ step_number]
															       argument-result]]
														       arguments]]]]]
						[[eq `parog                          command] [apply &append
												     [append `[[do the following in parallel punctuation-colon]]
													     [let [[step_number 1]]
													       [mapcar [funk [argument]
															     [let [[argument-result [append `[* punctuation-period]
																			    [get this expression-as_english_conslist argument]
																			    [if [not [eq step_number arguments-length]]
																				`[punctuation-comma]]]]]
															       argument-result]]
														       arguments]]]]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[time_to_wait [elt arguments 0]]]
												  [append `[wait for]
													  `[,time_to_wait]]]]]
						[[eq `call-below             command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[action_name [get this expression-as_english_conslist [elt arguments 0]]]]
												  [append `[call action in layer below to]
													  [have action_name flatten]]]]]
						[[eq `call                   command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[action_name [get this expression-as_english_conslist [elt arguments 0]]]]
												  [append `[call action to]
													  [have action_name flatten]]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let* [[plan_name [get this expression-as_english_conslist [elt arguments 0]]]]
												  [append `[call plan to]
													  [have plan_name flatten]]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[exists-expression [elt arguments 0]]]
												  [get this expression-as_english_conslist exists-expression]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[partial_state [get this expression-as_english_conslist [elt arguments 0]]]]
												  [append `[wait for]
													  partial_state]]]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[if-condition    [get this expression-as_english_conslist [elt arguments 0]]]
												      [if-true_branch  [get this expression-as_english_conslist [elt arguments 1]]]
												      [if-false_branch [if [== arguments-length 3]
															   [get this expression-as_english_conslist [elt arguments 2]]]]]
												  [append `[if]
													  if-condition
													  `[punctuation-comma]
													  if-true_branch
													  [if if-false_branch
													      [append `[otherwise]
														      if-false_branch]]]]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[assert-expression [get this expression-as_english_conslist [elt arguments 0]]]]
												  [append `[assert that]
													  assert-expression]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[variable-symbol [elt arguments 0]]]
												  `[? ,variable-symbol]]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[source_type     [get this expression-as_english_conslist [elt arguments 0]]]
												      [source_key_type [get this expression-as_english_conslist [elt arguments 1]]]
												      [source_key      [get this expression-as_english_conslist [elt arguments 2]]]
												      [source_value    [get this expression-as_english_conslist [elt arguments 3]]]
												      [key_type        [get this expression-as_english_conslist [elt arguments 4]]]
												      [key             [get this expression-as_english_conslist [elt arguments 5]]]
												      [value           [get this expression-as_english_conslist [elt arguments 6]]]]
												  [get [new semantic_partial_state_property [get [get this mind] semantic_realm]
													    source_type
													    source_key_type
													    source_key
													    source_value
													    key_type
													    key
													    value]
												       as-declarative_english_conslist]]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[source_type     [get this expression-as_english_conslist [elt arguments 0]]]
												      [source_key_type [get this expression-as_english_conslist [elt arguments 1]]]
												      [source_key      [get this expression-as_english_conslist [elt arguments 2]]]
												      [source_value    [get this expression-as_english_conslist [elt arguments 3]]]
												      [key_type        [get this expression-as_english_conslist [elt arguments 4]]]
												      [key             [get this expression-as_english_conslist [elt arguments 5]]]
												      [target_type     [get this expression-as_english_conslist [elt arguments 6]]]
												      [target_key_type [get this expression-as_english_conslist [elt arguments 7]]]
												      [target_key      [get this expression-as_english_conslist [elt arguments 8]]]
												      [target_value    [get this expression-as_english_conslist [elt arguments 9]]]]
												  [get [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
													    source_type
													    source_key_type
													    source_key
													    source_value
													    key_type
													    key
													    target_type
													    target_key_type
													    target_key
													    target_value]
												       as-declarative_english_conslist]]]]
						[[eq `defplan                        command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name                       [elt arguments 0]]
												      [matches                    nil]
												      [frame_variable_definitions nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= matches       [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= frame_variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]
												      ]]
												  nil]]]
						[t                                            `[error ,[flatten_constree expression]]]]]]]
	[t                            `[error punctuation-colon ,[flatten_constree expression]]]]]

[deftypefunk nonsemantic_plan get as-english_conslist []
  [if [eq `uninitialized internal-english_conslist]
      [= internal-english_conslist [get this expression-as_english_conslist expression]]]
  internal-english_conslist]

[deftypefunk nonsemantic_plan get as-english_string []
  [if [null internal-english_string]
      [= internal-english_string [conslist-as-english_string [get this as-english_conslist]]]]
  internal-english_string]

[deftypefunk nonsemantic_plan get as-string []
  [get this as-english_string]]

[deftypefunk nonsemantic_plan get as-graphviz_label []
  [string-concat '<' [get [get this unique_name] as-string] '>']]



[deftypefunk nonsemantic_plan execute expression-syntax_check [expression]
  [cond [[is-type `symbol expression] `[quote ,expression]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `eval
													 expression expression]
												[let [[eval-expression `[quote ,[elt arguments 0]]]]
												  `cannot_determine_syntax]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `quote
													 expression expression]
												[let [[quote-expression [elt arguments 0]]]
												  `[quote ,quote-expression]]]]
						[[or [eq `list                       command]
						     [eq `backquote-list             command]] [mapc [funk [argument]
													   [have this expression-syntax_check argument]]
												     arguments]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `print
													 expression expression]
												[let [[print-expression [elt arguments 0]]]
												  [have this expression-syntax_check print-expression]]]]
						[[eq `prog                           command] [let [[last_argument nil]]
												[mapc [funk [argument]
													    [= last_argument [have this expression-syntax_check argument]]]
												      arguments]
												last_argument]]
						[[eq `parog                          command] [prog [mapc [funk [argument]
														[have this expression-syntax_check argument]]
													  arguments]
												    nil]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-for-time
													 expression expression]
												[let [[time_to_wait [elt arguments 0]]]
												  [if [not [is-type `integer time_to_wait]]
												      [terminal_format standard-terminal '\nplan syntax warning: time_to_wait is not an integer (' time_to_wait ').']]
												  nil]]]
						[[eq `call-below             command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `call-below
													 expression expression]
												[let [[action_name [elt arguments 0]]]
												  [have this expression-syntax_check action_name]]]]
						[[eq `call                   command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `call
													 expression expression]
												[let [[action_name [elt arguments 0]]]
												  [have this expression-syntax_check action_name]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `plan-call
													 expression expression]
												[let [[plan_name [elt arguments 0]]]
												  [have this expression-syntax_check plan_name]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `exists
													 expression expression]
												[let [[exists-expression [elt arguments 0]]]
												  [have this expression-syntax_check exists-expression]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-for
													 expression expression]
												`cannot_determine_syntax]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `if
													 expression expression]
												[let [[if-condition    [have this expression-syntax_check [elt arguments 0]]]
												      [if-true_branch  [have this expression-syntax_check [elt arguments 1]]]
												      [if-false_branch [if [== arguments-length 3]
															   [have this expression-syntax_check [elt arguments 2]]]]]
												  `cannot_determine_syntax]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `assert
													 expression expression]
												[let [[assert-expression [elt arguments 0]]]
												  [have this expression-syntax_check assert-expression]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `?
													 expression expression]
												[let [[variable-symbol `[quote ,[elt arguments 0]]]]
												  `cannot_determine_syntax]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `property
													 expression expression]
												[let [[source_type     [have this expression-syntax_check [elt arguments 0]]]
												      [source_key_type [have this expression-syntax_check [elt arguments 1]]]
												      [source_key      [have this expression-syntax_check [elt arguments 2]]]
												      [source_value    [have this expression-syntax_check [elt arguments 3]]]
												      [key_type        [have this expression-syntax_check [elt arguments 4]]]
												      [key             [have this expression-syntax_check [elt arguments 5]]]
												      [value           [have this expression-syntax_check [elt arguments 6]]]]
												  `cannot_determine_syntax]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `relationship
													 expression expression]
												[let [[source_type     [have this expression-syntax_check [elt arguments 0]]]
												      [source_key_type [have this expression-syntax_check [elt arguments 1]]]
												      [source_key      [have this expression-syntax_check [elt arguments 2]]]
												      [source_value    [have this expression-syntax_check [elt arguments 3]]]
												      [key_type        [have this expression-syntax_check [elt arguments 4]]]
												      [key             [have this expression-syntax_check [elt arguments 5]]]
												      [target_type     [have this expression-syntax_check [elt arguments 6]]]
												      [target_key_type [have this expression-syntax_check [elt arguments 7]]]
												      [target_key      [have this expression-syntax_check [elt arguments 8]]]
												      [target_value    [have this expression-syntax_check [elt arguments 9]]]]
												  `cannot_determine_syntax]]]
						[[eq `defplan                        command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name                       [elt arguments 0]]
												      [matches                    nil]
												      [frame_variable_definitions nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= matches       [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= frame_variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]
												      ]]
												  nil]]]
						[t                                            [error bug_name `nonsemantic_plan_syntax_error]]]]]]
	[t                            [error bug_name `nonsemantic_plan_syntax_error]]]]

[deftypefunk nonsemantic_plan execute syntax_check []
  [have this expression-syntax_check expression]]


[deftypefunk nonsemantic_plan execute check_exists [semantic_partial_state]
  [have [get this mental_layer] check_exists semantic_partial_state]]

[deftypefunk nonsemantic_plan execute imagine_check_exists [semantic_partial_state]
  [have [get this mental_layer] imagine_check_exists semantic_partial_state]]

[deftypefunk nonsemantic_plan execute wait_for [semantic_partial_state]
  [have [get this mental_layer] wait_for semantic_partial_state]]

[deftypefunk nonsemantic_plan execute assert [semantic_partial_state]
  [have [get this mental_layer] assert semantic_partial_state]]

[deftypefunk nonsemantic_plan execute imagine_asserting [semantic_partial_state]
  [have [get this mental_layer] imagine_assuring semantic_partial_state]]


[deftypefunk nonsemantic_plan execute __execute_funk_as_thought_in_semantic_planner [semantic_planner variable_frame funk args]
  [terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.']
  [shelter [let* [[semantic_knowledge_base_set [have semantic_planner lookup `semantic_knowledge_base_set]]
		  [semantic_knowledge_bases    [get semantic_knowledge_base_set elements]]]
	     [if [null semantic_knowledge_bases]
		 [error funkname `semantic_planner-new_semantic_thought
			bug_name `semantic_knowledge_bases-is-nil]]
	     
	     [let* [[execute_now-conditionlock   [new conditionlock]]
		    [execute_now                 nil]
		    [thought_fiber               [fiber [funk []
							      [have execute_now-conditionlock lock]
							      [while [not execute_now]
								[have execute_now-conditionlock wait]]
							      [have execute_now-conditionlock unlock]
							      [cause-define cause-name [get this unique_name]]
							      [apply funk args]]
							[]]]
		    [semantic_thought            [let [[this [new semantic_thought [get semantic_planner semantic_realm]]]]
						   [set this fiber thought_fiber]
						   this]]]
	       
	       [let [[semantic_environment [new semantic_environment [get semantic_planner semantic_realm]]]]
		 [have [get this semantic_plan_object] add_default_frame_to_environment semantic_environment]
		 [mapc [funk [variable_name]
			     [let [[default_variable_value_set [semantic-lookup_set semantic_environment variable variable_name]]]
			       [mapc [funk [default_variable_value]
					   [semantic-remove semantic_environment variable variable_name default_variable_value]]
				     [get default_variable_value_set elements]]]
			     [semantic-add semantic_environment variable variable_name [have variable_frame lookup variable_name]]]
		       [get variable_frame keys]]
		 [set semantic_thought environment semantic_environment]]
	       
	       [mapc [funk [semantic_knowledge_base]
			   [have semantic_knowledge_base add_semantic_frame semantic_thought]]
		     semantic_knowledge_bases]
	       [semantic-add semantic_planner thought semantic_thought]
	       
	       [have [get thought_fiber cause_reg] define `cause-semantic_thought semantic_thought]
	       
	       [terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (telling thought_fiber to execute now)']
	       [have execute_now-conditionlock lock]
	       [= execute_now t]
	       [have execute_now-conditionlock signal]
	       [have execute_now-conditionlock unlock]
	       [let [[result [fiber-sheltered_join thought_fiber]]]
		 [terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (joined thought_fiber)']
		 
		 [semantic-remove semantic_planner thought semantic_thought]
		 [mapc [funk [semantic_knowledge_base]
			     [have semantic_knowledge_base remove_semantic_frame semantic_thought]]
		       semantic_knowledge_bases]
		 
		 result]]]]]




[defunk nonsemantic_plan-expression-compile [expression]
  [cond [[is-type `symbol expression] [eval `[funk []
						   [quote ,expression]]]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `eval
													 expression expression]
												[let [[eval-expression `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [eval ,eval-expression]]]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `quote
													 expression expression]
												[let [[quote-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [quote ,quote-expression]
													       ]]]]]
						[[or [eq `list                       command]
						     [eq `backquote-list             command]] [eval `[funk [this]
													    [conslist @[mapcar [funk [argument]
																     `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
															       arguments]]]]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `print
													 expression expression]
												[let [[print-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-print-expression [funkall ,[nonsemantic_plan-expression-compile print-expression] this]]]
														 [terminal_format standard-terminal '\nplan printing expression: ' eval-print-expression]
														 eval-print-expression]]]]]]
						[[eq `prog                           command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan evaluating serial process.']
													   @[mapcar [funk [argument]
															  `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
														    arguments]]]]
						[[eq `parog                          command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan evaluating parallel process.']
													   [parog @[mapcar [funk [argument]
																 `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
															   arguments]]
													   nil]]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-for-time
													 expression expression]
												[let [[time_to_wait [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[time_to_wait ,time_to_wait]]
														 [dotimes [i time_to_wait]
														   `[terminal_format standard-terminal '\nplan waiting for time step ' i `/ time_to_wait '.']
														   [wait-for-trigger [get [get [get this mind] body] time_step_trigger]]]
														 ]]]]]]
						[[eq `call-below             command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `call-below
													 expression expression]
												[let [[action_name `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action_below ,action_name]]]
														 [if [null action]
														     [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															    action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														   [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
															 [have action wait_to_call]
															 ]]]]]]]]
						[[eq `call                   command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `call
													 expression expression]
												[let [[action_name `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action ,action_name]]]
														 [if [null action]
														     [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															    action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														   [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
															 [have action wait_to_call]
															 ]]]]]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `plan-call
													 expression expression]
												[let [[plan_name `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let* [[plan_name                            ,plan_name]
														      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														      [semantic_plan_object                 [have [get this mental_layer] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														      [variable_frame                       [new frame]]]
														 [if [null semantic_plan_object]
														     [let [[semantic_plan_variable_pair [have [get this mental_layer] lookup_matching_semantic_plan_variable_pair plan_name]]]
														       [if semantic_plan_variable_pair
															   [prog [= semantic_plan_object [car semantic_plan_variable_pair]]
																 [= variable_frame       [cdr semantic_plan_variable_pair]]]]]]
														 [terminal_format standard-terminal '\nexecuting plan with variable frame: ' variable_frame]
														 [if [null semantic_plan_object]
														     [error bug_name           `nonsemantic_plan-plan_call-no_such_plan
															    action_description [conslist-as-english_string [have [cons semantic_plan_object-phenomenal_name nil] flatten]]]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]
															 [semantic_planner [get [get [get this mental_layer] agency `plan] semantic_planner]]]
														     [terminal_format standard-terminal '\nexecuting plan: "' [get semantic_plan_object-phenomenal_name as-string] '."']
														     [have nonsemantic_plan execute_as_thought_in_semantic_planner semantic_planner variable_frame]
														     ]]]]]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `exists
													 expression expression]
												[let [[exists-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-exists-expression [funkall ,[nonsemantic_plan-expression-compile exists-expression] this]]]
														 [have this check_exists eval-exists-expression]
														 ]]]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-for
													 expression expression]
												[let [[partial_state `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[partial_state ,partial_state]]
														 [terminal_format standard-terminal '\nplan waiting for: "' [get partial_state as-declarative_english_string] '."']
														 [have this wait_for partial_state]]
													       ]]]]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `if
													 expression expression]
												[let [[if-condition    `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]
												      [if-true_branch  `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]
												      [if-false_branch [if [== arguments-length 3]
															   `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]]]
												  [eval `[funk [this]
													       [if ,if-condition
														   ,if-true_branch
														 ,if-false_branch]]]]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `assert
													 expression expression]
												[let [[assert-expression `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[assert-expression ,assert-expression]]
														 [if [not assert-expression]
														     [error bug_name    `assertion-failed
															    description [conslist `assert [quote ,assert-expression]]]]]]]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `?
													 expression expression]
												[let [[variable-symbol `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
														 [terminal_format standard-terminal '\nplan looking up variable value, ' ,variable-symbol '.']
														 [have semantic_thought lookup_a_variable_value ,variable-symbol]
														 ]]]]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `property
													 expression expression]
												[let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												      [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]]
												      [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]]
												      [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 3]] this]]]
												      [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 4]] this]]]
												      [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 5]] this]]]
												      [value           `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 6]] this]]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,value]
													       ]]]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `relationship
													 expression expression]
												[let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												      [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]]
												      [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]]
												      [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 3]] this]]]
												      [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 4]] this]]]
												      [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 5]] this]]]
												      [target_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 6]] this]]]
												      [target_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 7]] this]]]
												      [target_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 8]] this]]]
												      [target_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile [elt arguments 9]] this]]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,target_type
														    ,target_key_type
														    ,target_key
														    ,target_value]
													       ]]]]]
						[[eq `defplan                        command] [if [not [>= arguments-length 1]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[name_expression      [elt arguments 0]]
												      [name_patterns        nil]
												      [variable_definitions nil]
												      [plan_body_expression nil]]
												  [let [[argument_iter                   [cdr arguments]]
													[done_reading_optional_arguments nil]]
												    [while [not done_reading_optional_arguments]
												      [let [[optional_argument_key [car argument_iter]]]
													[cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			  [= name_patterns [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			  [= variable_definitions [car argument_iter]]
																			  [= argument_iter [cdr argument_iter]]]]
													      [t                                    [= done_reading_optional_arguments t]]]]]
												    [if [== [length argument_iter] 1]
													[= plan_body_expression [car argument_iter]]
												      [= plan_body_expression `[prog @argument_iter]]]]
												  [eval `[funk [this]
													       [have [get this mental_layer] create_semantic_plan [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]
													       ]]]]]
						[t                                            [error bug_name `nonsemantic_plan_compile_error]]]]]]
	[t                            [error bug_name `nonsemantic_plan_compile_error]]]]

[deftypefunk nonsemantic_plan get __compiled_funk []
  [nonsemantic_plan-expression-compile expression]]

[deftypefunk nonsemantic_plan get compiled_funk []
  [if [null internal-compiled_funk]
      [= internal-compiled_funk [get this __compiled_funk]]]
  internal-compiled_funk]

[deftypefunk nonsemantic_plan execute eval []
  [funkall [get this compiled_funk] this]]

[deftypefunk nonsemantic_plan execute execute_as_thought_in_semantic_planner [semantic_planner variable_frame]
  [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
	[funk []
	      [have this eval]]
	[]]]


[deftypefunk nonsemantic_plan execute lookup_action_below [action_name_expression]
  [have mental_layer lookup_action_below action_name_expression]]

[deftypefunk nonsemantic_plan execute lookup_action [action_name_expression]
  [have mental_layer lookup_action action_name_expression]]


[defunk nonsemantic_plan-expression-compile_imagine [expression]
  [cond [[is-type `symbol expression] [eval `[funk []
						   [quote ,expression]]]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
				      [let [[arguments-length [length arguments]]]
					[cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `eval
												       expression expression]
											      [let [[eval-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[eval-expression [quote ,eval-expression]]]
													       [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' eval_expression '.']
													       ]]]]]]
					      [[eq `quote                          command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `quote
												       expression expression]
											      [let [[quote-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [quote ,quote-expression]
													     ]]]]]
					      [[or [eq `list                       command]
						   [eq `backquote-list             command]] [eval `[funk [this]
													  [conslist @[mapcar [funk [argument]
																   `[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
															     arguments]]]]]
					      [[eq `print                          command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `print
												       expression expression]
											      [let [[print-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[eval-print-expression [funkall ,[nonsemantic_plan-expression-compile_imagine print-expression] this]]]
													       [terminal_format standard-terminal '\nplan imagine printing expression: ' eval-print-expression]
													       eval-print-expression]]]]]]
					      [[eq `prog                           command] [eval `[funk [this]
													 [terminal_format standard-terminal '\nplan imagining serial process.']
													 @[mapcar [funk [argument]
															`[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
														  arguments]]]]
					      [[eq `parog                          command] [eval `[funk [this]
													 [terminal_format standard-terminal '\nplan imagining parallel process.']
													 [parog @[mapcar [funk [argument]
															       `[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
															 arguments]]
													 nil]]]
					      [[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `wait-for-time
												       expression expression]
											      [let [[time_to_wait [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[time_to_wait ,time_to_wait]]
													       'no imaginative effects'
													       ]]]]]]
					      [[eq `call-below             command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `call-below
												       expression expression]
											      [let [[action_name `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												[eval `[funk [this]
													     [let [[action [have this lookup_action_below ,action_name]]]
													       [if [null action]
														   [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															  action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														 [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
														       [have action imagine_waiting_to_call]
														       ]]]]]]]]
					      [[eq `call                   command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `call
												       expression expression]
											      [let [[action_name `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												[eval `[funk [this]
													     [let [[action [have this lookup_action ,action_name]]]
													       [if [null action]
														   [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															  action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														 [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
														       [have action imagine_waiting_to_call]
														       ]]]]]]]]
					      [[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan-call
												       expression expression]
											      [let* [[plan_name `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												[eval `[funk [this]
													     [let* [[plan_name                            ,plan_name]
														    [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
														    [semantic_plan_object                 [have [get this mental_layer] lookup_semantic_plan semantic_plan_object-phenomenal_name]]
														    [variable_frame                       [new frame]]]
													       [if [null semantic_plan_object]
														   [let [[semantic_plan_variable_pair [have [get this mental_layer] lookup_matching_semantic_plan_variable_pair plan_name]]]
														     [if semantic_plan_variable_pair
															 [prog [= semantic_plan_object [car semantic_plan_variable_pair]]
															       [= variable_frame       [cdr semantic_plan_variable_pair]]]]]]
													       [terminal_format standard-terminal '\nimagining executing plan with variable frame: ' variable_frame]
													       [if [null semantic_plan_object]
														   [error bug_name           `nonsemantic_plan-plan_call-no_such_plan
															  action_description [conslist-as-english_string [have [cons semantic_plan_object-phenomenal_name nil] flatten]]]
														 [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]
														       [semantic_planner [get [get [get this mental_layer] agency `plan] semantic_planner]]]
														   [terminal_format standard-terminal '\nimagining executing plan: "' [get semantic_plan_object-phenomenal_name as-string] '."']
														   [have nonsemantic_plan imagine_as_thought_in_semantic_planner semantic_planner variable_frame]
														   ]]]]]]]]
					      [[eq `exists                         command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `exists
												       expression expression]
											      [let [[exists-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[eval-exists-expression [funkall ,[nonsemantic_plan-expression-compile_imagine exists-expression] this]]]
													       [have this imagine_check_exists eval-exists-expression]
													       ]]]]]]
					      [[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `wait-for
												       expression expression]
											      [let [[partial_state `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												[eval `[funk [this]
													     [let [[partial_state ,partial_state]]
													       [terminal_format standard-terminal '\nplan imagining waiting for: "'
																[get partial_state as-declarative_english_string] '."']
													       [have this wait_for partial_state]
													       ]
													     ]]]]]
					      [[eq `if                             command] [if [not [or [== arguments-length 2]
													 [== arguments-length 3]]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `if
												       expression expression]
											      [let [[if-condition    `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]
												    [if-true_branch  `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]
												    [if-false_branch [if [== arguments-length 3]
															 `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]]]
												[eval `[funk [this]
													     [if ,if-condition
														 ,if-true_branch
													       ,if-false_branch]]]]]]
					      [[eq `assert                         command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `assert
												       expression expression]
											      [let [[assert-expression `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												[eval `[funk [this]
													     [let [[assert-expression ,assert-expression]]
													       [if [not assert-expression]
														   [error bug_name    `assertion-failed
															  description [conslist `imagine_asserting [quote ,assert-expression]]]]]]]]]]
					      [[eq `?                              command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `?
												       expression expression]
											      [let [[variable-symbol `[quote ,[elt arguments 0]]]]
												[eval `[funk [this]
													     [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
													       [terminal_format standard-terminal '\nplan imagining looking up variable value, ' ,variable-symbol '.']
													       [have semantic_thought lookup_a_variable_value ,variable-symbol]
													       ]]]]]]
					      [[eq `property                       command] [if [not [eq 7 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `property
												       expression expression]
											      [let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												    [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]]
												    [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]]
												    [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 3]] this]]]
												    [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 4]] this]]]
												    [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 5]] this]]]
												    [value           `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 6]] this]]]]
												[eval `[funk [this]
													     [new semantic_partial_state_property [get [get this mind] semantic_realm]
														  ,source_type
														  ,source_key_type
														  ,source_key
														  ,source_value
														  ,key_type
														  ,key
														  ,value]
													     ]]]]]
					      [[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `relationship
												       expression expression]
											      [let [[source_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												    [source_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]]
												    [source_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]]
												    [source_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 3]] this]]]
												    [key_type        `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 4]] this]]]
												    [key             `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 5]] this]]]
												    [target_type     `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 6]] this]]]
												    [target_key_type `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 7]] this]]]
												    [target_key      `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 8]] this]]]
												    [target_value    `[name_expression-as-symbol [funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 9]] this]]]]
												[eval `[funk [this]
													     [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
														  ,source_type
														  ,source_key_type
														  ,source_key
														  ,source_value
														  ,key_type
														  ,key
														  ,target_type
														  ,target_key_type
														  ,target_key
														  ,target_value]
													     ]]]]]
					      [[eq `defplan                        command] [if [not [>= arguments-length 1]]
												`[error punctuation-colon ,[flatten_constree expression]]
											      [let [[name                       [elt arguments 0]]
												    [matches                    nil]
												    [frame_variable_definitions nil]]
												[let [[argument_iter                   [cdr arguments]]
												      [done_reading_optional_arguments nil]]
												  [while [not done_reading_optional_arguments]
												    [let [[optional_argument_key [car argument_iter]]]
												      [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			[= matches       [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			[= frame_variable_definitions [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [t                                    [= done_reading_optional_arguments t]]]]
												    ]]
												[eval `[funk [this]
													     ]]]]]
					      [t                                            [error bug_name `nonsemantic_plan_compile_imagine_error]]]]]]
	[t                          [error bug_name `nonsemantic_plan_compile_imagine_error]]]]

[deftypefunk nonsemantic_plan get __compiled_imagine_funk []
  [nonsemantic_plan-expression-compile_imagine expression]]

[deftypefunk nonsemantic_plan get compiled_imagine_funk []
  [if [null internal-compiled_imagine_funk]
      [= internal-compiled_imagine_funk [get this __compiled_imagine_funk]]]
  internal-compiled_imagine_funk]

[deftypefunk nonsemantic_plan execute imagine_eval []
  [funkall [get this compiled_imagine_funk] this]]

[deftypefunk nonsemantic_plan execute imagine_as_thought_in_semantic_planner [semantic_planner variable_frame]
  [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
	[funk []
	      [have this imagine_eval]]
	[]]]




[defunk semantic_plan_operator_activation-new_with_resource_dependency [semantic_realm resource_activation_dependency]
  [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]
	[semantic_counterfactual_transframe [new semantic_counterfactual_transframe semantic_realm]]]
    [set semantic_counterfactual_transframe resource_activation_dependency resource_activation_dependency]
    [set semantic_plan_operator_activation counterfactual_transframe semantic_counterfactual_transframe]
    semantic_plan_operator_activation]]

[defunk nonsemantic_plan-expression-semantic_compile [expression semantic_realm]
  [cond [[is-type `symbol expression] [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
					,expression]]
	[[is-type `cons expression] [let [[command   [car expression]]
					  [arguments [cdr expression]]]
				      [let [[arguments-length [length arguments]]]
					[cond [[eq `eval                           command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `eval
												       expression expression]
											      [let [[eval-expression [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `eval]]]]
					      [[eq `quote                          command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `quote
												       expression expression]
											      [let [[quote-expression [elt arguments 0]]]
												nil]]]
					      [[or [eq `list                       command]
						   [eq `backquote-list             command]] [mapcar [funk [argument]
													   [nonsemantic_plan-expression-semantic_compile argument semantic_realm]]
												     arguments]]
					      [[eq `print                          command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `print
												       expression expression]
											      [let [[print-expression [elt arguments 0]]]
												[nonsemantic_plan-expression-semantic_compile print-expression semantic_realm]]]]
					      [[eq `prog                           command] [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]]
											      semantic_plan_operator_activation]]
					      [[eq `parog                          command] [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]]
											      semantic_plan_operator_activation]]
					      [[eq `wait-for-time                  command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `wait-for-time
												       expression expression]
											      [let [[time_to_wait [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-for-time]]]]
					      [[eq `call-below                     command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `call-below
												       expression expression]
											      [let [[action_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `call-below]]]]
					      [[eq `call                           command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `call
												       expression expression]
											      [let [[action_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `call]]]]
					      [[eq `plan-call                      command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan-call
												       expression expression]
											      [let [[plan_name [nonsemantic_plan-expression-semantic_compile [elt arguments 0] semantic_realm]]]
												nil]]]
					      [[eq `exists                         command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `exists
												       expression expression]
											      [let [[exists-expression [elt arguments 0]]]
												[nonsemantic_plan-expression-semantic_compile exists-expression semantic_realm]]]]
					      [[eq `wait-for                       command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `wait-for
												       expression expression]
											      [let [[partial_state [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-for]]]]
					      [[eq `if                             command] [if [not [or [== arguments-length 2]
													 [== arguments-length 3]]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `if
												       expression expression]
											      nil]]
					      [[eq `assert                         command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `assert
												       expression expression]
											      [let [[assert-expression [elt arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `assert]]]]
					      [[eq `?                              command] [if [not [== 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `?
												       expression expression]
											      [let [[variable-symbol [elt arguments 0]]]
												`[? ,variable-symbol]]]]
					      [[eq `property                       command] [if [not [== 7 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `property
												       expression expression]
											      [let [[source_type     [elt arguments 0]]
												    [source_key_type [elt arguments 1]]
												    [source_key      [elt arguments 2]]
												    [source_value    [elt arguments 3]]
												    [key_type        [elt arguments 4]]
												    [key             [elt arguments 5]]
												    [value           [elt arguments 6]]]
												nil]]]
					      [[eq `relationship                   command] [if [not [== 10 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `relationship
												       expression expression]
											      [let [[source_type     [elt arguments 0]]
												    [source_key_type [elt arguments 1]]
												    [source_key      [elt arguments 2]]
												    [source_value    [elt arguments 3]]
												    [key_type        [elt arguments 4]]
												    [key             [elt arguments 5]]
												    [target_type     [elt arguments 6]]
												    [target_key_type [elt arguments 7]]
												    [target_key      [elt arguments 8]]
												    [target_value    [elt arguments 9]]]
												nil]]]
					      [[eq `defplan                        command] [if [not [>= arguments-length 1]]
												`[error punctuation-colon ,[flatten_constree expression]]
											      [let [[name                       [elt arguments 0]]
												    [matches                    nil]
												    [frame_variable_definitions nil]]
												[let [[argument_iter                   [cdr arguments]]
												      [done_reading_optional_arguments nil]]
												  [while [not done_reading_optional_arguments]
												    [let [[optional_argument_key [car argument_iter]]]
												      [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
																			[= matches       [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
																			[= frame_variable_definitions [car argument_iter]]
																			[= argument_iter [cdr argument_iter]]]]
													    [t                                    [= done_reading_optional_arguments t]]]]
												    ]]
												nil]]]
					      [t                                            [error bug_name `nonsemantic_plan_compile_error]]]]]]
	[t                          [error bug_name `nonsemantic_plan_compile_error]]]]

[deftypefunk nonsemantic_plan get __semantic_plan_object []
  [let [[semantic_plan_object [new semantic_plan_object [get [get this mind] semantic_realm] [get this unique_name] this]]
	[start_plan_operator  [nonsemantic_plan-expression-semantic_compile expression [get [get this mind] semantic_realm]]]]
    [set semantic_plan_object start_plan_operator start_plan_operator]
    [mapc [funk [variable_definition]
		[cond [[is-type `symbol variable_definition] [semantic-add semantic_plan_object default_variable variable_definition nil]]
		      [[is-type `cons   variable_definition] [if [== [length variable_definition] 2]
								 [let [[variable   [first  variable_definition]]
								       [definition [second variable_definition]]]
								   [semantic-add semantic_plan_object default_variable variable definition]]
							       [error bug_name   `invalid_plan_variable_definition
								      expression variable_definition]]]
		      [t                                     [error bug_name `invalid_plan_variable_definitions
								    expression expression]]]]
	  [get this variables]]
    semantic_plan_object]]

[deftypefunk nonsemantic_plan get semantic_plan_object []
  [if [null internal-semantic_plan_object]
      [= internal-semantic_plan_object [get this __semantic_plan_object]]]
  internal-semantic_plan_object]

