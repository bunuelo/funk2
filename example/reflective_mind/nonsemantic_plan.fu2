'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[defunk name_expression-as-string [this]
  [cond [[is-type `string this] this]
	[t                      [get this as-string]]]]

[defunk name_expression-as-symbol [this]
  [get [name_expression-as-string this] as-symbol]]

[defunk nonsemantic_plan-unique_name_from_name_expression [name_expression]
  [name_expression-as-symbol name_expression]]



'semantic_plan_operator_activation'

[defunk semantic_plan_operator_activation-new_with_resource_dependency [semantic_realm resource_activation_dependency]
  [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]
	[semantic_counterfactual_transframe [new semantic_counterfactual_transframe semantic_realm]]]
    [set semantic_counterfactual_transframe resource_activation_dependency resource_activation_dependency]
    [set semantic_plan_operator_activation counterfactual_transframe semantic_counterfactual_transframe]
    semantic_plan_operator_activation]]



'nonsemantic_plan_value'

[deframe nonsemantic_plan_value [frame] [value
					 [partial_state_existence_dependency_set [new set]]
					 [dependent_value_set                    [new set]]
					 [value_dependency_set                   [new set]]]
  [new [initial-value]
       [= value initial-value]
       [if [cause-lookup cause-last_decision_value]
	   [have this add_value_dependency cause-last_decision_value]]]]

[deftypefunk nonsemantic_plan_value execute add_partial_state_existence_dependency [partial_state]
  [have partial_state_existence_dependency_set add partial_state]]

[deftypefunk nonsemantic_plan_value execute add_value_dependency [nonsemantic_plan_value]
  [have [get nonsemantic_plan_value dependent_value_set] add this]
  [have value_dependency_set                             add nonsemantic_plan_value]]

[deftypefunk nonsemantic_plan_value get partial_state_dependencies []
  [get partial_state_existence_dependency_set elements]]

[deftypefunk nonsemantic_plan_value get negative []
  [let [[new_value [new nonsemantic_plan_value value]]]
    [mapc [funk [partial_state_existence_dependency]
		[have new_value add_partial_state_existence_dependency partial_state_existence_dependency]]
	  [get partial_state_existence_dependency_set elements]]
    [have new_value add_value_dependency this]
    new_value]]


'nonsemantic_plan_execution_node'

[deframe nonsemantic_plan_execution_node [frame] [node_type
						  expression
						  [subnode_set [new set]]
						  supernode
						  first_subnode
						  previous_node
						  next_node]
  [new [initial-node_type initial-expression]
       [= node_type  initial-node_type]
       [= expression initial-expression]
       [= supernode  [cause-lookup cause-nonsemantic_plan_execution_node]]
       [if supernode
	   [have [get supernode subnode_set] add this]]]]

[deftypefunk nonsemantic_plan_execution_node set previous_node [node]
  [if previous_node
      [error bug_name `nonsemantic_plan_execution_node-previous_node_already_defined_for_node
	     this     this
	     node     node]]
  [if [get node next_node]
      [error bug_name `nonsemantic_plan_execution_node-next_node_already_defined_for_node
	     this     this
	     node     node]]
  [= previous_node node]
  [set node next_node this]]

[deftypefunk nonsemantic_plan_execution_node set first_subnode [node]
  [if first_subnode
      [error bug_name `nonsemantic_plan_execution_node-first_subnode_already_defined_for_node
	     this     this
	     node     node]]
  [= first_subnode node]]

[deftypefunk nonsemantic_plan_execution_node get as-graph_node [graph node_ptypehash]
  [let [[this-graph_node [have node_ptypehash lookup this]]]
    [if [not this-graph_node]
	[prog [= this-graph_node [new graph_node node_type]]
	      [have graph add_node this-graph_node]
	      [have node_ptypehash add this this-graph_node]
	      [mapc [funk [subnode]
			  [let* [[subnode-graph_node [get subnode as-graph_node graph node_ptypehash]]
				 [subnode-graph_edge [new graph_edge `subnode this-graph_node subnode-graph_node]]]
			    [have graph add_edge subnode-graph_edge]]]
		    [get subnode_set elements]]
	      [if first_subnode
		  [let* [[first_subnode-graph_node [get first_subnode as-graph_node graph node_ptypehash]]
			 [first_subnode-graph_edge [new graph_edge `first_subnode this-graph_node first_subnode-graph_node]]]
		    [have graph add_edge first_subnode-graph_edge]]]
	      [if next_node
		  [let* [[next_node-graph_node [get next_node as-graph_node graph node_ptypehash]]
			 [next_node-graph_edge [new graph_edge `next_node this-graph_node next_node-graph_node]]]
		    [have graph add_edge next_node-graph_edge]]]]]
    this-graph_node]]

[deftypefunk nonsemantic_plan_execution_node get as-graph []
  [let [[graph          [new graph]]
	[node_ptypehash [new ptypehash]]]
    [get this as-graph_node graph node_ptypehash]
    graph]]

'value_dependency'

[deframe value_dependency [frame] [multiple_possible_values
				   value]
  [new [initial-multiple_possible_values
	initial-value]
       [= multiple_possible_values initial-multiple_possible_values]
       [= value                    initial-value]]]


'multiple_possible_values'

[deframe multiple_possible_values [frame] [[mutate_mutex                 [new mutex]]
					   [good_value_set               [new set]]
					   [bug_value_ptypehash          [new ptypehash]]
					   [dependencies_value_ptypehash [new ptypehash]]]
  [new [values]
       [mapc [funk [value]
		   [have this add_value value]]
	     values]]]

[deftypefunk multiple_possible_values get good_value_count []
  [get good_value_set key_count]]

[deftypefunk multiple_possible_values get good_values []
  [get good_value_set elements]]

[deftypefunk multiple_possible_values get good_value []
  [have mutate_mutex lock]
  [let [[good_values [get good_value_set elements]]]
    [if good_values
	[let [[result [car good_values]]]
	  [have mutate_mutex unlock]
	  result]
      [prog [have mutate_mutex unlock]
	    [error bug_name `multiple_possible_values-get-good_value-no_good_values_exist
		   this     this]]]]]

[deftypefunk multiple_possible_values execute add_value_bug [value bug]
  [have mutate_mutex lock]
  [if [get good_value_set contains value]
      [have good_value_set remove value]]
  [let [[current_value_bugs [have bug_value_ptypehash lookup value]]]
    [have bug_value_ptypehash add value [cons bug current_value_bugs]]
    [have mutate_mutex unlock]]]

[deftypefunk multiple_possible_values execute add_value [value]
  [cond [[is-type `multiple_possible_values value] [let [[multiple_possible_values value]]
						     [mapc [funk [one_value]
								 [have this add_value one_value]]
							   [get multiple_possible_values good_values]]]]
	[t                                         [prog [have mutate_mutex lock]
							 [have good_value_set add value]
							 [have mutate_mutex unlock]]]]]

[deftypefunk multiple_possible_values execute add_value_dependency [value dependency]
  [assert-type value_dependency dependency]
  [cond [[is-type `multiple_possible_values value] [let [[multiple_possible_values value]]
						     [mapc [funk [one_value]
								 [have this add_value_dependency one_value dependency]]
							   [get multiple_possible_values good_values]]]]
	[t                                         [prog [have mutate_mutex lock]
							 [have dependencies_value_ptypehash add value [cons dependency [have dependencies_value_ptypehash lookup value]]]
							 [have mutate_mutex unlock]]]]]

[deftypefunk multiple_possible_values execute add_value_with_dependency [value dependency]
  [have this add_value value]
  [have this add_value_dependency value dependency]]

[deftypefunk multiple_possible_values get value_dependencies [value]
  [have dependencies_value_ptypehash lookup value]]


'nonsemantic_plan'

[deframe nonsemantic_plan [frame] [mental_layer
				   name_expression
				   name_patterns
				   variables
				   expression
				   [internal-default_variable_frame  nil]
				   [internal-unique_name             nil]
				   [internal-semantic_plan_object    nil]
				   [internal-compiled_funk           nil]
				   [internal-compiled_imagine_funk   nil]
				   [internal-natural_language_string nil]
				   [internal-constant_variable_frame nil]
				   [top_execution_node_set           [new set]]
				   [imagined_top_execution_node_set  [new set]]]
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [= mental_layer    initial-mental_layer]
       [= name_expression initial-name_expression]
       [= name_patterns   initial-name_patterns]
       [= variables       initial-variables]
       [= expression      initial-expression]]]

[deftypefunk nonsemantic_plan get mental_layer_below []
  [get mental_layer mental_layer_below]]

[deftypefunk nonsemantic_plan get __default_variable_frame []
  [let [[default_variable_frame [new frame]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first variable_definition]]
		      [variable_value [second variable_definition]]]
		  [have default_variable_frame add variable_name variable_value]]]
	  variables]
    default_variable_frame]]

[deftypefunk nonsemantic_plan get default_variable_frame []
  [if [null internal-default_variable_frame]
      [= internal-default_variable_frame [get this __default_variable_frame]]]
  internal-default_variable_frame]

[deftypefunk nonsemantic_plan get new_copy_given_variable_frame [variable_frame]
  [let [[new_name_expressions nil]
	[new_variable_frame   [get variable_frame new_copy]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first  variable_definition]]
		      [variable_value [second variable_definition]]]
		  [if [get variable_frame contains variable_name]
		      [have new_variable_frame add variable_name [have variable_frame lookup variable_name]]
		    [have new_variable_frame add variable_name variable_value]]]]
	  variables]
    [let [[new_variables [mapcar [funk [variable_name]
				       `[,variable_name ,[have new_variable_frame lookup variable_name]]]
				 [get new_variable_frame keys]]]]
      [mapc [funk [name_pattern]
		  [let [[used_variable_frame [new frame]]]
		    [let [[new_name_expression [get name_pattern pattern_evaluation
						    [funk [variable_name]
							  [have used_variable_frame add variable_name t]
							  [if [get new_variable_frame contains variable_name]
							      [have new_variable_frame lookup variable_name]
							    [error bug_name     new_copy_given_variable_frame-could_not_find_variable_match_in_default_frame
								   this         this
								   name_pattern name_pattern]]]]]]
		      [let [[used_all_nondefault_variables t]]
			[mapc [funk [nondefault_variable_name]
				    [if [not [have used_variable_frame lookup nondefault_variable_name]]
					[= used_all_nondefault_variables nil]]]
			      [get variable_frame keys]]
			[if used_all_nondefault_variables
			    [= new_name_expressions [cons new_name_expression new_name_expressions]]]]]]]
	    name_patterns]
      [if [null new_name_expressions]
	  [error bug_name `nonsemantic_plan-new_copy_given_variable_frame-could_not_generate_new_name
		 this     this
		 variable_frame variable_frame]
	[let [[new_name_expression [car [reverse new_name_expressions]]]]
	  [new nonsemantic_plan
	       mental_layer
	       new_name_expression
	       name_patterns
	       new_variables
	       expression]]]]]]

[deftypefunk nonsemantic_plan get unique_name []
  [if [null internal-unique_name]
      [= internal-unique_name [nonsemantic_plan-unique_name_from_name_expression [get this name_expression]]]]
  internal-unique_name]

[deftypefunk nonsemantic_plan get mind []
  [get mental_layer mind]]

[deftypefunk nonsemantic_plan get name_pattern_match_pairs [expression]
  [let [[name_pattern_matches nil]]
    [mapc [funk [name_pattern]
		[let [[matches [string_pattern-match name_pattern expression]]]
		  [mapc [funk [match]
			      [= name_pattern_matches [cons [cons name_pattern match]
							    name_pattern_matches]]]
			matches]]]
	  name_patterns]
    name_pattern_matches]]

[deftypefunk nonsemantic_plan get sorted_name_pattern_matches [expression]
  [let* [[name_pattern_match_pairs [get this name_pattern_match_pairs expression]]]
    [mapcar [funk [name_pattern_match_pair]
		  [let [[match [cdr name_pattern_match_pair]]]
		    match]]
	    [mapcar [funk [pair]
			  [car pair]]
		    [have [mapcar [funk [name_pattern_match_pair]
					[let [[match [cdr name_pattern_match_pair]]]
					  [cons name_pattern_match_pair [length [get match keys]]]]]
				  name_pattern_match_pairs]
			  sort [funk [x y]
				     [< [cdr x] [cdr y]]]]]]]]


`[deftypefunk nonsemantic_plan get expression-as_natural_language_string [expression]
  [let [[compile_option_frame [frame mode `natural_language]]]
    [get this expression-compile expression compile_option_frame]]]

[deftypefunk nonsemantic_plan get expression-as_natural_language_string [expression]
  '']

`[deftypefunk nonsemantic_plan get as-natural_language_string []
  [if [null internal-natural_language_string]
      [= internal-natural_language_string [get this expression-as_natural_language_string expression]]]
  internal-natural_language_string]

[deftypefunk nonsemantic_plan get as-natural_language_string []
  [if [null internal-natural_language_string]
      [= internal-natural_language_string [name_expression-as-string [get this name_expression]]]]
  internal-natural_language_string]

[deftypefunk nonsemantic_plan get as-string []
  [get this as-natural_language_string]]

[deftypefunk nonsemantic_plan get as-graphviz_label []
  [string-concat '<' [get [get this unique_name] as-string] '>']]

[deftypefunk nonsemantic_plan execute check_exists [semantic_partial_state]
  [let* [[truth_value            [have [get this mental_layer] check_exists semantic_partial_state]]
	 [nonsemantic_plan_value [new nonsemantic_plan_value truth_value]]]
    [have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
    nonsemantic_plan_value]]

[deftypefunk nonsemantic_plan execute imagine_check_exists [semantic_partial_state]
  [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
    [let [[found_event [have [get this mental_layer] imagine_check_exists semantic_partial_state]]]
      [cond [[null found_event]                              [prog [terminal_format standard-terminal '\nnonsemantic_plan: did not find existence event, so using current actual physical knowledge.']
								   [let* [[simple_truth_value [have [get this mental_layer] check_exists semantic_partial_state]]
									  [nonsemantic_plan_value [new nonsemantic_plan_value simple_truth_value]]]
								     [have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
								     [have result_multiple_possible_values add_value nonsemantic_plan_value]]]]
	    [[is-type `multiple_possible_values found_event] [let [[multiple_possible_values found_event]]
							       [mapc [funk [one_found_event]
									   [let* [[simple_truth_value           [not [get one_found_event is_negative_knowledge]]]
										  [nonsemantic_plan_value [new nonsemantic_plan_value simple_truth_value]]]
									     [have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
									     [have result_multiple_possible_values add_value_with_dependency nonsemantic_plan_value [new value_dependency one_found_event multiple_possible_values]]]]
								     [get multiple_possible_values good_values]]]]
	    [t                                               [let* [[simple_truth_value           [not [get found_event is_negative_knowledge]]]
								    [nonsemantic_plan_value [new nonsemantic_plan_value simple_truth_value]]]
							       [have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
							       [have result_multiple_possible_values add_value nonsemantic_plan_value]]]]]
    [let [[outside_hypothesis_space_positive_truth_value [new nonsemantic_plan_value t]]
	  [outside_hypothesis_space_negative_truth_value [new nonsemantic_plan_value nil]]]
      [have outside_hypothesis_space_positive_truth_value add_partial_state_existence_dependency semantic_partial_state]
      [have outside_hypothesis_space_negative_truth_value add_partial_state_existence_dependency semantic_partial_state]
      [have result_multiple_possible_values add_value outside_hypothesis_space_positive_truth_value]
      [have result_multiple_possible_values add_value outside_hypothesis_space_negative_truth_value]
      result_multiple_possible_values]]]

[deftypefunk nonsemantic_plan execute wait_for [semantic_partial_state]
  [have [get this mental_layer] wait_for semantic_partial_state]]

[globalize globalize_plan_bugs_enabled nil]
[globalize plan_bug_count              0]

[deftypefunk nonsemantic_plan execute __execute_funk_as_thought_in_semantic_planner [semantic_planner variable_frame funk args]
  `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.']
  [let [[result [shelter [let* [[semantic_knowledge_base_set [have semantic_planner lookup `semantic_knowledge_base_set]]
				[semantic_knowledge_bases    [get semantic_knowledge_base_set elements]]]
			   [if [null semantic_knowledge_bases]
			       [error funkname `semantic_planner-new_semantic_thought
				      bug_name `semantic_knowledge_bases-is-nil]]
			   
			   [let* [[execute_now-conditionlock   [new conditionlock]]
				  [execute_now                 nil]
				  [thought_fiber               [fiber [funk []
									    
									    [have execute_now-conditionlock lock]
									    [while [not execute_now]
									      [have execute_now-conditionlock wait]]
									    [have execute_now-conditionlock unlock]
									    
									    [cause-define cause-name [get this unique_name]]
									    [apply funk args]]
								      []]]
				  [semantic_thought            [let [[this [new semantic_thought [get semantic_planner semantic_realm]]]]
								 [set this fiber thought_fiber]
								 this]]]
			     
			     [let [[semantic_environment [new semantic_environment [get semantic_planner semantic_realm]]]]
			       [have [get this semantic_plan_object] add_default_frame_to_environment semantic_environment]
			       [mapc [funk [variable_name]
					   [let [[default_variable_value_set [semantic-lookup_set semantic_environment variable variable_name]]]
					     [mapc [funk [default_variable_value]
							 [semantic-remove semantic_environment variable variable_name default_variable_value]]
						   [if default_variable_value_set
						       [get default_variable_value_set elements]
						     nil]]]
					   [semantic-add semantic_environment variable variable_name [have variable_frame lookup variable_name]]]
				     [get variable_frame keys]]
			       [set semantic_thought environment semantic_environment]
			       
			       [mapc [funk [semantic_knowledge_base]
					   [have semantic_knowledge_base add_semantic_frame semantic_environment]
					   [have semantic_knowledge_base add_semantic_frame semantic_thought]]
				     semantic_knowledge_bases]
			       [semantic-add semantic_planner thought semantic_thought]
			       
			       [have [get thought_fiber cause_reg] define `cause-semantic_thought semantic_thought]
			       
			       `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (telling thought_fiber to execute now)']
			       
			       [have execute_now-conditionlock lock]
			       [=    execute_now t]
			       [have execute_now-conditionlock signal]
			       [have execute_now-conditionlock unlock]
			       
			       [let [[fiber_result [fiber-sheltered_join thought_fiber]]]
				 
				 `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (joined thought_fiber)']
				 
				 [semantic-remove semantic_planner thought semantic_thought]
				 [mapc [funk [semantic_knowledge_base]
					     [have semantic_knowledge_base remove_semantic_frame semantic_environment]
					     [have semantic_knowledge_base remove_semantic_frame semantic_thought]]
				       semantic_knowledge_bases]
				 
				 fiber_result]]]]]]]
    [if [is-type `bug result]
	[let [[bug result]]
	  [if globalize_plan_bugs_enabled
	      [let [[global_bug_name [get [string-concat 'plan_bug-' [get plan_bug_count as-string]] as-symbol]]]
		[++ plan_bug_count]
		[terminal_format standard-terminal '\nplan "' [get this as-string] '": globally defining bug as ' global_bug_name '.']
		[eval `[globalize ,global_bug_name [quote ,bug]]]]]
	  [terminal_format standard-terminal '\nnonsemantic_plan: returning bug ' bug]]]
    result]]


[deftypefunk nonsemantic_plan execute lookup_action_below [action_name_expression]
  [have mental_layer lookup_action_below action_name_expression]]

[deftypefunk nonsemantic_plan execute lookup_action [action_name_expression]
  [have mental_layer lookup_action action_name_expression]]





[deftypefunk nonsemantic_plan get expression-compile-symbol [expression compile_option_frame]
  [eval `[funk [this]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `symbol [quote ,expression]]]]
				 [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
				     [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [quote ,expression]]]]]]

[deftypefunk nonsemantic_plan get expression-compile-string [expression compile_option_frame]
  [eval `[funk [nonsemantic_plan]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `string [quote ,expression]]]]
				 [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
				     [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
				   [have semantic_thought evaluate_string ,expression]]]]]]]

[deftypefunk nonsemantic_plan get expression-compile-multiple_possible_values [expression compile_option_frame]
  [eval `[funk [nonsemantic_plan]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `multiple_possible_values [quote ,expression]]]]
				 [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
				     [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
				   [prog @[mapcar [funk [value]
							`[let [[result [shelter [funkall ,[get nonsemantic_plan expression-compile value compile_option_frame] nonsemantic_plan]]]]
							   [if [is-type `bug result]
							       [let [[bug result]]
								 [if [have [get bug frame] lookup `is_plan_bug]
								     [bug bug]
								   [have result_multiple_possible_values add_value_with_dependency result [new value_dependency [quote ,value] [quote ,expression]]]]]]]]
						  [get expression good_values]]]
				   result_multiple_possible_values results]]]]]]

[globalize nonsemantic_plan-command_frame [new frame]]

[deframe nonsemantic_plan_command [frame] [name
					   arguments
					   body
					   arguments_contain_rest
					   minimum_argument_count
					   maximum_argument_count
					   compiled_funk]
  [new [initial-name
	initial-arguments
	initial-body]
       [= name      initial-name]
       [= arguments initial-arguments]
       [= body      initial-body]
       [mapc [funk [argument]
		   [if [eq argument `:rest]
		       [= arguments_contain_rest t]]]
	     arguments]
       [if arguments_contain_rest
	   [prog [= minimum_argument_count [- [length arguments] 2]]
		 [= maximum_argument_count nil]]
	 [prog [= minimum_argument_count [length arguments]]
	       [= maximum_argument_count minimum_argument_count]]]
       [= compiled_funk [eval `[funk [nonsemantic_plan compile_option_frame arguments]
				     [apply [funk ,`[nonsemantic_plan compile_option_frame @arguments]
						  @body]
					    `[,nonsemantic_plan ,compile_option_frame @arguments]]]]]
       ]]

[deftypefunk nonsemantic_plan_command execute compile [nonsemantic_plan compile_option_frame arguments]
  [let [[result [shelter [let [[arguments-length [length arguments]]]
			   [if [or [< arguments-length minimum_argument_count]
				   [and [not [null maximum_argument_count]]
					[> arguments-length maximum_argument_count]]]
			       [error bug_name                      `nonsemantic_plan_compile-wrong_number_of_arguments
				      minimum_argument_count        minimum_argument_count
				      maximum_argument_count        maximum_argument_count
				      nonsemantic_plan_command-name name
				      arguments                     arguments
				      compile_option_frame          compile_option_frame]
			     [apply compiled_funk `[,nonsemantic_plan ,compile_option_frame ,arguments]]]]]]]
    [if [is-type `bug result]
	[let [[bug result]]
	  [error bug_name         `nonsemantic_plan_command-error_compiling_command
		 subbug           bug
		 this             this
		 nonsemantic_plan nonsemantic_plan
		 arguments        arguments]]
      result]]]

[defunk defplancommand-raw [name arguments body]
  [have nonsemantic_plan-command_frame add name [new nonsemantic_plan_command
						     name
						     arguments
						     body]]
  nil]

[defmetro defplancommand [name arguments :rest body]
  [terminal_format standard-terminal '\n' `[defplancommand ,name ,arguments]]
  [defplancommand-raw name arguments `[[with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node [quote ,name] [quote ,arguments]]]]
							 [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
							     [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
							 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
							 @body]]]]]

[defmetro defplanfunk [name arguments :rest body]
  [terminal_format standard-terminal '\n' `[defplanfunk ,name ,arguments]]
  [let [[arguments_without_rest nil]
	[arguments_contain_rest nil]
	[rest_argument          nil]]
    [let [[arguments_iter arguments]]
      [while arguments_iter
	[let [[argument [car arguments_iter]]]
	  [if [eq argument `:rest]
	      [= arguments_contain_rest t]
	    [if arguments_contain_rest
		[if [cdr arguments_iter]
		    [error bug_name  defplanfunk-multiple_rest_arguments_defined
			   name      name
			   arguments arguments]
		  [= rest_argument argument]]
	      [= arguments_without_rest [cons argument arguments_without_rest]]]]]
	[= arguments_iter [cdr arguments_iter]]]
      [= arguments_without_rest [reverse arguments_without_rest]]]
    [let [[planfunk_body `[[with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node [quote ,name] [quote ,arguments]]]]
					     [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
						 [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
					     [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
					     [let ,[append [mapcar [funk [argument]
									 `[,argument `[funkall ,[get nonsemantic_plan expression-compile ,argument compile_option_frame] nonsemantic_plan]]]
								   arguments_without_rest]
							   [if arguments_contain_rest
							       `[[,rest_argument [mapcar [funk [argument]
											       `[funkall ,[get nonsemantic_plan expression-compile argument compile_option_frame] nonsemantic_plan]]
											 ,rest_argument]]]
							     nil]]
					       @body]]]]]]
      [defplancommand-raw name arguments planfunk_body]]]]

[defplancommand eval [expression]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[eval ,expression]]
  [eval `[funk [nonsemantic_plan]
	       [let [[expression [quote ,expression]]]
		 [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' expression '.']
		 ]]]]

[defplancommand quote [expression]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[quote ,expression]]
  [eval `[funk [nonsemantic_plan]
	       [quote ,quote-expression]
	       ]]]

[defplanfunk list [:rest expressions]
  [eval `[funk [nonsemantic_plan]
	       [conslist @expressions]]]]

[defplanfunk backquote-list [:rest expressions]
  [eval `[funk [nonsemantic_plan]
	       [conslist @expressions]]]]

[defplanfunk print [expression]
  [eval `[funk [nonsemantic_plan]
	       [let [[eval-expression ,expression]]
		 [terminal_format standard-terminal '\nimagined plan printing expression: ' eval-expression]
		 eval-expression]]]]

[defplancommand prog [:rest expressions]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[prog @expressions]]
  [eval `[funk [nonsemantic_plan]
	       [terminal_format standard-terminal '\nplan evaluating serial process.']
	       [let [[current_nonsemantic_plan_execution_node  nil]
		     [previous_nonsemantic_plan_execution_node nil]]
		 @[mapcar [funk [expression]
				`[with-new-cause [= previous_nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
						 [= current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `prog-sequence [quote ,expression]]]
						 [if previous_nonsemantic_plan_execution_node
						     [set current_nonsemantic_plan_execution_node previous_node previous_nonsemantic_plan_execution_node]
						   [if [cause-lookup cause-nonsemantic_plan_execution_node]
						       [set cause-nonsemantic_plan_execution_node first_subnode current_nonsemantic_plan_execution_node]]]
						 [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
						     [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
						 [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
						 [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
			  expressions]]]]]

[defplancommand parog [:rest expressions]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[parog @expressions]]
  [eval `[funk [nonsemantic_plan]
	       [terminal_format standard-terminal '\nplan evaluating parallel process.']
	       [parog @[mapcar [funk [expression]
				     `[let [[result [with-new-cause [cause-define cause-imagine_time                                     cause-imagine_time]
								    [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
								    [cause-define cause-imagine_potential_effect_partial_state_set_mutex [new mutex]]
								    [cause-define cause-imagine_potential_effect_partial_state_set       [new set]]
								    [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]]
					[if [is-type `bug result]
					    [let [[bug result]]
					      [if [have [get bug frame] lookup `is_plan_bug]
						  bug
						[bug bug]]]
					  result]]]
			       expressions]]
	       nil]]]

[defplancommand wait-for-time [time_to_wait]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[wait-for-time ,time_to_wait]]
  [eval `[funk [nonsemantic_plan]
	       [let [[time_to_wait ,time_to_wait]]
		 [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan imagining waiting for ' time_to_wait 'time steps.']
		 ]]]]

[defplanfunk call-below [action_name :rest action_arguments]
  [eval `[funk [nonsemantic_plan]
	       [let [[action [have nonsemantic_plan lookup_action_below ,action_name]]]
		 [if [null action]
		     [error bug_name    `nonsemantic_plan-call_below-no_such_action
			    is_plan_bug t
			    action_name ,action_name]
		   [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
			 [have action imagine_waiting_to_call @action_arguments]
			 ]]]]]]

[defplanfunk call [action_name :rest action_arguments]
  [eval `[funk [nonsemantic_plan]
	       [let [[action [have nonsemantic_plan lookup_action ,action_name]]]
		 [if [null action]
		     [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
			    is_plan_bug t
			    action_name ,action_name]
		   [prog [terminal_format standard-terminal '\nplan imagining waiting to call: "' [get action as-string] '."']
			 [have action imagine_waiting_to_call @action_arguments]
			 ]]]]]]

[defplanfunk plan [plan_name]
  [eval `[funk [nonsemantic_plan]
	       [let* [[plan_name                            ,plan_name]
		      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
		      [variable_frame                       [new frame]]
		      [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
		 [if semantic_plan_matches
		     [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
		       [mapc [funk [semantic_plan_match]
				   [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
				   [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
					 [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
					 [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
				     [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
				     [if [null match-semantic_plan_object]
					 [error bug_name    `nonsemantic_plan-plan-no_such_plan
						action_name semantic_plan_object-phenomenal_name]
				       [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
					      [new_nonsemantic_plan   [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
					      [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
					 [have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
			     semantic_plan_matches]
		       result_multiple_possible_values]
		   [error bug_name    `could_not_find_matching_semantic_plans
			  is_plan_bug t
			  funkname    `plan
			  plan_name   plan_name]]]]]]

[defplanfunk plan-below [plan_name]
  [eval `[funk [nonsemantic_plan]
	       [let* [[plan_name                            ,plan_name]
		      [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
		      [variable_frame                       [new frame]]
		      [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
		 [if semantic_plan_matches
		     [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
		       [mapc [funk [semantic_plan_match]
				   [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]]
			     semantic_plan_matches]
		       [mapc [funk [semantic_plan_match]
				   [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
					 [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
					 [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
				     [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
				     [if [null semantic_plan_object]
					 [error bug_name    `nonsemantic_plan-plan-no_such_plan
						action_name semantic_plan_object-phenomenal_name]
				       [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
					      [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
					      [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
					 [have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
			     semantic_plan_matches]
		       result_multiple_possible_values]
		   [error bug_name    `could_not_find_matching_semantic_plans
			  is_plan_bug t
			  funkname    `plan-below
			  plan_name   plan_name]]]]]]

[defplanfunk plan-call [plan]
  [eval `[funk [nonsemantic_plan]
	       [let [[plan ,plan]]
		 [cond [[is-type `nonsemantic_plan_value   plan] [let* [[semantic_plan_object [get plan value]]
									[nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
								   [terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
								   [have nonsemantic_plan imagine_as_thought [frame]]]]
		       [[is-type `multiple_possible_values plan] [let* [[multiple_possible_values        plan]
									[semantic_plan_objects           [get multiple_possible_values good_values]]
									[result_multiple_possible_values [new multiple_possible_values nil]]]
								   [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call ' [length semantic_plan_objects] ' possible plans.']
								   [let [[index 0]]
								     [mapc [funk [nonsemantic_plan_value]
										 [let [[semantic_plan_object [get nonsemantic_plan_value value]]]
										   [= index [+ index 1]]
										   [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call possible plan '
												    index '/' [length semantic_plan_objects] '.']
										   [with-new-cause [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `call-plan-decision [quote ,plan]]]]
												     [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
													 [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
												     [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
												     [let [[nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
												       [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: '
															'attempting to execute plan: "' [get nonsemantic_plan as-string] '"']
												       [let [[result [shelter [have nonsemantic_plan imagine_as_thought [frame]]]]]
													 [if [is-type `bug result]
													     [let [[bug result]]
													       [if [not [have [get bug frame] lookup `is_plan_bug]]
														   [bug bug]
														 [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: found bug executing plan: '
																	'\n  ' bug]
														       [have multiple_possible_values add_value_bug semantic_plan_object bug]]]]
													   [have result_multiple_possible_values add_value_with_dependency result [new value_dependency semantic_plan_object multiple_possible_values]]]]]]]]]
									   semantic_plan_objects]]
								   [if [!= [get result_multiple_possible_values good_value_count] 0]
								       result_multiple_possible_values
								     [error bug_name         `nonsemantic_plan-plan_call-no_possible_results
									    is_plan_bug      t
									    nonsemantic_plan nonsemantic_plan
									    plan             plan]]]]
		       [t                                        [error bug_name `nonsemantic_plan-plan_call-invalid_argument_type
									correct_type `[or `semantic_plan_object multiple_possible_values]
									actual_type  [type plan]
									plan         plan]]]]]]]

[defplanfunk not [truth_value]
  [eval `[funk [nonsemantic_plan]
	       [let [[truth_value ,truth_value]]
		 [cond [[is-type `nonsemantic_plan_value   truth_value] [get truth_value negative]]
		       [[is-type `multiple_possible_values truth_value] [let [[multiple_possible_values        truth_value]
									      [result_multiple_possible_values [new multiple_possible_values nil]]]
									  [mapc [funk [one_truth_value]
										      [have result_multiple_possible_values add_value_with_dependency [get one_truth_value negative] [new value_dependency one_truth_value multiple_possible_values]]]
										[get multiple_possible_values good_values]]
									  result_multiple_possible_values]]
		       [t                                               [error bug_name      `nonsemantic_plan-not-invalid_type
									       correct_types `[nonsemantic_plan_value
											       multiple_possible_values]
									       truth_value   truth_value]]]]]]]

[defplanfunk exists [partial_state]
  [eval `[funk [nonsemantic_plan]
	       [let [[partial_state ,partial_state]]
		 [have nonsemantic_plan imagine_check_exists partial_state]
		 ]]]]

[defplanfunk wait-for [partial_state]
  [eval `[funk [nonsemantic_plan]
	       [let [[partial_state ,partial_state]]
		 [terminal_format standard-terminal '\nplan imagining waiting for: "' [get partial_state as-declarative_natural_language_string] '."  (not yet implemented)']
		 `[have nonsemantic_plan wait_for partial_state]]
	       ]]]

[defplancommand if [condition true_expression :rest false_expressions]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[if ,condition ,true_expression @false_expressions]]
  [let [[condition-eval         `[funkall ,[get nonsemantic_plan expression-compile condition       compile_option_frame] nonsemantic_plan]]
	[true_expression-eval   `[funkall ,[get nonsemantic_plan expression-compile true_expression compile_option_frame] nonsemantic_plan]]
	[false_expressions-eval [mapcar [funk [false_expression]
					      `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]
					false_expressions]]]
    [eval `[funk [nonsemantic_plan]
		 [let [[condition ,condition-eval]]
		   [cond [[is-type `nonsemantic_plan_value   condition] [if [get condition value]
									    [with-new-cause [cause-define cause-last_decision_value condition]
											    [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-true [quote ,true_expression]]]]
											      [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
												  [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
											      [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      ,true_expression-eval]]
									  [with-new-cause [cause-define cause-last_decision_value condition]
											  [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-false [quote ,false_expressions]]]]
											    [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
												[have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
											    [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											    @false_expressions-eval]]]]
			 [[is-type `multiple_possible_values condition] [let* [[multiple_possible_values        condition]
									       [result_multiple_possible_values [new multiple_possible_values nil]]
									       [conditions                      [get multiple_possible_values good_values]]
									       [conditions-length               [length conditions]]
									       [index                           0]]
									  
									  [terminal_format standard-terminal '\nnonsemantic_plan if: considering ' conditions-length ' conditions.']
									  [mapc [funk [one_condition]
										      [++ index]
										      [terminal_format standard-terminal '\nnonsemantic_plan if: considering condition ' index '/' conditions-length ': ' one_condition]
										      [if [get one_condition value]
											  [let [[true_result [shelter [with-new-cause [cause-define cause-last_decision_value one_condition]
																      [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-true [quote ,true_expression]]]]
																	[if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
																	    [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
																	[cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																	,true_expression-eval]]]]]
											    [if [is-type `bug true_result]
												[let [[bug true_result]]
												  [terminal_format standard-terminal '\nnonsemantic_plan if true_result bug: ' bug]
												  [if [not [have [get bug frame] lookup `is_plan_bug]]
												      [bug bug]
												    [have multiple_possible_values add_value_bug one_condition bug]]]
											      [have result_multiple_possible_values add_value_with_dependency true_result [new value_dependency one_condition multiple_possible_values]]]]
											[let [[false_result [shelter [with-new-cause [cause-define cause-last_decision_value one_condition]
																     [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-false [quote ,false_expressions]]]]
																       [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
																	   [have nonsemantic_plan add_imagined_top_execution_node nonsemantic_plan_execution_node]]
																       [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																       @false_expressions-eval]]]]]
											  [if [is-type `bug false_result]
											      [let [[bug false_result]]
												[terminal_format standard-terminal '\nnonsemantic_plan if false_result bug: ' bug]
												[if [not [have [get bug frame] lookup `is_plan_bug]]
												    [bug bug]
												  [have multiple_possible_values add_value_bug one_condition bug]]]
											    [have result_multiple_possible_values add_value_with_dependency false_result [new value_dependency one_condition multiple_possible_values]]]]]]
										[get multiple_possible_values good_values]]
									  
									  [if [== [get result_multiple_possible_values good_value_count] 0]
									      [error bug_name    `if-no_possible_good_results
										     is_plan_bug t
										     expression  [cons `if [cons [quote ,condition]
														 [cons [quote ,true_expression]
														       [conslist @false_expressions]]]]]
									    result_multiple_possible_values]]]
			 [t                                             [error bug_name        `nonsemantic_plan-if-truth_value_must_be_of_type_nonsemantic_plan_value
									       condition       condition
									       quote-condition [quote ,condition]]]]]]]]]

[defplanfunk fail []
  [eval `[funk [nonsemantic_plan]
	       [error bug_name                     `failure
		      is_plan_bug                  t]]]]

[defplancommand ? [variable_name]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[? ,variable_name]]
  [eval `[funk [nonsemantic_plan]
	       [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
		 [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
		 [have semantic_thought lookup_a_variable_value [quote ,variable_name]]
		 ]]]]

[defplanfunk property [source_type
		       source_key_type
		       source_key
		       source_value
		       key_type
		       key
		       value]
  [eval `[funk [nonsemantic_plan]
	       [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
		    ,source_type
		    ,source_key_type
		    ,source_key
		    ,source_value
		    ,key_type
		    ,key
		    ,value]
	       ]]]

[defplanfunk relationship [source_type
			   source_key_type
			   source_key
			   source_value
			   key_type
			   key
			   target_type
			   target_key_type
			   target_key
			   target_value]
  [eval `[funk [nonsemantic_plan]
	       [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
		    ,source_type
		    ,source_key_type
		    ,source_key
		    ,source_value
		    ,key_type
		    ,key
		    ,target_type
		    ,target_key_type
		    ,target_key
		    ,target_value]
	       ]]]

[defplancommand defplan [name_expression :rest arguments]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[defplan ,name_expression @arguments]]
  [let [[name_patterns        nil]
	[variable_definitions nil]
	[plan_body_expression nil]]
    [let [[argument_iter                   arguments]
	  [done_reading_optional_arguments nil]]
      [while [not done_reading_optional_arguments]
	[let [[optional_argument_key [car argument_iter]]]
	  [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
							    [= name_patterns [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
							    [= variable_definitions [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[t                                    [= done_reading_optional_arguments t]]]]]
      [if [== [length argument_iter] 1]
	  [= plan_body_expression [car argument_iter]]
	[= plan_body_expression `[prog @argument_iter]]]]
    [eval `[funk [nonsemantic_plan]
		 [terminal_format standard-terminal '\n' [conslist `defplan [quote ,name_expression]]]
		 [let* [[new_nonsemantic_plan [new nonsemantic_plan [get nonsemantic_plan mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]]
			[new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
		   [have [get nonsemantic_plan mental_layer] add_semantic_plan new_semantic_plan_object]]]]]]



[deftypefunk nonsemantic_plan get expression-compile-cons [expression compile_option_frame]
  [let [[command   [car expression]]
	[arguments [cdr expression]]]
    [let [[nonsemantic_plan_command [have nonsemantic_plan-command_frame lookup command]]]
      [if [not [null nonsemantic_plan_command]]
	  [have nonsemantic_plan_command compile this compile_option_frame arguments]
	[error bug_name   `nonsemantic_plan_compile_error-invalid_command
	       expression expression
	       command    command]]]]]

[deftypefunk nonsemantic_plan execute add_top_execution_node [nonsemantic_plan_execution_node]
  [have top_execution_node_set add nonsemantic_plan_execution_node]]

[deftypefunk nonsemantic_plan execute add_imagined_top_execution_node [nonsemantic_plan_execution_node]
  [have imagined_top_execution_node_set add nonsemantic_plan_execution_node]]

[deftypefunk nonsemantic_plan get expression-compile [expression compile_option_frame]
  [let [[unwrapped_compile_result [cond [[is-type `symbol expression]                   [get this expression-compile-symbol                   expression compile_option_frame]]
					[[is-type `string expression]                   [get this expression-compile-string                   expression compile_option_frame]]
					[[is-type `cons   expression]                   [get this expression-compile-cons                     expression compile_option_frame]]
					[[is-type `multiple_possible_values expression] [get this expression-compile-multiple_possible_values expression compile_option_frame]]
					[t                                              [error bug_name        `nonsemantic_plan_compile_error-invalid_expression_type
											       expression-type [type expression]
											       expression      expression]]]]]
    [eval `[funk [this]
		 [terminal_format standard-terminal '\nnonsemantic_plan imagining executing compiled expression: ' [quote ,expression]]
		 [let [[result [shelter [funkall ,unwrapped_compile_result this]]]]
		   [if [is-type `bug result]
		       [let [[bug result]]
			 [if [have [get bug frame] lookup `is_plan_bug]
			     [bug bug]
			   [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
			     [terminal_format standard-terminal '\nnonsemantic_plan-expression_encountered_bug: ' [quote ,expression]]
			     [error bug_name         `nonsemantic_plan-expression_encountered_bug
				    expression       [quote ,expression]
				    semantic_thought semantic_thought
				    subbug           bug]]]]
		     [prog [terminal_format standard-terminal '\nnonsemantic_plan done imagining executing compiled expression: ' [quote ,expression]]
			   result]]]]]]]

[deftypefunk nonsemantic_plan get __compiled_funk []
  [terminal_format standard-terminal '\nnonsemantic_plan execution not yet supported.']
  [error bug_name `nonsemantic_plan-execution-not-yet-supported
	 this     this]]

[deftypefunk nonsemantic_plan get compiled_funk []
  [if [null internal-compiled_funk]
      [= internal-compiled_funk [let [[result [shelter [get this __compiled_funk]]]]
				  [if [is-type `bug result]
				      [let [[bug result]]
					[error bug_name `nonsemantic_plan-error_compiling_execute_funk
					       subbug   bug
					       this     this]]
				    result]]]]
  internal-compiled_funk]

[deftypefunk nonsemantic_plan execute eval []
  [funkall [get this compiled_funk] this]]

[deftypefunk nonsemantic_plan execute execute_as_thought [variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: executing "' [get this name_expression] '" with ' variable_frame '.']
  [let* [[semantic_planner [get [get this mental_layer] semantic_planner]]
	 [result           [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
				 [funk []
				       [have this eval]]
				 []]]]
    [terminal_format standard-terminal '\nnonsemantic_plan: done executing "' [get this name_expression] '".']
    result]]



[deftypefunk nonsemantic_plan get __compiled_imagine_funk []
  [let [[compile_option_frame [frame mode `imagine]]]
    [get this expression-compile expression compile_option_frame]]]

[deftypefunk nonsemantic_plan get compiled_imagine_funk []
  [if [null internal-compiled_imagine_funk]
      [= internal-compiled_imagine_funk [let [[result [shelter [get this __compiled_imagine_funk]]]]
					  [if [is-type `bug result]
					      [let [[bug result]]
						[error bug_name `nonsemantic_plan-error_compiling_imagine_funk
						       subbug   bug
						       this     this]]
					    result]]]]
  internal-compiled_imagine_funk]

[deftypefunk nonsemantic_plan execute imagine_eval []
  [funkall [get this compiled_imagine_funk] this]]

[deftypefunk nonsemantic_plan execute imagine_as_thought [variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: imagining executing "' [get this name_expression] '" with ' variable_frame '.']
  [with-new-cause [if [null [cause-lookup cause-imagine_time]]
		      [prog [cause-define cause-imagine_time                                     [new semantic_time [time]]]
			    [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
			    [cause-define cause-traced_resource_activation_set                   [new set]]
			    [cause-define cause-last_decision_value                              [new nonsemantic_plan_value `begin-imagine-plan]]
			    ]]
		  [let [[remember_token [new remember_token cause-imagine_time]]]
		    [have [get [get this mental_layer] counterfactual_knowledge_base] add_remember_token remember_token]
		    [let* [[semantic_planner [get [get this mental_layer] semantic_planner]]
			   [result           [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
						   [funk []
							 [have this imagine_eval]]
						   []]]]
		      [mapc [funk [imagined_top_execution_node]
				  [fiber [funk []
					       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: generating execution node graph.']
					       [let [[result [shelter [let [[graph [get imagined_top_execution_node as-graph]]]
									[terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: visualizing execution node graph.']
									[have graph gview]]]]]
						 [if [is-type `bug result]
						     [let [[bug result]]
						       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: bug defined as ' `plan_graph_bug '.']
						       [globalize plan_graph_bug bug]]]]]
					 nil]]
			    [get imagined_top_execution_node_set elements]]
		      [terminal_format standard-terminal '\nnonsemantic_plan: done imagining executing "' [get this name_expression] '".']
		      [have [get [get this mental_layer] counterfactual_knowledge_base] remove_remember_token remember_token]
		      result]]]]




[deftypefunk nonsemantic_plan get __semantic_plan_object []
  [let [[semantic_plan_object [new semantic_plan_object [get [get this mind] semantic_realm] [get this unique_name] this]]]
    [mapc [funk [variable_definition]
		[cond [[is-type `symbol variable_definition] [semantic-add semantic_plan_object default_variable variable_definition nil]]
		      [[is-type `cons   variable_definition] [if [== [length variable_definition] 2]
								 [let [[variable   [first  variable_definition]]
								       [definition [second variable_definition]]]
								   [semantic-add semantic_plan_object default_variable variable definition]]
							       [error bug_name   `invalid_plan_variable_definition
								      expression variable_definition]]]
		      [t                                     [error bug_name `invalid_plan_variable_definitions
								    expression expression]]]]
	  [get this variables]]
    semantic_plan_object]]

[deftypefunk nonsemantic_plan get semantic_plan_object []
  [if [null internal-semantic_plan_object]
      [= internal-semantic_plan_object [get this __semantic_plan_object]]]
  internal-semantic_plan_object]
































































































































`[


[defplancommand eval [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[eval ,expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog ]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    ,expression]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[expression [quote ,expression]]]
							      [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' expression '.']
							      ]]]]
	  [[eq compile-mode `natural_language] 'evaluate funk expression']
	  [[eq compile-mode `semantic]         [semantic_plan_operator_activation-new_with_resource_dependency [get [get nonsemantic_plan mind] semantic_realm] `eval]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand quote [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[quote ,expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog ]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [quote ,expression]
							    ]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [quote ,quote-expression]
							    ]]]
	  [[eq compile-mode `natural_language] [get expression as-string]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand list [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[list @expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expression]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'a list of '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [let [[separator [if [== index 0]
													       ''
													     [if [== index [- expressions-length 1]]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [mapcar [funk [expression]
							     [get nonsemantic_plan expression-compile expression compile_option_frame]]
						       expressions]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand backquote-list [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[backquote-list @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expression]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'a list of '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [let [[separator [if [== index 0]
													       ''
													     [if [== index [- expressions-length 1]]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [mapcar [funk [expression]
							     [get nonsemantic_plan expression-compile expression compile_option_frame]]
						       expressions]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand print [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[print expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile expression compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[eval-expression [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
							      [terminal_format standard-terminal '\nplan printing expression: ' eval-expression]
							      eval-expression]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[eval-expression [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
							      [terminal_format standard-terminal '\nimagined plan printing expression: ' eval-expression]
							      eval-expression]]]]
	  [[eq compile-mode `natural_language] [string-concat 'print ' [get nonsemantic_plan expression-compile expression compile_option_frame]]] 
	  [[eq compile-mode `semantic]         [get nonsemantic_plan expression-compile expression compile_option_frame]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand prog [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[prog @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating serial process.']
							    [let [[current_nonsemantic_plan_execution_node  nil]
								  [previous_nonsemantic_plan_execution_node nil]]
							      @[mapcar [funk [expression]
									     `[with-new-cause [= previous_nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [= current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `prog-sequence [quote ,expression]]]
											      [if previous_nonsemantic_plan_execution_node
												  [set current_nonsemantic_plan_execution_node previous_node previous_nonsemantic_plan_execution_node]
												[if [cause-lookup cause-nonsemantic_plan_execution_node]
												    [set cause-nonsemantic_plan_execution_node first_subnode current_nonsemantic_plan_execution_node]]]
											      [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
								       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating serial process.']
							    [let [[current_nonsemantic_plan_execution_node  nil]
								  [previous_nonsemantic_plan_execution_node nil]]
							      @[mapcar [funk [expression]
									     `[with-new-cause [= previous_nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [= current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `prog-sequence [quote ,expression]]]
											      [if previous_nonsemantic_plan_execution_node
												  [set current_nonsemantic_plan_execution_node previous_node previous_nonsemantic_plan_execution_node]
												[if [cause-lookup cause-nonsemantic_plan_execution_node]
												    [set cause-nonsemantic_plan_execution_node first_subnode current_nonsemantic_plan_execution_node]]]
											      [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
								       expressions]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'do the following in serial: '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [= index [+ index 1]]
											  [let [[separator [if [== index 1]
													       ''
													     [if [== index expressions-length]
														 ', and finally '
													       ', ']]]]
											    [string-concat separator
													   '(' [get index as-string] ') '
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand parog [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[parog @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating parallel process.']
							    [parog @[mapcar [funk [expression]
										  `[let [[result [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
										     [if [is-type `bug result]
											 [let [[bug result]]
											   [if [have [get bug frame] lookup `is_plan_bug]
											       bug
											     [bug bug]]]
										       result]]]
									    expressions]]
							    nil]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating parallel process.']
							    [parog @[mapcar [funk [expression]
										  `[let [[result [with-new-cause [cause-define cause-imagine_time                                     cause-imagine_time]
														 [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
														 [cause-define cause-imagine_potential_effect_partial_state_set_mutex [new mutex]]
														 [cause-define cause-imagine_potential_effect_partial_state_set       [new set]]
														 [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]]
										     [if [is-type `bug result]
											 [let [[bug result]]
											   [if [have [get bug frame] lookup `is_plan_bug]
											       bug
											     [bug bug]]]
										       result]]]
									    expressions]]
							    nil]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'do the following at the same time: '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [= index [+ index 1]]
											  [let [[separator [if [== index 1]
													       ''
													     [if [== index expressions-length]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   '(' [get index as-string] ') '
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand wait-for-time [time_to_wait]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[wait-for-time ,time_to_wait]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [if [not [is-type `integer time_to_wait]]
						   [error bug_name     `nonsemantic_plan-wait_for_time-time_must_be_integer
							  time_to_wait time_to_wait]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[time_to_wait ,time_to_wait]
								  [time_step    [get [get nonsemantic_plan mind] time_step]]]
							      [dotimes [i [+ time_to_wait 1]]
								[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan waiting for time step ' i `/ time_to_wait '.']
								[= time_step [have [get nonsemantic_plan mind] wait_for_time_step [+ time_step 1]]]]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[time_to_wait ,time_to_wait]]
							      [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan imagining waiting for ' time_to_wait 'time steps.']
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat 'wait for ' [get time_to_wait as-string] ' physical world steps']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand call-below [action_name :rest action_arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[call-below ,action_name @action_arguments]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile action_name compile_option_frame]
						     [mapc [funk [action_argument]
								 [get nonsemantic_plan expression-compile action_argument compile_option_frame]]
							   action_arguments]]]
	  [[eq compile-mode `execute]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action_below ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-call_below-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
									[have action wait_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `imagine]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    [cdr arguments]]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action_below ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-call_below-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
									[have action imagine_waiting_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'activate "' [get nonsemantic_plan expression-compile action_name compile_option_frame] '" resource in layer below']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand call [action_name :rest action_arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[call ,action_name @action_arguments]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile action_name compile_option_frame]
						     [mapc [funk [action_argument]
								 [get nonsemantic_plan expression-compile action_argument compile_option_frame]]
							   action_arguments]]]
	  [[eq compile-mode `execute]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
									[have action wait_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `imagine]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan imagining waiting to call: "' [get action as-string] '."']
									[have action imagine_waiting_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'activate "' [get nonsemantic_plan expression-compile action_name compile_option_frame] '" resource in this layer']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan [plan_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan ,plan_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan_name compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null match-semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `imagine]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null match-semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan   [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'a plan in this layer to ' [get nonsemantic_plan expression-compile plan_name compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan-below [plan_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan-below ,plan_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan_name compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan-below
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `imagine]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]]
									    semantic_plan_matches]
								      [mapc [funk [semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan-below
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'a plan in the layer below to ' [get nonsemantic_plan expression-compile plan_name compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan-call [plan]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan-call ,plan]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[plan [funkall ,[get nonsemantic_plan expression-compile plan compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `nonsemantic_plan_value   plan] [let* [[semantic_plan_object [get plan value]]
														     [nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
														[terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
														[have nonsemantic_plan execute_as_thought [frame]]]]
								    [[is-type `multiple_possible_values plan] [let* [[multiple_possible_values        plan]
														     [semantic_plan_objects           [get multiple_possible_values good_values]]
														     [result_multiple_possible_values [new multiple_possible_values nil]]]
														[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call ' [length semantic_plan_objects] ' possible plans.']
														[let [[index 0]]
														  [mapc [funk [nonsemantic_plan_value]
															      [let [[semantic_plan_object [get nonsemantic_plan_value value]]]
																[= index [+ index 1]]
																[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call possible plan '
																		 index '/' [length semantic_plan_objects] '.']
																[with-new-cause [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `call-plan-decision [quote ,plan]]]]
																		  [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																		  [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
																		    [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: '
																				     'attempting to execute plan: "' [get nonsemantic_plan as-string] '"']
																		    [let [[result [shelter [have nonsemantic_plan execute_as_thought [frame]]]]]
																		      [if [is-type `bug result]
																			  [let [[bug result]]
																			    [if [not [have [get bug frame] lookup `is_plan_bug]]
																				[bug bug]
																			      [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: found bug executing plan: '
																						     '\n  ' bug]
																				    [have multiple_possible_values add_value_bug semantic_plan_object bug]]]]
																			[have result_multiple_possible_values add_value_with_dependency result [new value_dependency semantic_plan_object multiple_possible_values]]]]]]]]]
															semantic_plan_objects]]
														[if [!= [get result_multiple_possible_values good_value_count] 0]
														    result_multiple_possible_values
														  [error bug_name         `nonsemantic_plan-plan_call-no_possible_results
															 is_plan_bug      t
															 nonsemantic_plan nonsemantic_plan
															 plan             plan]]]]
								    [t                                        [error bug_name `nonsemantic_plan-plan_call-invalid_argument_type
														     correct_type `[or `semantic_plan_object multiple_possible_values]
														     actual_type  [type plan]
														     plan         plan]]]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[plan [funkall ,[get nonsemantic_plan expression-compile plan compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `nonsemantic_plan_value   plan] [let* [[semantic_plan_object [get plan value]]
														     [nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
														[terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
														[have nonsemantic_plan imagine_as_thought [frame]]]]
								    [[is-type `multiple_possible_values plan] [let* [[multiple_possible_values        plan]
														     [semantic_plan_objects           [get multiple_possible_values good_values]]
														     [result_multiple_possible_values [new multiple_possible_values nil]]]
														[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call ' [length semantic_plan_objects] ' possible plans.']
														[let [[index 0]]
														  [mapc [funk [nonsemantic_plan_value]
															      [let [[semantic_plan_object [get nonsemantic_plan_value value]]]
																[= index [+ index 1]]
																[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call possible plan '
																		 index '/' [length semantic_plan_objects] '.']
																[with-new-cause [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `call-plan-decision [quote ,plan]]]]
																		  [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																		  [let [[nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
																		    [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: '
																				     'attempting to execute plan: "' [get nonsemantic_plan as-string] '"']
																		    [let [[result [shelter [have nonsemantic_plan imagine_as_thought [frame]]]]]
																		      [if [is-type `bug result]
																			  [let [[bug result]]
																			    [if [not [have [get bug frame] lookup `is_plan_bug]]
																				[bug bug]
																			      [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: found bug executing plan: '
																						     '\n  ' bug]
																				    [have multiple_possible_values add_value_bug semantic_plan_object bug]]]]
																			[have result_multiple_possible_values add_value_with_dependency result [new value_dependency semantic_plan_object multiple_possible_values]]]]]]]]]
															semantic_plan_objects]]
														[if [!= [get result_multiple_possible_values good_value_count] 0]
														    result_multiple_possible_values
														  [error bug_name         `nonsemantic_plan-plan_call-no_possible_results
															 is_plan_bug      t
															 nonsemantic_plan nonsemantic_plan
															 plan             plan]]]]
								    [t                                        [error bug_name `nonsemantic_plan-plan_call-invalid_argument_type
														     correct_type `[or `semantic_plan_object multiple_possible_values]
														     actual_type  [type plan]
														     plan         plan]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'call ' [get nonsemantic_plan expression-compile plan compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand not [truth_value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[not ,truth_value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile truth_value compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[truth_value [funkall ,[get nonsemantic_plan expression-compile truth_value compile_option_frame] nonsemantic_plan]]]
							      [if [not [is-type `nonsemantic_plan_value truth_value]]
								  [error bug_name     `nonsemantic_plan-not-truth_value_of_wrong_type
									 correct_type `nonsemantic_plan_value
									 actual_type  [type truth_value]
									 truth_value  truth_value]
								[get truth_value negative]]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[truth_value [funkall ,[get nonsemantic_plan expression-compile truth_value compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `nonsemantic_plan_value   truth_value] [get truth_value negative]]
								    [[is-type `multiple_possible_values truth_value] [let [[multiple_possible_values        truth_value]
															   [result_multiple_possible_values [new multiple_possible_values nil]]]
														       [mapc [funk [one_truth_value]
																   [have result_multiple_possible_values add_value_with_dependency [get one_truth_value negative] [new value_dependency one_truth_value multiple_possible_values]]]
															     [get multiple_possible_values good_values]]
														       result_multiple_possible_values]]
								    [t                                               [error bug_name      `nonsemantic_plan-not-invalid_type
															    correct_types `[nonsemantic_plan_value
																	    multiple_possible_values]
															    truth_value   truth_value]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'not ' [get nonsemantic_plan expression-compile truth_value compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand exists [partial_state]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[exists ,partial_state]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile partial_state compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[partial_state [funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
							      [have nonsemantic_plan check_exists partial_state]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[partial_state [funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
							      [have nonsemantic_plan imagine_check_exists partial_state]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat [get nonsemantic_plan expression-compile partial_state compile_option_frame] ' exists']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand wait-for [partial_state]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[wait-for ,partial_state]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile partial_state compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[partial_state-eval `[funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[partial_state ,partial_state-eval]]
								[terminal_format standard-terminal '\nplan waiting for: "' [get partial_state as-declarative_natural_language_string] '."']
								[have nonsemantic_plan wait_for partial_state]]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[partial_state-eval `[funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[partial_state ,partial_state-eval]]
								[terminal_format standard-terminal '\nplan imagining waiting for: "' [get partial_state as-declarative_natural_language_string] '."  (not yet implemented)']
								`[have nonsemantic_plan wait_for partial_state]]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat 'wait for ' [get nonsemantic_plan expression-compile partial_state compile_option_frame] ' to exist']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand if [condition true_expression :rest false_expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[if ,condition ,true_expression @false_expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile condition       compile_option_frame]
						     [get nonsemantic_plan expression-compile true_expression compile_option_frame]
						     [mapc [funk [false_expression]
								 [get nonsemantic_plan expression-compile false_expression compile_option_frame]]
							   false_expressions]]]
	  [[eq compile-mode `execute]          [let [[condition-eval         `[funkall ,[get nonsemantic_plan expression-compile condition       compile_option_frame] nonsemantic_plan]]
						     [true_expression-eval   `[funkall ,[get nonsemantic_plan expression-compile true_expression compile_option_frame] nonsemantic_plan]]
						     [false_expressions-eval [mapcar [funk [false_expression]
											   `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]
										     false_expressions]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[condition ,condition-eval]]
								[if [not [is-type `nonsemantic_plan_value condition]]
								    [error bug_name        `nonsemantic_plan-if-truth_value_must_be_of_type_nonsemantic_plan_value
									   condition       condition
									   quote-condition [quote ,condition]]
								  [if [get condition value]
								      ,true_expression-eval
								    @false_expressions-eval]]]]]]]
	  [[eq compile-mode `imagine]          [let [[condition-eval         `[funkall ,[get nonsemantic_plan expression-compile condition       compile_option_frame] nonsemantic_plan]]
						     [true_expression-eval   `[funkall ,[get nonsemantic_plan expression-compile true_expression compile_option_frame] nonsemantic_plan]]
						     [false_expressions-eval [mapcar [funk [false_expression]
											   `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]
										     false_expressions]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[condition ,condition-eval]]
								[cond [[is-type `nonsemantic_plan_value   condition] [if [get condition value]
															 [with-new-cause [cause-define cause-last_decision_value condition]
																	 [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-true [quote ,true_expression]]]]
																	   [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																	   ,true_expression-eval]]
														       [with-new-cause [cause-define cause-last_decision_value condition]
																       [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-false [quote ,false_expressions]]]]
																	 [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																	 @false_expressions-eval]]]]
								      [[is-type `multiple_possible_values condition] [let* [[multiple_possible_values        condition]
															    [result_multiple_possible_values [new multiple_possible_values nil]]
															    [conditions                      [get multiple_possible_values good_values]]
															    [conditions-length               [length conditions]]
															    [index                           0]]
														       
														       [terminal_format standard-terminal '\nnonsemantic_plan if: considering ' conditions-length ' conditions.']
														       [mapc [funk [one_condition]
																   [++ index]
																   [terminal_format standard-terminal '\nnonsemantic_plan if: considering condition ' index '/' conditions-length ': ' one_condition]
																   [if [get one_condition value]
																       [let [[true_result [shelter [with-new-cause [cause-define cause-last_decision_value one_condition]
																						   [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-true [quote ,true_expression]]]]
																						     [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																						     ,true_expression-eval]]]]]
																	 [if [is-type `bug true_result]
																	     [let [[bug true_result]]
																	       [terminal_format standard-terminal '\nnonsemantic_plan if true_result bug: ' bug]
																	       [if [not [have [get bug frame] lookup `is_plan_bug]]
																		   [bug bug]
																		 [have multiple_possible_values add_value_bug one_condition bug]]]
																	   [have result_multiple_possible_values add_value_with_dependency true_result [new value_dependency one_condition multiple_possible_values]]]]
																     [let [[false_result [shelter [with-new-cause [cause-define cause-last_decision_value one_condition]
																						  [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-false [quote ,false_expressions]]]]
																						    [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																						    @false_expressions-eval]]]]]
																       [if [is-type `bug false_result]
																	   [let [[bug false_result]]
																	     [terminal_format standard-terminal '\nnonsemantic_plan if false_result bug: ' bug]
																	     [if [not [have [get bug frame] lookup `is_plan_bug]]
																		 [bug bug]
																	       [have multiple_possible_values add_value_bug one_condition bug]]]
																	 [have result_multiple_possible_values add_value_with_dependency false_result [new value_dependency one_condition multiple_possible_values]]]]]]
															     [get multiple_possible_values good_values]]
														       
														       [if [== [get result_multiple_possible_values good_value_count] 0]
															   [error bug_name    `if-no_possible_good_results
																  is_plan_bug t
																  expression  [cons `if [cons [quote ,condition]
																			      [cons [quote ,true_expression]
																				    [conslist @false_expressions]]]]]
															 result_multiple_possible_values]]]
								      [t                                             [error bug_name        `nonsemantic_plan-if-truth_value_must_be_of_type_nonsemantic_plan_value
															    condition       condition
															    quote-condition [quote ,condition]]]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'if ' [get nonsemantic_plan expression-compile condition       compile_option_frame]
							      ', '  [get nonsemantic_plan expression-compile true_expression compile_option_frame]
							      [if false_expressions
								  [string-concat ', otherwise '
										 [stringlist-concat [let [[false_expressions-length [length false_expressions]]
													  [index                    0]]
												      [mapcar [funk [false_expression]
														    [= index [+ index 1]]
														    [let [[separator [if [== index 1]
																	 ''
																       [if [== index false_expressions-length]
																	   ', and '
																	 ', ']]]]
														      [string-concat separator
																     [get nonsemantic_plan expression-compile false_expression compile_option_frame]]]]
													      false_expressions]]]]
								'']]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand fail []
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[fail]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     nil]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [error bug_name                     `failure
								   is_plan_bug                  t]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [error bug_name                     `failure
								   is_plan_bug                  t]]]]
	  [[eq compile-mode `natural_language] 'fail']
	  [[eq compile-mode `semantic]         nil]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand ? [variable_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[? ,variable_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [if [not [is-type `symbol variable_name]]
						   [error bug_name      `nonsemantic_plan-?-variable_name_must_be_symbol
							  variable_name variable_name]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
							      [have semantic_thought lookup_a_variable_value [quote ,variable_name]]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
							      [have semantic_thought lookup_a_variable_value [quote ,variable_name]]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat '[? ' [get variable_name as-string] ']']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand property [source_type
			  source_key_type
			  source_key
			  source_value
			  key_type
			  key
			  value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[property ,source_type
											,source_key_type
											,source_key
											,source_value
											,key_type
											,key
											,value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile source_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile source_value    compile_option_frame]
						     [get nonsemantic_plan expression-compile key_type        compile_option_frame]
						     [get nonsemantic_plan expression-compile key             compile_option_frame]
						     [get nonsemantic_plan expression-compile value           compile_option_frame]]]
	  [[eq compile-mode `execute]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [value-eval           `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile value           compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,value-eval]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [value-eval           `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile value           compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,value-eval]
							      ]]]]
	  [[eq compile-mode `natural_language] [let [[source_type-eval     [get nonsemantic_plan expression-compile source_type     compile_option_frame]]
						     [source_key_type-eval [get nonsemantic_plan expression-compile source_key_type compile_option_frame]]
						     [source_key-eval      [get nonsemantic_plan expression-compile source_key      compile_option_frame]]
						     [source_value-eval    [get nonsemantic_plan expression-compile source_value    compile_option_frame]]
						     [key_type-eval        [get nonsemantic_plan expression-compile key_type        compile_option_frame]]
						     [key-eval             [get nonsemantic_plan expression-compile key             compile_option_frame]]
						     [value-eval           [get nonsemantic_plan expression-compile value           compile_option_frame]]]
						 [get [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
							   source_type-eval0
							   source_key_type-eval
							   source_key-eval
							   source_value-eval
							   key_type-eval
							   key-eval
							   value-eval] as-natural_language_string]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand relationship [source_type
			      source_key_type
			      source_key
			      source_value
			      key_type
			      key
			      target_type
			      target_key_type
			      target_key
			      target_value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[relationship ,source_type
											    ,source_key_type
											    ,source_key
											    ,source_value
											    ,key_type
											    ,key
											    ,target_type
											    ,target_key_type
											    ,target_key
											    ,target_value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile source_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile source_value    compile_option_frame]
						     [get nonsemantic_plan expression-compile key_type        compile_option_frame]
						     [get nonsemantic_plan expression-compile key             compile_option_frame]
						     [get nonsemantic_plan expression-compile target_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile target_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile target_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile target_value    compile_option_frame]]]
	  [[eq compile-mode `execute]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [target_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_type     compile_option_frame] nonsemantic_plan]]]
						     [target_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key_type compile_option_frame] nonsemantic_plan]]]
						     [target_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key      compile_option_frame] nonsemantic_plan]]]
						     [target_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_value    compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,target_type-eval
								   ,target_key_type-eval
								   ,target_key-eval
								   ,target_value-eval]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [target_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_type     compile_option_frame] nonsemantic_plan]]]
						     [target_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key_type compile_option_frame] nonsemantic_plan]]]
						     [target_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key      compile_option_frame] nonsemantic_plan]]]
						     [target_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_value    compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,target_type-eval
								   ,target_key_type-eval
								   ,target_key-eval
								   ,target_value-eval]
							      ]]]]
	  [[eq compile-mode `natural_language] [let [[source_type-eval     [get nonsemantic_plan expression-compile source_type     compile_option_frame]]
						     [source_key_type-eval [get nonsemantic_plan expression-compile source_key_type compile_option_frame]]
						     [source_key-eval      [get nonsemantic_plan expression-compile source_key      compile_option_frame]]
						     [source_value-eval    [get nonsemantic_plan expression-compile source_value    compile_option_frame]]
						     [key_type-eval        [get nonsemantic_plan expression-compile key_type        compile_option_frame]]
						     [key-eval             [get nonsemantic_plan expression-compile key             compile_option_frame]]
						     [target_type-eval     [get nonsemantic_plan expression-compile target_type     compile_option_frame]]
						     [target_key_type-eval [get nonsemantic_plan expression-compile target_key_type compile_option_frame]]
						     [target_key-eval      [get nonsemantic_plan expression-compile target_key      compile_option_frame]]
						     [target_value-eval    [get nonsemantic_plan expression-compile target_value    compile_option_frame]]]
						 [get [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
							   source_type-eval
							   source_key_type-eval
							   source_key-eval
							   source_value-eval
							   key_type-eval
							   key-eval
							   target_type-eval
							   target_key_type-eval
							   target_key-eval
							   target_value-eval] as-natural_language_string]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand defplan [name_expression :rest arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[defplan ,name_expression @arguments]]
  [let [[name_patterns        nil]
	[variable_definitions nil]
	[plan_body_expression nil]]
    [let [[argument_iter                   arguments]
	  [done_reading_optional_arguments nil]]
      [while [not done_reading_optional_arguments]
	[let [[optional_argument_key [car argument_iter]]]
	  [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
							    [= name_patterns [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
							    [= variable_definitions [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[t                                    [= done_reading_optional_arguments t]]]]]
      [if [== [length argument_iter] 1]
	  [= plan_body_expression [car argument_iter]]
	[= plan_body_expression `[prog @argument_iter]]]]
    [let [[compile-mode [have compile_option_frame lookup `mode]]]
      [cond [[eq compile-mode `syntax_check]     [prog ]]
	    [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							      [terminal_format standard-terminal '\n' [conslist `defplan [quote ,name_expression]]]
							      [let* [[new_nonsemantic_plan [new nonsemantic_plan [get nonsemantic_plan mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]]
								     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
								[have [get nonsemantic_plan mental_layer] add_semantic_plan new_semantic_plan_object]]]]]
	    [[eq compile-mode `imagine]          [prog ]]
	    [[eq compile-mode `natural_language] [string-concat 'define a plan to ' [if [is-type `string name_expression]
											name_expression
										      [get name_expression as-string]]]]
	    [[eq compile-mode `semantic]         [prog ]]
	    [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
							compile-mode compile-mode]]]]]]

]