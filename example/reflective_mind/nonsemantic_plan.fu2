'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[defunk name_expression-as-string [this]
  [cond [[is-type `string this] this]
	[t                      [get this as-string]]]]

[defunk name_expression-as-symbol [this]
  [get [name_expression-as-string this] as-symbol]]

[defunk nonsemantic_plan-unique_name_from_name_expression [name_expression]
  [name_expression-as-symbol name_expression]]



'bug'

[deftypefunk bug get as-nonsemantic_plan_execution_node_graph_node [graph node_ptypehash]
  [let [[this-graph_node [have node_ptypehash lookup this]]]
    [if [not this-graph_node]
	[prog [= this-graph_node [new graph_node [format nil 'bug: ' [have [get this frame] lookup `bug_name]]]]
	      [have graph add_node this-graph_node]
	      [have node_ptypehash add this this-graph_node]
	      
	      ]]
    this-graph_node]]



'semantic_plan_operator_activation'

[defunk semantic_plan_operator_activation-new_with_resource_dependency [semantic_realm resource_activation_dependency]
  [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]
	[semantic_counterfactual_transframe [new semantic_counterfactual_transframe semantic_realm]]]
    [set semantic_counterfactual_transframe resource_activation_dependency resource_activation_dependency]
    [set semantic_plan_operator_activation counterfactual_transframe semantic_counterfactual_transframe]
    semantic_plan_operator_activation]]



'nonsemantic_plan_value'

[deframe nonsemantic_plan_value [frame] [value
					 [partial_state_existence_dependency_set [new set]]
					 [dependent_value_set                    [new set]]
					 [value_dependency_set                   [new set]]
					 [cause_execution_node                   nil]]
  [new [initial-value]
       [= value initial-value]
       [if [cause-lookup cause-last_decision_value]
	   [have this add_value_dependency cause-last_decision_value]]
       [if [cause-lookup cause-nonsemantic_plan_execution_node]
	   [= cause_execution_node cause-nonsemantic_plan_execution_node]
	 [error bug_name `nonsemantic_plan_value-not_created_within_causal_scope_of_execution_node
		value    value]]]]

[deftypefunk nonsemantic_plan_value execute add_partial_state_existence_dependency [partial_state]
  [have partial_state_existence_dependency_set add partial_state]]

[deftypefunk nonsemantic_plan_value execute add_value_dependency [nonsemantic_plan_value]
  [have [get nonsemantic_plan_value dependent_value_set] add this]
  [have value_dependency_set                             add nonsemantic_plan_value]]

[deftypefunk nonsemantic_plan_value get partial_state_dependencies []
  [get partial_state_existence_dependency_set elements]]

[deftypefunk nonsemantic_plan_value get negative []
  [let [[new_value [new nonsemantic_plan_value value]]]
    [mapc [funk [partial_state_existence_dependency]
		[have new_value add_partial_state_existence_dependency partial_state_existence_dependency]]
	  [get partial_state_existence_dependency_set elements]]
    [have new_value add_value_dependency this]
    new_value]]

[deftypefunk nonsemantic_plan_value get as-nonsemantic_plan_execution_node_graph_node [graph node_ptypehash]
  [let [[this-graph_node [have node_ptypehash lookup this]]]
    [if [not this-graph_node]
	[prog [= this-graph_node [new graph_node [format nil 'value: ' [type value]]]]
	      [have graph add_node this-graph_node]
	      [have node_ptypehash add this this-graph_node]
	      
	      [let* [[cause_execution_node-graph_node [get cause_execution_node as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
		     [cause_execution_node-graph_edge [new graph_edge `cause_node this-graph_node cause_execution_node-graph_node]]]
		[have graph add_edge cause_execution_node-graph_edge]]
	      
	      [mapc [funk [value_dependency]
			  [let* [[value_dependency-graph_node [get value_dependency as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
				 [value_dependency-graph_edge [new graph_edge `dependency this-graph_node value_dependency-graph_node]]]
			    [have graph add_edge value_dependency-graph_edge]]]
		    [get value_dependency_set elements]]
	      
	      ]]
    this-graph_node]]


'multiple_possible_values'

[deframe multiple_possible_values [frame] [[mutate_mutex [new mutex]]
					   [value_set    [new set]]]
  [new [values]
       [mapc [funk [value]
		   [have this add_value value]]
	     values]]]

[deftypefunk multiple_possible_values get values []
  [get value_set elements]]

[deftypefunk multiple_possible_values get nonbug_values []
  [let [[nonbug_values nil]]
    [mapc [funk [value]
		[if [not [is-type `bug value]]
		    [= nonbug_values [cons value nonbug_values]]]]
	  [get this values]]
    nonbug_values]]

[deftypefunk multiple_possible_values get nonbug_and_failure_values []
  [let [[nonbug_and_failure_values nil]]
    [mapc [funk [value]
		[if [or [not [is-type `bug value]]
			[have [get value frame] lookup `is_plan_failure]]
		    [= nonbug_and_failure_values [cons value nonbug_and_failure_values]]]]
	  [get this values]]
    nonbug_and_failure_values]]

[deftypefunk multiple_possible_values execute add_value [value]
  [cond [[is-type `multiple_possible_values value] [let [[multiple_possible_values value]]
						     [mapc [funk [one_value]
								 [have this add_value one_value]]
							   [get multiple_possible_values values]]]]
	[[is-type `nonsemantic_plan_value   value] [prog [have mutate_mutex lock]
							 [have value_set add value]
							 [have mutate_mutex unlock]]]
	[[is-type `bug                      value] [prog [have mutate_mutex lock]
							 [have value_set add value]
							 [have mutate_mutex unlock]]]
	[t                                         [error bug_name    `multiple_possible_values-add_value-invalid_type
							  valid_types `[multiple_possible_values
									nonsemantic_plan_value
									bug]]]]]

'nonsemantic_plan_execution_node'

[deframe nonsemantic_plan_execution_node [frame] [node_type
						  expression
						  [subnode_set      [new set]]
						  supernode
						  first_subnode
						  previous_node
						  next_node
						  [variable_frame   [new frame]]
						  [return_value_set [new set]]]
  [new [initial-node_type initial-expression]
       [= node_type  initial-node_type]
       [= expression initial-expression]
       [= supernode  [cause-lookup cause-nonsemantic_plan_execution_node]]
       [if supernode
	   [have [get supernode subnode_set] add this]]
       [if [null [cause-lookup cause-nonsemantic_plan_execution_node]]
	   [if [null [cause-lookup cause-nonsemantic_plan_execution_mode]]
	       [error bug_name   `nonsemantic_plan_execution_node-new-nonsemantic_plan_execution_mode-not_defined
		      node_type  node_type
		      expression expression]
	     [cond [[eq cause-nonsemantic_plan_execution_mode `execute] [have cause-top_nonsemantic_plan add_executed_top_execution_node this]]
		   [[eq cause-nonsemantic_plan_execution_mode `imagine] [have cause-top_nonsemantic_plan add_imagined_top_execution_node this]]
		   [t                                                   [error bug_name       `nonsemantic_plan_execution_node-new-invalid_execution_mode
									       execution_mode cause-nonsemantic_plan_execution_mode
									       node_type      node_type
									       expression     expression]]]]]]]

[deftypefunk nonsemantic_plan_execution_node get subnodes []
  [get subnode_set elements]]

[deftypefunk nonsemantic_plan_execution_node get return_values []
  [get return_value_set elements]]

[deftypefunk nonsemantic_plan_execution_node get nonbug_return_values []
  [let [[nonbug_return_values nil]]
    [mapc [funk [return_value]
		[if [not [is-type `bug return_value]]
		    [= nonbug_return_values [cons return_value nonbug_return_values]]]]
	  [get this return_values]]
    nonbug_return_values]]

[deftypefunk nonsemantic_plan_execution_node get nonbug_and_failure_return_values []
  [let [[nonbug_and_failure_return_values nil]]
    [mapc [funk [return_value]
		[if [or [not [is-type `bug return_value]]
			[have [get return_value frame] lookup `is_plan_failure]]
		    [= nonbug_and_failure_return_values [cons return_value nonbug_and_failure_return_values]]]]
	  [get this return_values]]
    nonbug_and_failure_return_values]]

[deftypefunk nonsemantic_plan_execution_node set previous_node [node]
  [if previous_node
      [error bug_name `nonsemantic_plan_execution_node-previous_node_already_defined_for_node
	     this     this
	     node     node]]
  [if [get node next_node]
      [error bug_name `nonsemantic_plan_execution_node-next_node_already_defined_for_node
	     this     this
	     node     node]]
  [= previous_node node]
  [set node next_node this]]

[deftypefunk nonsemantic_plan_execution_node set first_subnode [node]
  [if first_subnode
      [error bug_name `nonsemantic_plan_execution_node-first_subnode_already_defined_for_node
	     this     this
	     node     node]]
  [= first_subnode node]]

[deftypefunk nonsemantic_plan_execution_node execute add_variable_value [variable value]
  [if [get variable_frame contains variable]
      [error bug_name  `nonsemantic_plan_execution_node-variable_already_defined
	     this      this
	     variable  variable
	     old_value [have variable_frame lookup variable]
	     new_value value]
    [have variable_frame add variable value]]]

[deftypefunk nonsemantic_plan_execution_node get variable_value [variable]
  [have variable_frame lookup variable]]

[deftypefunk nonsemantic_plan_execution_node execute add_return_value [value]
  [cond [[is-type `nonsemantic_plan_value   value] [have return_value_set add value]]
	[[is-type `bug                      value] [have return_value_set add value]]
	[[is-type `multiple_possible_values value] [mapc [funk [one_value]
							       [have this add_return_value one_value]]
							 [get value values]]]
	[t                                         [error bug_name    `nonsemantic_plan_execution_node-add_return_value-invalid_type
							  valid_types `[nonsemantic_plan_value
									multiple_possible_values
									bug]
							  actual_type [type value]
							  value       value]]]]

[deftypefunk nonsemantic_plan_execution_node get as-nonsemantic_plan_execution_node_graph_node [graph node_ptypehash]
  [let [[this-graph_node [have node_ptypehash lookup this]]]
    [if [not this-graph_node]
	[prog [= this-graph_node [new graph_node [format nil 'code: ' node_type]]]
	      [have graph add_node this-graph_node]
	      [have node_ptypehash add this this-graph_node]
	      [mapc [funk [subnode]
			  [let* [[subnode-graph_node [get subnode as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
				 [subnode-graph_edge [new graph_edge `subnode this-graph_node subnode-graph_node]]]
			    [have graph add_edge subnode-graph_edge]]]
		    [get subnode_set elements]]
	      [if first_subnode
		  [let* [[first_subnode-graph_node [get first_subnode as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
			 [first_subnode-graph_edge [new graph_edge `first_subnode this-graph_node first_subnode-graph_node]]]
		    [have graph add_edge first_subnode-graph_edge]]]
	      [if next_node
		  [let* [[next_node-graph_node [get next_node as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
			 [next_node-graph_edge [new graph_edge `next_node this-graph_node next_node-graph_node]]]
		    [have graph add_edge next_node-graph_edge]]]
	      [mapc [funk [variable]
			  [let [[value [have variable_frame lookup variable]]]
			    [cond [[is-type `multiple_possible_values value] [let [[multiple_possible_values value]]
									       [mapc [funk [one_value]
											   [let* [[variable_value-graph_node [get one_value as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
												  [variable_value-graph_edge [new graph_edge variable this-graph_node variable_value-graph_node]]]
											     [have graph add_edge variable_value-graph_edge]]]
										     [get multiple_possible_values values]]]]
				  [t                                         [error bug_name      `nonsemantic_plan_execution_node-invalid_variable_value_type
										    correct_types `[multiple_possible_values]
										    actual_type   [type value]
										    value         value]]]]]
		    [get variable_frame keys]]
	      [mapc [funk [return_value]
			  [cond [[is-type `nonsemantic_plan_value   return_value] [let* [[return_value-graph_node [get return_value as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
											 [return_value-graph_edge [new graph_edge `returned_from return_value-graph_node this-graph_node]]]
										    [have graph add_edge return_value-graph_edge]]]
				[[is-type `bug                      return_value] [let* [[return_value-graph_node [get return_value as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
											 [return_value-graph_edge [new graph_edge `returned_from return_value-graph_node this-graph_node]]]
										    [have graph add_edge return_value-graph_edge]]]
				[[is-type `multiple_possible_values return_value] [let [[multiple_possible_values return_value]]
										    [mapc [funk [one_value]
												[let* [[return_value-graph_node [get one_value as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]]
												       [return_value-graph_edge [new graph_edge `returned_from return_value-graph_node this-graph_node]]]
												  [have graph add_edge return_value-graph_edge]]]
											  [get multiple_possible_values values]]]]
				[t                                                [error bug_name      `nonsemantic_plan_execution_node-invalid_return_value_type
											 correct_types `[nonsemantic_plan_value
													 multiple_possible_values]
											 actual_type   [type return_value]
											 return_value  return_value]]]]
		    [get return_value_set elements]]]]
    this-graph_node]]

[deftypefunk nonsemantic_plan_execution_node get as-graph []
  [let [[graph          [new graph]]
	[node_ptypehash [new ptypehash]]]
    [get this as-nonsemantic_plan_execution_node_graph_node graph node_ptypehash]
    graph]]


'nonsemantic_plan'

[deframe nonsemantic_plan [frame] [mental_layer
				   name_expression
				   name_patterns
				   variables
				   expression
				   [internal-default_variable_frame  nil]
				   [internal-unique_name             nil]
				   [internal-semantic_plan_object    nil]
				   [internal-compiled_funk           nil]
				   [internal-compiled_imagine_funk   nil]
				   [internal-natural_language_string nil]
				   [internal-constant_variable_frame nil]
				   [executed_top_execution_node_set  [new set]]
				   [imagined_top_execution_node_set  [new set]]]
  [new [initial-mental_layer
	initial-name_expression
	initial-name_patterns
	initial-variables
	initial-expression]
       [= mental_layer    initial-mental_layer]
       [= name_expression initial-name_expression]
       [= name_patterns   initial-name_patterns]
       [= variables       initial-variables]
       [= expression      initial-expression]]]

[deftypefunk nonsemantic_plan get mental_layer_below []
  [get mental_layer mental_layer_below]]

[deftypefunk nonsemantic_plan get __default_variable_frame []
  [let [[default_variable_frame [new frame]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first variable_definition]]
		      [variable_value [second variable_definition]]]
		  [have default_variable_frame add variable_name variable_value]]]
	  variables]
    default_variable_frame]]

[deftypefunk nonsemantic_plan get default_variable_frame []
  [if [null internal-default_variable_frame]
      [= internal-default_variable_frame [get this __default_variable_frame]]]
  internal-default_variable_frame]

[deftypefunk nonsemantic_plan get new_copy_given_variable_frame [variable_frame]
  [let [[new_name_expressions nil]
	[new_variable_frame   [get variable_frame new_copy]]]
    [mapc [funk [variable_definition]
		[let [[variable_name  [first  variable_definition]]
		      [variable_value [second variable_definition]]]
		  [if [get variable_frame contains variable_name]
		      [have new_variable_frame add variable_name [have variable_frame lookup variable_name]]
		    [have new_variable_frame add variable_name variable_value]]]]
	  variables]
    [let [[new_variables [mapcar [funk [variable_name]
				       `[,variable_name ,[have new_variable_frame lookup variable_name]]]
				 [get new_variable_frame keys]]]]
      [mapc [funk [name_pattern]
		  [let [[used_variable_frame [new frame]]]
		    [let [[new_name_expression [get name_pattern pattern_evaluation
						    [funk [variable_name]
							  [have used_variable_frame add variable_name t]
							  [if [get new_variable_frame contains variable_name]
							      [have new_variable_frame lookup variable_name]
							    [error bug_name     new_copy_given_variable_frame-could_not_find_variable_match_in_default_frame
								   this         this
								   name_pattern name_pattern]]]]]]
		      [let [[used_all_nondefault_variables t]]
			[mapc [funk [nondefault_variable_name]
				    [if [not [have used_variable_frame lookup nondefault_variable_name]]
					[= used_all_nondefault_variables nil]]]
			      [get variable_frame keys]]
			[if used_all_nondefault_variables
			    [= new_name_expressions [cons new_name_expression new_name_expressions]]]]]]]
	    name_patterns]
      [if [null new_name_expressions]
	  [error bug_name `nonsemantic_plan-new_copy_given_variable_frame-could_not_generate_new_name
		 this     this
		 variable_frame variable_frame]
	[let [[new_name_expression [car [reverse new_name_expressions]]]]
	  [new nonsemantic_plan
	       mental_layer
	       new_name_expression
	       name_patterns
	       new_variables
	       expression]]]]]]

[deftypefunk nonsemantic_plan get unique_name []
  [if [null internal-unique_name]
      [= internal-unique_name [nonsemantic_plan-unique_name_from_name_expression [get this name_expression]]]]
  internal-unique_name]

[deftypefunk nonsemantic_plan get mind []
  [get mental_layer mind]]

[deftypefunk nonsemantic_plan get name_pattern_match_pairs [expression]
  [let [[name_pattern_matches nil]]
    [mapc [funk [name_pattern]
		[let [[matches [string_pattern-match name_pattern expression]]]
		  [mapc [funk [match]
			      [= name_pattern_matches [cons [cons name_pattern match]
							    name_pattern_matches]]]
			matches]]]
	  name_patterns]
    name_pattern_matches]]

[deftypefunk nonsemantic_plan get sorted_name_pattern_matches [expression]
  [let* [[name_pattern_match_pairs [get this name_pattern_match_pairs expression]]]
    [mapcar [funk [name_pattern_match_pair]
		  [let [[match [cdr name_pattern_match_pair]]]
		    match]]
	    [mapcar [funk [pair]
			  [car pair]]
		    [have [mapcar [funk [name_pattern_match_pair]
					[let [[match [cdr name_pattern_match_pair]]]
					  [cons name_pattern_match_pair [length [get match keys]]]]]
				  name_pattern_match_pairs]
			  sort [funk [x y]
				     [< [cdr x] [cdr y]]]]]]]]


`[deftypefunk nonsemantic_plan get expression-as_natural_language_string [expression]
  [let [[compile_option_frame [frame mode `natural_language]]]
    [get this expression-compile expression compile_option_frame]]]

[deftypefunk nonsemantic_plan get expression-as_natural_language_string [expression]
  '']

`[deftypefunk nonsemantic_plan get as-natural_language_string []
  [if [null internal-natural_language_string]
      [= internal-natural_language_string [get this expression-as_natural_language_string expression]]]
  internal-natural_language_string]

[deftypefunk nonsemantic_plan get as-natural_language_string []
  [if [null internal-natural_language_string]
      [= internal-natural_language_string [name_expression-as-string [get this name_expression]]]]
  internal-natural_language_string]

[deftypefunk nonsemantic_plan get as-string []
  [get this as-natural_language_string]]

[deftypefunk nonsemantic_plan get as-graphviz_label []
  [string-concat '<' [get [get this unique_name] as-string] '>']]

[deftypefunk nonsemantic_plan execute check_exists [semantic_partial_state]
  [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
    [cond [[eq cause-nonsemantic_plan_execution_mode `execute] [let* [[simple_truth_value     [have [get this mental_layer] check_exists semantic_partial_state]]
								      [nonsemantic_plan_value [new nonsemantic_plan_value simple_truth_value]]]
								 [have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
								 [have result_multiple_possible_values add_value nonsemantic_plan_value]]]
	  [[eq cause-nonsemantic_plan_execution_mode `imagine] [prog [let [[found_event [have [get this mental_layer] imagine_check_exists semantic_partial_state]]]
								       [cond [[null found_event]                              [prog [terminal_format standard-terminal '\nnonsemantic_plan: did not find existence event, so using current actual physical knowledge.']
																    [let* [[simple_truth_value     [have [get this mental_layer] check_exists semantic_partial_state]]
																	   [nonsemantic_plan_value [new nonsemantic_plan_value simple_truth_value]]]
																      [have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
																      [have result_multiple_possible_values add_value nonsemantic_plan_value]]]]
									     [[is-type `multiple_possible_values found_event] [let [[multiple_possible_values found_event]]
																[mapc [funk [one_found_event]
																	    [if [is-type `bug one_found_event]
																		[have result_multiple_possible_values add_value one_found_event]
																	      [let* [[simple_truth_value           [not [get one_found_event is_negative_knowledge]]]
																		     [nonsemantic_plan_value [new nonsemantic_plan_value simple_truth_value]]]
																		[have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
																		[have result_multiple_possible_values add_value nonsemantic_plan_value]]]]
																      [get multiple_possible_values nonbug_and_failure_values]]]]
									     [t                                               [let* [[simple_truth_value           [not [get found_event is_negative_knowledge]]]
																     [nonsemantic_plan_value [new nonsemantic_plan_value simple_truth_value]]]
																[have nonsemantic_plan_value add_partial_state_existence_dependency semantic_partial_state]
																[have result_multiple_possible_values add_value nonsemantic_plan_value]]]]]
								     [let [[outside_hypothesis_space_positive_truth_value [new nonsemantic_plan_value t]]
									   [outside_hypothesis_space_negative_truth_value [new nonsemantic_plan_value nil]]]
								       [have outside_hypothesis_space_positive_truth_value add_partial_state_existence_dependency semantic_partial_state]
								       [have outside_hypothesis_space_negative_truth_value add_partial_state_existence_dependency semantic_partial_state]
								       [have result_multiple_possible_values add_value outside_hypothesis_space_positive_truth_value]
								       [have result_multiple_possible_values add_value outside_hypothesis_space_negative_truth_value]]]]
	  [t                                                   [error bug_name               `nonsemantic_plan-check_exists-invalid_execution_mode
								      execution_mode         cause-nonsemantic_plan_execution_mode
								      semantic_partial_state semantic_partial_state]]]
    result_multiple_possible_values]]]

[deftypefunk nonsemantic_plan execute wait_for [semantic_partial_state]
  [have [get this mental_layer] wait_for semantic_partial_state]]

[globalize globalize_plan_bugs_enabled nil]
[globalize plan_bug_count              0]

[deftypefunk nonsemantic_plan execute __execute_funk_as_thought_in_semantic_planner [semantic_planner variable_frame funk args]
  `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.']
  [let [[result [shelter [let* [[semantic_knowledge_base_set [have semantic_planner lookup `semantic_knowledge_base_set]]
				[semantic_knowledge_bases    [get semantic_knowledge_base_set elements]]]
			   [if [null semantic_knowledge_bases]
			       [error funkname `semantic_planner-new_semantic_thought
				      bug_name `semantic_knowledge_bases-is-nil]]
			   
			   [let* [[execute_now-conditionlock   [new conditionlock]]
				  [execute_now                 nil]
				  [thought_fiber               [fiber [funk []
									    
									    [have execute_now-conditionlock lock]
									    [while [not execute_now]
									      [have execute_now-conditionlock wait]]
									    [have execute_now-conditionlock unlock]
									    
									    [cause-define cause-name [get this unique_name]]
									    [apply funk args]]
								      []]]
				  [semantic_thought            [let [[this [new semantic_thought [get semantic_planner semantic_realm]]]]
								 [set this fiber thought_fiber]
								 this]]]
			     
			     [let [[semantic_environment [new semantic_environment [get semantic_planner semantic_realm]]]]
			       [have [get this semantic_plan_object] add_default_frame_to_environment semantic_environment]
			       [mapc [funk [variable_name]
					   [let [[default_variable_value_set [semantic-lookup_set semantic_environment variable variable_name]]]
					     [mapc [funk [default_variable_value]
							 [semantic-remove semantic_environment variable variable_name default_variable_value]]
						   [if default_variable_value_set
						       [get default_variable_value_set elements]
						     nil]]]
					   [semantic-add semantic_environment variable variable_name [have variable_frame lookup variable_name]]]
				     [get variable_frame keys]]
			       [set semantic_thought environment semantic_environment]
			       
			       [mapc [funk [semantic_knowledge_base]
					   [have semantic_knowledge_base add_semantic_frame semantic_environment]
					   [have semantic_knowledge_base add_semantic_frame semantic_thought]]
				     semantic_knowledge_bases]
			       [semantic-add semantic_planner thought semantic_thought]
			       
			       [have [get thought_fiber cause_reg] define `cause-semantic_thought semantic_thought]
			       
			       `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (telling thought_fiber to execute now)']
			       
			       [have execute_now-conditionlock lock]
			       [=    execute_now t]
			       [have execute_now-conditionlock signal]
			       [have execute_now-conditionlock unlock]
			       
			       [let [[fiber_result [fiber-sheltered_join thought_fiber]]]
				 
				 `[terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (joined thought_fiber)']
				 
				 [semantic-remove semantic_planner thought semantic_thought]
				 [mapc [funk [semantic_knowledge_base]
					     [have semantic_knowledge_base remove_semantic_frame semantic_environment]
					     [have semantic_knowledge_base remove_semantic_frame semantic_thought]]
				       semantic_knowledge_bases]
				 
				 fiber_result]]]]]]]
    [if [is-type `bug result]
	[let [[bug result]]
	  [if globalize_plan_bugs_enabled
	      [let [[global_bug_name [get [string-concat 'plan_bug-' [get plan_bug_count as-string]] as-symbol]]]
		[++ plan_bug_count]
		[terminal_format standard-terminal '\nplan "' [get this as-string] '": globally defining bug as ' global_bug_name '.']
		[eval `[globalize ,global_bug_name [quote ,bug]]]]]
	  [terminal_format standard-terminal '\nnonsemantic_plan: returning bug ' bug]]]
    result]]


[deftypefunk nonsemantic_plan execute lookup_action_below [action_name_expression]
  [have mental_layer lookup_action_below action_name_expression]]

[deftypefunk nonsemantic_plan execute lookup_action [action_name_expression]
  [have mental_layer lookup_action action_name_expression]]


[deftypefunk nonsemantic_plan get layer_knowledge_symbol [value]
  [let [[result [shelter [get [get this mental_layer] knowledge_symbol value]]]]
    [if [is-type `bug result]
	[let [[bug result]]
	  [error bug_name    `nonsemantic_plan-get-knowledge_symbol
		 subbug      bug
		 is_plan_bug t]]
      result]]]




[deftypefunk nonsemantic_plan get expression-compile-nil [expression compile_option_frame]
  [eval `[funk [this]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node nil ,expression]]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [let [[result [new multiple_possible_values [conslist [new nonsemantic_plan_value nil]]]]]
				   [have nonsemantic_plan_execution_node add_return_value result]
				   result]]]]]]

[deftypefunk nonsemantic_plan get expression-compile-integer [expression compile_option_frame]
  [eval `[funk [this]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `integer ,expression]]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [let [[result [new multiple_possible_values [conslist [new nonsemantic_plan_value ,expression]]]]]
				   [have nonsemantic_plan_execution_node add_return_value result]
				   result]]]]]]

[deftypefunk nonsemantic_plan get expression-compile-symbol [expression compile_option_frame]
  [eval `[funk [this]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `symbol [quote ,expression]]]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [let [[result [new multiple_possible_values [conslist [new nonsemantic_plan_value [quote ,expression]]]]]]
				   [have nonsemantic_plan_execution_node add_return_value result]
				   result]]]]]]

[deftypefunk nonsemantic_plan get expression-compile-string [expression compile_option_frame]
  [eval `[funk [nonsemantic_plan]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `string [quote ,expression]]]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
				   [let [[result [new multiple_possible_values [conslist [new nonsemantic_plan_value [have semantic_thought evaluate_string ,expression]]]]]]
				     [have nonsemantic_plan_execution_node add_return_value result]
				     result]]]]]]]

[deftypefunk nonsemantic_plan get expression-compile-multiple_possible_values [expression compile_option_frame]
  [eval `[funk [nonsemantic_plan]
	       [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `multiple_possible_values [quote ,expression]]]]
				 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				 [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
				   [prog @[mapcar [funk [value]
							[if [is-type `bug value]
							    `[have result_multiple_possible_values add_value ,value]
							  `[let [[result [shelter [funkall ,[get nonsemantic_plan expression-compile value compile_option_frame] nonsemantic_plan]]]]
							     [if [is-type `bug result]
								 [let [[bug result]]
								   [if [have [get bug frame] lookup `is_plan_bug]
								       [bug bug]
								     [have result_multiple_possible_values add_value result]]]]]]]
						  [get expression nonbug_and_failure_values]]]
				   [have nonsemantic_plan_execution_node add_return_value result_multiple_possible_values]
				   result_multiple_possible_values]]]]]]

[deftypefunk nonsemantic_plan get expression-compile-cons [expression compile_option_frame]
  [let [[compile_mode [have compile_option_frame lookup `mode]]]
    [let [[command   [car expression]]
	  [arguments [cdr expression]]]
      [let [[nonsemantic_plan_command [have [lookup_nonsemantic_plan_compile_mode compile_mode] lookup_command command]]]
	[if [not [null nonsemantic_plan_command]]
	    [have nonsemantic_plan_command compile this compile_option_frame arguments]
	  [error bug_name   `nonsemantic_plan_compile_error-invalid_command
		 expression expression
		 command    command]]]]]]

[deftypefunk nonsemantic_plan execute add_executed_top_execution_node [nonsemantic_plan_execution_node]
  [have executed_top_execution_node_set add nonsemantic_plan_execution_node]]

[deftypefunk nonsemantic_plan execute add_imagined_top_execution_node [nonsemantic_plan_execution_node]
  [have imagined_top_execution_node_set add nonsemantic_plan_execution_node]]

[globalize imagine_expression_bug_count 0]

[deftypefunk nonsemantic_plan get expression-compile [expression compile_option_frame]
  [let [[unwrapped_compile_result [cond [[null                              expression] [get this expression-compile-nil                      expression compile_option_frame]]
					[[is-type `integer                  expression] [get this expression-compile-integer                  expression compile_option_frame]]
					[[is-type `symbol                   expression] [get this expression-compile-symbol                   expression compile_option_frame]]
					[[is-type `string                   expression] [get this expression-compile-string                   expression compile_option_frame]]
					[[is-type `cons                     expression] [get this expression-compile-cons                     expression compile_option_frame]]
					[[is-type `multiple_possible_values expression] [get this expression-compile-multiple_possible_values expression compile_option_frame]]
					[t                                              [error bug_name        `nonsemantic_plan_compile_error-invalid_expression_type
											       expression-type [type expression]
											       expression      expression]]]]]
    [eval `[funk [this]
		 [terminal_format standard-terminal '\nnonsemantic_plan imagining executing compiled expression: ' [quote ,expression]]
		 [let [[result [shelter [funkall ,unwrapped_compile_result this]]]]
		   [if [is-type `bug result]
		       [let [[bug result]]
			 [if [have [get bug frame] lookup `is_plan_bug]
			     [bug bug]
			   [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
			     [terminal_format standard-terminal '\nnonsemantic_plan-expression_encountered_bug: ' [quote ,expression]]
			     [let [[bug_name [have [get bug frame] lookup `bug_name]]]
			       [if [not [eq bug_name `nonsemantic_plan-expression_encountered_bug]]
				   [let [[global_bug_name [get [string-concat 'imagine_expression_bug-' [get imagine_expression_bug_count as-string]] as-symbol]]]
				     [++ imagine_expression_bug_count]
				     [terminal_format standard-terminal '\nglobally defining bug as ' global_bug_name '.']
				     [eval `[globalize ,global_bug_name [quote ,bug]]]]]
			       [error bug_name         `nonsemantic_plan-expression_encountered_bug
				      expression       [quote ,expression]
				      semantic_thought semantic_thought
				      subbug           bug]]]]]
		     [prog [terminal_format standard-terminal '\nnonsemantic_plan done imagining executing compiled expression: ' [quote ,expression]]
			   [if [not [is-type `multiple_possible_values result]]
			       [error bug_name      `nonsemantic_plan-expression_compile-invalid_return_type
				      correct_types `[multiple_possible_values]
				      actual_type   [type result]
				      result        result
				      expression    expression]
			     result]]]]]]]]

[deftypefunk nonsemantic_plan get __compiled_imagine_funk []
  [let [[compile_option_frame [frame mode `imagine]]]
    [get this expression-compile expression compile_option_frame]]]

[deftypefunk nonsemantic_plan get compiled_imagine_funk []
  [if [null internal-compiled_imagine_funk]
      [= internal-compiled_imagine_funk [let [[result [shelter [get this __compiled_imagine_funk]]]]
					  [if [is-type `bug result]
					      [let [[bug result]]
						[error bug_name `nonsemantic_plan-error_compiling_imagine_funk
						       subbug   bug
						       this     this]]
					    result]]]]
  internal-compiled_imagine_funk]

[deftypefunk nonsemantic_plan execute imagine_eval []
  [funkall [get this compiled_imagine_funk] this]]

[deftypefunk nonsemantic_plan execute imagine_as_thought [variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: imagining executing "' [get this name_expression] '" with ' variable_frame '.']
  [with-new-cause [if [null [cause-lookup cause-top_nonsemantic_plan]]
		      [prog [cause-define cause-top_nonsemantic_plan                             this]
			    [cause-define cause-imagine_time                                     [new semantic_time [time]]]
			    [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
			    [cause-define cause-traced_resource_activation_set                   [new set]]
			    [cause-define cause-nonsemantic_plan_execution_mode                  `imagine]
			    ]]
		  [let [[remember_token [new remember_token cause-imagine_time]]]
		    [have [get [get this mental_layer] counterfactual_knowledge_base] add_remember_token remember_token]
		    [let* [[semantic_planner [get [get this mental_layer] semantic_planner]]
			   [result           [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
						   [funk []
							 [have this imagine_eval]]
						   []]]]
		      [mapc [funk [imagined_top_execution_node]
				  [fiber [funk []
					       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: generating execution node graph.']
					       [let [[result [shelter [let [[graph [get imagined_top_execution_node as-graph]]]
									[terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: visualizing execution node graph.']
									[have graph gview]]]]]
						 [if [is-type `bug result]
						     [let [[bug result]]
						       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: bug defined as ' `plan_graph_bug '.']
						       [globalize plan_graph_bug bug]]]]]
					 nil]]
			    [get imagined_top_execution_node_set elements]]
		      [mapc [funk [imagined_top_execution_node]
				  [terminal_format standard-terminal '\nnonsemantic_plan compiled: ' [get this execution_node_as_code imagined_top_execution_node]]]
			    [get imagined_top_execution_node_set elements]]
		      [terminal_format standard-terminal '\nnonsemantic_plan: done imagining executing "' [get this name_expression] '".']
		      [have [get [get this mental_layer] counterfactual_knowledge_base] remove_remember_token remember_token]
		      result]]]]



[deftypefunk nonsemantic_plan get __compiled_funk []
  [let [[top_nonsemantic_plan_execution_nodes [get imagined_top_execution_node_set elements]]]
    [if [null top_nonsemantic_plan_execution_nodes]
	[prog [have this imagine_eval]
	      [let [[imagined_top_execution_nodes [get imagined_top_execution_node_set elements]]]
		[if [null imagined_top_execution_nodes]
		    [error bug_name `nonsemantic_plan-get-compiled_funk-no_imagined_top_execution_nodes_after_imagine
			   this     this]
		  [= top_nonsemantic_plan_execution_nodes imagined_top_execution_nodes]]]]]
    [let [[top_nonsemantic_plan_execution_node [first top_nonsemantic_plan_execution_nodes]]]
      [let [[execution_code [get this execution_node_as_code top_nonsemantic_plan_execution_node]]]
	[let [[compile_option_frame [frame mode `imagine]]]
	  [get this expression-compile execution_code compile_option_frame]]]]]]

[deftypefunk nonsemantic_plan get compiled_funk []
  [if [null internal-compiled_funk]
      [= internal-compiled_funk [let [[result [shelter [get this __compiled_funk]]]]
				  [if [is-type `bug result]
				      [let [[bug result]]
					[error bug_name `nonsemantic_plan-error_compiling_execute_funk
					       subbug   bug
					       this     this]]
				    result]]]]
  internal-compiled_funk]

[deftypefunk nonsemantic_plan execute eval []
  [funkall [get this compiled_funk] this]]

`[deftypefunk nonsemantic_plan execute execute_as_thought [variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: executing "' [get this name_expression] '" with ' variable_frame '.']
  [let* [[semantic_planner [get [get this mental_layer] semantic_planner]]
	 [result           [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
				 [funk []
				       [have this eval]]
				 []]]]
    [terminal_format standard-terminal '\nnonsemantic_plan: done executing "' [get this name_expression] '".']
    result]]

[deftypefunk nonsemantic_plan execute execute_as_thought [variable_frame]
  [terminal_format standard-terminal '\nnonsemantic_plan: executing "' [get this name_expression] '" with ' variable_frame '.']
  [with-new-cause [if [null [cause-lookup cause-top_nonsemantic_plan]]
		      [prog [cause-define cause-top_nonsemantic_plan                             this]
			    [cause-define cause-imagine_time                                     [new semantic_time [time]]]
			    [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
			    [cause-define cause-traced_resource_activation_set                   [new set]]
			    [cause-define cause-nonsemantic_plan_execution_mode                  `execute]
			    ]]
		  [let [[remember_token [new remember_token cause-imagine_time]]]
		    [have [get [get this mental_layer] counterfactual_knowledge_base] add_remember_token remember_token]
		    [let* [[semantic_planner [get [get this mental_layer] semantic_planner]]
			   [result           [have this __execute_funk_as_thought_in_semantic_planner semantic_planner variable_frame
						   [funk []
							 [have this eval]]
						   []]]]
		      [mapc [funk [executed_top_execution_node]
				  [fiber [funk []
					       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: generating execution node graph.']
					       [let [[result [shelter [let [[graph [get executed_top_execution_node as-graph]]]
									[terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: visualizing execution node graph.']
									[have graph gview]]]]]
						 [if [is-type `bug result]
						     [let [[bug result]]
						       [terminal_format standard-terminal '\n' [get [get this mental_layer] name] ' nonsemantic_plan: bug defined as ' `plan_graph_bug '.']
						       [globalize plan_graph_bug bug]]]]]
					 nil]]
			    [get executed_top_execution_node_set elements]]
		      [mapc [funk [executed_top_execution_node]
				  [terminal_format standard-terminal '\nnonsemantic_plan compiled: ' [get this execution_node_as_code executed_top_execution_node]]]
			    [get executed_top_execution_node_set elements]]
		      [terminal_format standard-terminal '\nnonsemantic_plan: done executing "' [get this name_expression] '".']
		      [have [get [get this mental_layer] counterfactual_knowledge_base] remove_remember_token remember_token]
		      result]]]]






[deftypefunk nonsemantic_plan get __semantic_plan_object []
  [let [[semantic_plan_object [new semantic_plan_object [get [get this mind] semantic_realm] [get this unique_name] this]]]
    [mapc [funk [variable_definition]
		[cond [[is-type `symbol variable_definition] [semantic-add semantic_plan_object default_variable variable_definition nil]]
		      [[is-type `cons   variable_definition] [if [== [length variable_definition] 2]
								 [let [[variable   [first  variable_definition]]
								       [definition [second variable_definition]]]
								   [semantic-add semantic_plan_object default_variable variable definition]]
							       [error bug_name   `invalid_plan_variable_definition
								      expression variable_definition]]]
		      [t                                     [error bug_name `invalid_plan_variable_definitions
								    expression expression]]]]
	  [get this variables]]
    semantic_plan_object]]

[deftypefunk nonsemantic_plan get semantic_plan_object []
  [if [null internal-semantic_plan_object]
      [= internal-semantic_plan_object [get this __semantic_plan_object]]]
  internal-semantic_plan_object]


[defunk remove_equals_duplicates [sequence]
  [let [[equals_hash [new equals_hash]]]
    [mapc [funk [element]
		[have equals_hash add element t]]
	  sequence]
    [get equals_hash keys]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-nil [nonsemantic_plan_execution_node]
  nil]

[deftypefunk nonsemantic_plan get execution_node_as_code-symbol [nonsemantic_plan_execution_node]
  [let [[expression [get nonsemantic_plan_execution_node expression]]]
    expression]]

[deftypefunk nonsemantic_plan get execution_node_as_code-? [nonsemantic_plan_execution_node]
  [let [[nonbug_and_failure_return_values [get nonsemantic_plan_execution_node nonbug_and_failure_return_values]]]
    [terminal_format standard-terminal '\nnonsemantic_plan-get-execution_node_as_code-?: choosing first of ' [length nonbug_and_failure_return_values] ' nonbug return values.']
    [get [first nonbug_and_failure_return_values] value]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-prog [nonsemantic_plan_execution_node]
  [let* [[first_subnode              [get nonsemantic_plan_execution_node first_subnode]]
	 [prog_sequence_subnodes     [cons first_subnode nil]]
	 [prog_sequence_subnode_iter prog_sequence_subnodes]]
    [while prog_sequence_subnode_iter
      [let* [[prog_sequence_subnode   [car prog_sequence_subnode_iter]]
	     [next_node [get prog_sequence_subnode next_node]]
	     [new_cons  nil]]
	[if next_node
	    [prog [= new_cons [cons next_node nil]]
		  [set prog_sequence_subnode_iter cdr new_cons]]]
	[= prog_sequence_subnode_iter new_cons]]]
    `[prog @[mapcar [funk [prog_sequence_subnode]
			  [let [[subnodes [get prog_sequence_subnode subnodes]]]
			    [if [!= [length subnodes] 1]
				[error bug_name                        `nonsemantic_plan-get-execution_node_as_code-prog-must_be_one_subnode
				       subnodes                        subnodes
				       nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
			      [let [[subnode [first subnodes]]]
				[get this execution_node_as_code subnode]]]]]
		    prog_sequence_subnodes]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-parog [nonsemantic_plan_execution_node]
  [let* [[subnodes     [get nonsemantic_plan_execution_node subnodes]]
	 [subnode_iter subnodes]]
    `[parog @[mapcar [funk [subnode]
			   [get this execution_node_as_code subnode]]
		     subnodes]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-call_below [nonsemantic_plan_execution_node]
  [let [[action_name [get nonsemantic_plan_execution_node variable_value `action_name]]]
    [cond [[is-type `multiple_possible_values action_name] [let* [[multiple_possible_values  action_name]
								  [nonbug_and_failure_values [get multiple_possible_values nonbug_and_failure_values]]]
							     [terminal_format standard-terminal '\nnonsemantic_plan-execution_node_as_code-call_below: choosing first of ' [length nonbug_and_failure_values] ' good values for action_name.']
							     [let [[one_value [first nonbug_and_failure_values]]]
							       `[call-below ,[get one_value value]]]]]
	  [t                                               [error bug_name                        `nonsemantic_plan-get-execution_node_as_code-call_below-invalid_type
								  correct_type                    `multiple_possible_values
								  actual_type                     [type action_name]
								  action_name                     action_name
								  nonsemantic_plan_execution_node nonsemantic_plan_execution_node]]]]]

[defunk nonsemantic_plan_remove_fails [sequence]
  [let [[new_sequence nil]]
    [mapc [funk [element]
		[if [not [equals element `[fail]]]
		    [= new_sequence [cons element new_sequence]]]]
	  sequence]
    new_sequence]]

[deftypefunk nonsemantic_plan get execution_node_as_code-plan_call [nonsemantic_plan_execution_node]
  [let [[subnodes                [get nonsemantic_plan_execution_node subnodes]]
	[argument_decision_nodes nil]]
    [mapc [funk [subnode]
		[let [[subnode-node_type [get subnode node_type]]]
		  [if [and [eq subnode-node_type `argument_decision]
			   [not [null [get subnode nonbug_and_failure_return_values]]]]
		      [= argument_decision_nodes [cons subnode argument_decision_nodes]]]]]
	  subnodes]
    [if [null argument_decision_nodes]
	[error bug_name                        `nonsemantic_plan-get-execution_node_as_code-plan_call-no_good_argument_decision_nodes
	       subnodes                        subnodes
	       nonsemantic_plan_execution_node nonsemantic_plan_execution_node
	       this                            this]
      [prog [terminal_format standard-terminal '\nnonsemantic_plan-execution_node_as_code-plan_call: interpretting ' [length argument_decision_nodes] ' argument decision nodes.']
	    [let [[multiple_interpretations [remove_equals_duplicates [mapcar [funk [argument_decision_node]
										    [let [[argument_decision_node-subnodes [get argument_decision_node subnodes]]]
										      [get this execution_node_as_code [first argument_decision_node-subnodes]]]]
									      argument_decision_nodes]]]]
	      [if [== [length multiple_interpretations] 1]
		  [first multiple_interpretations]
		`[multiple_interpretations @multiple_interpretations]]]]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-if [nonsemantic_plan_execution_node]
  [let [[subnodes           [get nonsemantic_plan_execution_node subnodes]]
	[if_condition_nodes nil]
	[if_true_nodes      nil]
	[if_false_nodes     nil]]
    [mapc [funk [subnode]
		[if [get subnode nonbug_and_failure_return_values]
		    [let [[subnode-node_type [get subnode node_type]]]
		      [cond [[eq subnode-node_type `if-condition] [= if_condition_nodes [cons subnode if_condition_nodes]]]
			    [[eq subnode-node_type `if-true]      [= if_true_nodes      [cons subnode if_true_nodes]]]
			    [[eq subnode-node_type `if-false]     [= if_false_nodes     [cons subnode if_false_nodes]]]]]]]
	  subnodes]
    `[terminal_format standard-terminal
		      '\nnonsemantic_plan-get-execution_node_as_code-if: ' [length if_condition_nodes] ' if_condition_nodes = ' if_condition_nodes
		      '\n                                                ' [length if_true_nodes]      ' if_true_nodes      = ' if_true_nodes
		      '\n                                                ' [length if_false_nodes]     ' if_false_nodes     = ' if_false_nodes]
    [let [[if_condition_interpretations [remove_equals_duplicates [mapcar [funk [if_condition_node]
										[get this execution_node_as_code [first [get if_condition_node subnodes]]]]
									  if_condition_nodes]]]
	  [if_true_interpretations      [remove_equals_duplicates [mapcar [funk [if_true_node]
										[get this execution_node_as_code [first [get if_true_node subnodes]]]]
									  if_true_nodes]]]
	  [if_false_interpretations     [remove_equals_duplicates [mapcar [funk [if_false_node]
										[get this execution_node_as_code [first [get if_false_node subnodes]]]]
									  if_false_nodes]]]]
      `[if ,[cond [[null if_condition_interpretations]          [error bug_name `nonsemantic_plan-get-execution_node_as_code-if-if_condition_interpretations_is_null
								       subnodes subnodes]]
		  [[== [length if_condition_interpretations] 1] [first if_condition_interpretations]]
		  [t                                            `[multiple_interpretations @if_condition_interpretations]]]
	   ,[cond [[null if_true_nodes]                         `[fail]]
		  [[== [length if_true_interpretations]      1] [first if_true_interpretations]]
		  [t                                            `[multiple_interpretations @if_true_interpretations]]]
	 @[cond [[null if_false_interpretations]                [conslist `[fail]]]
		[[== [length if_false_interpretations]       1] [conslist [first if_false_interpretations]]]
		[t                                              [conslist `[multiple_interpretations @if_false_interpretations]]]]]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-exists [nonsemantic_plan_execution_node]
  [let [[subnodes           [get nonsemantic_plan_execution_node subnodes]]
	[partial_state_node nil]]
    [mapc [funk [subnode]
		[let [[subnode-node_type [get subnode node_type]]]
		  [if [eq subnode-node_type `partial_state]
		      [if partial_state_node
			  [error bug_name           `nonsemantic_plan-get-execution_node_as_code-exists-more_than_one_partial_state_subnode
				 partial_state_node partial_state_node
				 subnode            subnode
				 this               this]
			[= partial_state_node subnode]]]]]
	  subnodes]
    `[exists ,[get this execution_node_as_code [first [get partial_state_node subnodes]]]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-not [nonsemantic_plan_execution_node]
  [let [[subnodes         [get nonsemantic_plan_execution_node subnodes]]
	[truth_value_node nil]]
    [mapc [funk [subnode]
		[let [[subnode-node_type [get subnode node_type]]]
		  [if [eq subnode-node_type `truth_value]
		      [if truth_value_node
			  [error bug_name         `nonsemantic_plan-get-execution_node_as_code-exists-more_than_one_truth_value_subnode
				 truth_value_node truth_value_node
				 subnode          subnode
				 this             this]
			[= truth_value_node subnode]]]]]
	  subnodes]
    `[not ,[get this execution_node_as_code [first [get truth_value_node subnodes]]]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-property [nonsemantic_plan_execution_node]
  [let [[subnodes           [get nonsemantic_plan_execution_node subnodes]]
	[source_type_node     nil]
	[source_key_type_node nil]
	[source_key_node      nil]
	[source_value_node    nil]
	[key_type_node        nil]
	[key_node             nil]
	[value                nil]]
    [mapc [funk [subnode]
		[let [[subnode-node_type [get subnode node_type]]]
		  [cond [[eq subnode-node_type `source_type]     [= source_type_node     subnode]]
			[[eq subnode-node_type `source_key_type] [= source_key_type_node subnode]]
			[[eq subnode-node_type `source_key]      [= source_key_node      subnode]]
			[[eq subnode-node_type `source_value]    [= source_value_node    subnode]]
			[[eq subnode-node_type `key_type]        [= key_type_node        subnode]]
			[[eq subnode-node_type `key]             [= key_node             subnode]]
			[[eq subnode-node_type `value]           [= value_node           subnode]]]]]
	  subnodes]
    `[property ,[get this execution_node_as_code [first [get source_type_node     subnodes]]]
	       ,[get this execution_node_as_code [first [get source_key_type_node subnodes]]]
	       ,[get this execution_node_as_code [first [get source_key_node      subnodes]]]
	       ,[get this execution_node_as_code [first [get source_value_node    subnodes]]]
	       ,[get this execution_node_as_code [first [get key_type_node        subnodes]]]
	       ,[get this execution_node_as_code [first [get key_node             subnodes]]]
	       ,[get this execution_node_as_code [first [get value_node           subnodes]]]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-relationship [nonsemantic_plan_execution_node]
  [let [[subnodes           [get nonsemantic_plan_execution_node subnodes]]
	[source_type_node     nil]
	[source_key_type_node nil]
	[source_key_node      nil]
	[source_value_node    nil]
	[key_type_node        nil]
	[key_node             nil]
	[target_type_node     nil]
	[target_key_type_node nil]
	[target_key_node      nil]
	[target_value_node    nil]]
    [mapc [funk [subnode]
		[let [[subnode-node_type [get subnode node_type]]]
		  [cond [[eq subnode-node_type `source_type]     [= source_type_node     subnode]]
			[[eq subnode-node_type `source_key_type] [= source_key_type_node subnode]]
			[[eq subnode-node_type `source_key]      [= source_key_node      subnode]]
			[[eq subnode-node_type `source_value]    [= source_value_node    subnode]]
			[[eq subnode-node_type `key_type]        [= key_type_node        subnode]]
			[[eq subnode-node_type `key]             [= key_node             subnode]]
			[[eq subnode-node_type `target_type]     [= target_type_node     subnode]]
			[[eq subnode-node_type `target_key_type] [= target_key_type_node subnode]]
			[[eq subnode-node_type `target_key]      [= target_key_node      subnode]]
			[[eq subnode-node_type `target_value]    [= target_value_node    subnode]]]]]
	  subnodes]
    `[relationship ,[get this execution_node_as_code [first [get source_type_node     subnodes]]]
		   ,[get this execution_node_as_code [first [get source_key_type_node subnodes]]]
		   ,[get this execution_node_as_code [first [get source_key_node      subnodes]]]
		   ,[get this execution_node_as_code [first [get source_value_node    subnodes]]]
		   ,[get this execution_node_as_code [first [get key_type_node        subnodes]]]
		   ,[get this execution_node_as_code [first [get key_node             subnodes]]]
		   ,[get this execution_node_as_code [first [get target_type_node     subnodes]]]
		   ,[get this execution_node_as_code [first [get target_key_type_node subnodes]]]
		   ,[get this execution_node_as_code [first [get target_key_node      subnodes]]]
		   ,[get this execution_node_as_code [first [get target_value_node    subnodes]]]]]]

[deftypefunk nonsemantic_plan get execution_node_as_code-fail [nonsemantic_plan_execution_node]
  `[fail]]

[deftypefunk nonsemantic_plan get execution_node_as_code [nonsemantic_plan_execution_node]
  [let [[result [let [[node_type [get nonsemantic_plan_execution_node node_type]]]
		  [terminal_format standard-terminal '\nnonsemantic_plan-get-execution_node_as_code input node_type: ' node_type]
		  [cond [[null node_type]             [get this execution_node_as_code-nil          nonsemantic_plan_execution_node]]
			[[eq node_type `symbol]       [get this execution_node_as_code-symbol       nonsemantic_plan_execution_node]]
			[[eq node_type `?]            [get this execution_node_as_code-?            nonsemantic_plan_execution_node]]
			[[eq node_type `prog]         [get this execution_node_as_code-prog         nonsemantic_plan_execution_node]]
			[[eq node_type `parog]        [get this execution_node_as_code-parog        nonsemantic_plan_execution_node]]
			[[eq node_type `if]           [get this execution_node_as_code-if           nonsemantic_plan_execution_node]]
			[[eq node_type `call-below]   [get this execution_node_as_code-call_below   nonsemantic_plan_execution_node]]
			[[eq node_type `plan-call]    [get this execution_node_as_code-plan_call    nonsemantic_plan_execution_node]]
			[[eq node_type `not]          [get this execution_node_as_code-not          nonsemantic_plan_execution_node]]
			[[eq node_type `exists]       [get this execution_node_as_code-exists       nonsemantic_plan_execution_node]]
			[[eq node_type `property]     [get this execution_node_as_code-property     nonsemantic_plan_execution_node]]
			[[eq node_type `relationship] [get this execution_node_as_code-relationship nonsemantic_plan_execution_node]]
			[[eq node_type `fail]         [get this execution_node_as_code-fail         nonsemantic_plan_execution_node]]
			[t                            [format nil 'unknown_type: ' node_type]]]]]]
    [terminal_format standard-terminal '\nnonsemantic_plan-get-execution_node_as_node result: ' result]
    result]]




'nonsemantic_plan_compile_mode'

[deframe nonsemantic_plan_compile_mode [frame] [name
						[command_frame [new frame]]]
  [new [initial-name]
       [= name initial-name]]]

[deftypefunk nonsemantic_plan_compile_mode execute add_command [name command]
  [assert-type nonsemantic_plan_command command]
  [have command_frame add name command]]

[deftypefunk nonsemantic_plan_compile_mode execute lookup_command [name]
  [have command_frame lookup name]]


'nonsemantic_plan-command_mode_frame'

[globalize nonsemantic_plan-command_mode_frame [new frame]]

[defunk lookup_nonsemantic_plan_compile_mode [compile_mode_name]
  [let [[compile_mode [have nonsemantic_plan-command_mode_frame lookup compile_mode_name]]]
    [if [null compile_mode]
	[prog [= compile_mode [new nonsemantic_plan_compile_mode compile_mode_name]]
	      [have nonsemantic_plan-command_mode_frame add compile_mode_name compile_mode]]]
    compile_mode]]


'nonsemantic_plan_command'

[deframe nonsemantic_plan_command [frame] [name
					   arguments
					   body
					   arguments_contain_rest
					   minimum_argument_count
					   maximum_argument_count
					   compiled_funk]
  [new [initial-name
	initial-arguments
	initial-body]
       [= name      initial-name]
       [= arguments initial-arguments]
       [= body      initial-body]
       [mapc [funk [argument]
		   [if [eq argument `:rest]
		       [= arguments_contain_rest t]]]
	     arguments]
       [if arguments_contain_rest
	   [prog [= minimum_argument_count [- [length arguments] 2]]
		 [= maximum_argument_count nil]]
	 [prog [= minimum_argument_count [length arguments]]
	       [= maximum_argument_count minimum_argument_count]]]
       [= compiled_funk [eval `[funk [nonsemantic_plan compile_option_frame arguments]
				     [apply [funk ,`[nonsemantic_plan compile_option_frame @arguments]
						  @body]
					    `[,nonsemantic_plan ,compile_option_frame @arguments]]]]]
       ]]

[deftypefunk nonsemantic_plan_command execute compile [nonsemantic_plan compile_option_frame arguments]
  [let [[result [shelter [let [[arguments-length [length arguments]]]
			   [if [or [< arguments-length minimum_argument_count]
				   [and [not [null maximum_argument_count]]
					[> arguments-length maximum_argument_count]]]
			       [error bug_name                      `nonsemantic_plan_compile-wrong_number_of_arguments
				      minimum_argument_count        minimum_argument_count
				      maximum_argument_count        maximum_argument_count
				      nonsemantic_plan_command-name name
				      arguments                     arguments
				      compile_option_frame          compile_option_frame]
			     [apply compiled_funk `[,nonsemantic_plan ,compile_option_frame ,arguments]]]]]]]
    [if [is-type `bug result]
	[let [[bug result]]
	  [error bug_name         `nonsemantic_plan_command-error_compiling_command
		 subbug           bug
		 this             this
		 nonsemantic_plan nonsemantic_plan
		 arguments        arguments]]
      result]]]

[defunk defplancommand-raw [compile_mode name arguments body]
  [cond [[or [eq compile_mode `imagine]
	     [eq compile_mode `execute]] [have [lookup_nonsemantic_plan_compile_mode compile_mode] add_command name [new nonsemantic_plan_command
															 name
															 arguments
															 body]]]
	[t                               [error bug_name `defplancommand-imagine_compile_mode
						compile_mode compile_mode
						name         name
						arguments    arguments]]]
  nil]

[defmetro defplancommand [compile_mode name arguments :rest body]
  [terminal_format standard-terminal '\n' `[defplancommand ,name ,arguments]]
  [defplancommand-raw compile_mode name arguments `[[let [[body_funk [prog @body]]]
						      [eval `[funk [nonsemantic_plan]
								   [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node [quote ,[quote ,name]] [quote ,[quote ,arguments]]]]]
										     [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
										     [let [[result [funkall ,body_funk nonsemantic_plan]]]
										       [have nonsemantic_plan_execution_node add_return_value result]
										       result]]]]]]]]]

[defunk nonsemantic_plan-apply_with_multiple_possible_values [nonsemantic_plan funk_name argument_expressions funk arguments]
  [let* [[result_multiple_possible_values [new multiple_possible_values nil]]
	 [argument_lists                  [mapcar [funk [argument]
							[cond [[is-type `multiple_possible_values argument] [get argument nonbug_and_failure_values]]
							      [t                                            [error bug_name `apply_with_multiple_possible_values-invalid_type
														   correct_type `multiple_possible_values
														   actual_type  [type argument]
														   argument     argument]]]]
						  arguments]]
	 [an_argument_has_zero_values     nil]]
    [mapc [funk [argument_list]
		[if [null argument_list]
		    [= an_argument_has_zero_values t]]]
	  argument_lists]
    [if [not an_argument_has_zero_values]
	[let* [[argument_max_index              [let [[index 0]]
						  [mapcar [funk [argument]
								[let [[result [- [length [get argument_lists elt index]] 1]]]
								  [++ index]
								  result]]
							  arguments]]]
	       [argument_index                  [mapcar [funk [argument]
							      0]
							arguments]]]
	  [let [[done nil]]
	    [while [not done]
	      [terminal_format standard-terminal
			       '\napply: argument_max_index = ' argument_max_index
			       '\n       argument_index     = ' argument_index]
	      [let* [[single_arguments_bugs nil]
		     [single_arguments      [let [[index 0]]
					      [mapcar [funk [argument_list]
							    [let [[result [get argument_list elt [get argument_index elt index]]]]
							      [++ index]
							      [if [is-type `bug result]
								  [= single_arguments_bugs [cons result single_arguments_bugs]]]
							      result]]
						      argument_lists]]]]
		[if single_arguments_bugs
		    [mapc [funk [single_arguments_bug]
				[have nonsemantic_plan_execution_node add_return_value single_arguments_bug]
				[have result_multiple_possible_values add_value        single_arguments_bug]]
			  single_arguments_bugs]
		  [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `argument_decision single_arguments]]]
				    [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
				    [let [[result [shelter [apply funk [cons nonsemantic_plan single_arguments]]]]]
				      [have nonsemantic_plan_execution_node add_return_value result]
				      [have result_multiple_possible_values add_value        result]
				      [if [is-type `bug result]
					  [let [[bug result]]
					    [if [not [have [get bug frame] lookup `is_plan_bug]]
						[bug bug]]]]]]]]
		[let [[argument_list_iter argument_lists]]
		  [let [[argument_list_index  0]
			[successful_increment nil]]
		    [while [and argument_list_iter
				[not successful_increment]]
		      [let [[argument_list             [car argument_list_iter]]
			    [argument_list_index_index [get argument_index elt argument_list_index]]]
			[if [< argument_list_index_index [get argument_max_index elt argument_list_index]]
			    [prog [set argument_index elt argument_list_index [+ argument_list_index_index 1]]
				  [= successful_increment t]]
			  [prog [++ argument_list_index]
				[= argument_list_iter [cdr argument_list_iter]]]]]]
		    [if successful_increment
			[let [[reset_index 0]]
			  [while [< reset_index argument_list_index]
			    [set argument_index elt reset_index 0]
			    [++ reset_index]]]
		      [= done t]]]]]]]]]
    result_multiple_possible_values]]

[defmetro defplanfunk [compile_mode name arguments :rest body]
  [terminal_format standard-terminal '\n' `[defplanfunk ,compile_mode ,name ,arguments]]
  [let [[arguments_without_rest nil]
	[arguments_contain_rest nil]
	[rest_argument          nil]]
    [let [[arguments_iter arguments]]
      [while arguments_iter
	[let [[argument [car arguments_iter]]]
	  [if [eq argument `:rest]
	      [= arguments_contain_rest t]
	    [if arguments_contain_rest
		[if [cdr arguments_iter]
		    [error bug_name  defplanfunk-multiple_rest_arguments_defined
			   name      name
			   arguments arguments]
		  [= rest_argument argument]]
	      [= arguments_without_rest [cons argument arguments_without_rest]]]]]
	[= arguments_iter [cdr arguments_iter]]]
      [= arguments_without_rest [reverse arguments_without_rest]]]
    [cond [[eq compile_mode `imagine] [let [[nonsemantic_plan_value_funk [eval `[funk [nonsemantic_plan @arguments]
										      @body]]]]
					[let [[planfunk_body `[[let [[argument_expanded_codes [append [parcar [funk [argument_code_pair]
														    [let [[argument_name [car argument_code_pair]]
															  [argument_code [cdr argument_code_pair]]]
														      `[with-new-cause [let [[parent_nonsemantic_plan_execution_node cause-nonsemantic_plan_execution_node]
																	     [nonsemantic_plan_execution_node        [new nonsemantic_plan_execution_node [quote ,argument_name] [quote ,argument_code]]]]
																	 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
																	 [let [[result [funkall ,[get nonsemantic_plan expression-compile argument_code compile_option_frame] nonsemantic_plan]]]
																	   [have parent_nonsemantic_plan_execution_node add_variable_value [quote ,argument_name] result]
																	   result]]]]]
													      [conslist @[mapcar [funk [argument]
																       `[cons [quote ,argument] ,argument]]
																 arguments_without_rest]]]
												      ,[if arguments_contain_rest
													   `[let [[index 0]]
													      [parcar [funk [argument_code]
															    [let [[argument_name [get [format nil [quote ,rest_argument] '-' index] as-symbol]]]
															      [++ index]
															      `[with-new-cause [let [[parent_nonsemantic_plan_execution_node cause-nonsemantic_plan_execution_node]
																		     [nonsemantic_plan_execution_node        [new nonsemantic_plan_execution_node [quote ,argument_name] [quote ,argument_code]]]]
																		 [cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
																		 [let [[result [funkall ,[get nonsemantic_plan expression-compile argument_code compile_option_frame] nonsemantic_plan]]]
																		   [have parent_nonsemantic_plan_execution_node add_variable_value [quote ,argument_name] result]
																		   result]]]]]
														      ,rest_argument]]
													 nil]]]]
								 [eval `[funk [nonsemantic_plan]
									      [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node [quote ,[quote ,name]] [quote ,[quote ,arguments]]]]]
												[cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
												[let [[arguments-eval [conslist @argument_expanded_codes]]]
												  [let [[result [nonsemantic_plan-apply_with_multiple_possible_values nonsemantic_plan [quote ,[quote ,name]] [quote ,[quote ,arguments]] ,,nonsemantic_plan_value_funk arguments-eval]]]
												    [have nonsemantic_plan_execution_node add_return_value result]
												    result]]]]]]]]]]
					  [defplancommand-raw compile_mode name arguments planfunk_body]]]]
	  [[eq compile_mode `execute] [let [[nonsemantic_plan_value_funk [eval `[funk [nonsemantic_plan @arguments]
										      @body]]]]
					[let [[planfunk_body `[[let [[argument_expanded_codes [append [parcar [funk [argument_code_pair]
														    [let [[argument_name [car argument_code_pair]]
															  [argument_code [cdr argument_code_pair]]]
														      `[funkall ,[get nonsemantic_plan expression-compile argument_code compile_option_frame] nonsemantic_plan]]]
													      [conslist @[mapcar [funk [argument]
																       `[cons [quote ,argument] ,argument]]
																 arguments_without_rest]]]
												      ,[if arguments_contain_rest
													   `[let [[index 0]]
													      [parcar [funk [argument_code]
															    [let [[argument_name [get [format nil [quote ,rest_argument] '-' index] as-symbol]]]
															      [++ index]
															      `[funkall ,[get nonsemantic_plan expression-compile argument_code compile_option_frame] nonsemantic_plan]]]
														      ,rest_argument]]
													 nil]]]]
								 [eval `[funk [nonsemantic_plan]
									      [let [[arguments-eval [conslist @argument_expanded_codes]]]
										[apply ,,nonsemantic_plan_value_funk [cons nonsemantic_plan arguments-eval]]]]]]]]]
					  [defplancommand-raw compile_mode name arguments planfunk_body]]]]
	  [t                            [error bug_name     `nonsemantic_plan-defplanfunk-invalid_compile_mode
					       compile_mode compile_mode
					       name         name
					       arguments    arguments]]]]]


[defplancommand imagine eval [expression]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling imagine ' `[eval ,expression]]
  [eval `[funk [nonsemantic_plan]
	       [let [[expression [quote ,expression]]]
		 [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' expression '.']
		 [new multiple_possible_values [conslist [new nonsemantic_plan_value nil]]]]]]]

[defplancommand imagine quote [expression]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling imagine ' `[quote ,expression]]
  [eval `[funk [nonsemantic_plan]
	       [new multiple_possible_values [conslist [new nonsemantic_plan_value [quote ,quote-expression]]]]
	       ]]]

[defplancommand imagine prog [:rest expressions]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling imagine ' `[prog @expressions]]
  [eval `[funk [nonsemantic_plan]
	       [terminal_format standard-terminal '\nplan imagining evaluating serial process.']
	       [let [[current_nonsemantic_plan_execution_node  nil]
		     [previous_nonsemantic_plan_execution_node nil]]
		 @[parcar [funk [expression]
				`[with-new-cause [= previous_nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
						 [= current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `prog-sequence [quote ,expression]]]
						 [if previous_nonsemantic_plan_execution_node
						     [set current_nonsemantic_plan_execution_node previous_node previous_nonsemantic_plan_execution_node]
						   [if [cause-lookup cause-nonsemantic_plan_execution_node]
						       [set cause-nonsemantic_plan_execution_node first_subnode current_nonsemantic_plan_execution_node]]]
						 [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
						 [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
			  expressions]]]]]

[defplancommand imagine parog [:rest expressions]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling imagine ' `[parog @expressions]]
  [eval `[funk [nonsemantic_plan]
	       [terminal_format standard-terminal '\nplan imagining evaluating parallel process.']
	       [parog @[parcar [funk [expression]
				     `[let [[result [with-new-cause [cause-define cause-imagine_time                                     cause-imagine_time]
								    [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
								    [cause-define cause-imagine_potential_effect_partial_state_set_mutex [new mutex]]
								    [cause-define cause-imagine_potential_effect_partial_state_set       [new set]]
								    [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]]
					[if [is-type `bug result]
					    [let [[bug result]]
					      [if [have [get bug frame] lookup `is_plan_bug]
						  bug
						[bug bug]]]
					  result]]]
			       expressions]]
	       [new multiple_possible_values [conslist [new nonsemantic_plan_value nil]]]]]]

[defplancommand imagine if [condition true_expression :rest false_expressions]
  [if [> [length false_expressions] 1]
      [error bug_name          `nonsemantic_plan-if-more_than_one_false_expression_given
	     condition         condition
	     true_expression   true_expression
	     false_expressions false_expressions]
    [let [[false_expression [if false_expressions [car false_expressions]]]]
      [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[if ,condition ,true_expression @false_expressions]]
      [let [[condition-eval        `[funkall ,[get nonsemantic_plan expression-compile condition        compile_option_frame] nonsemantic_plan]]
	    [true_expression-eval  `[funkall ,[get nonsemantic_plan expression-compile true_expression  compile_option_frame] nonsemantic_plan]]
	    [false_expression-eval `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]]
	[eval `[funk [nonsemantic_plan]
		     [let [[condition [with-new-cause [let [[nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-condition [quote ,condition]]]]
							[cause-define cause-nonsemantic_plan_execution_node nonsemantic_plan_execution_node]
							[let [[result [shelter ,condition-eval]]]
							  [if [is-type `bug result]
							      [let [[bug result]]
								[terminal_format standard-terminal '\nnonsemantic_plan if true_result bug: ' bug]
								[if [not [have [get bug frame] lookup `is_plan_bug]]
								    [bug bug]]]]
							  [have nonsemantic_plan_execution_node add_return_value result]
							  result]]]]]
		       [let* [[multiple_possible_values        condition]
			      [result_multiple_possible_values [new multiple_possible_values nil]]
			      [conditions                      [get multiple_possible_values values]]
			      [conditions-length               [length conditions]]
			      [index                           0]]
			 [terminal_format standard-terminal '\nnonsemantic_plan if: considering ' conditions-length ' conditions.']
			 [mapc [funk [one_condition]
				     [++ index]
				     [terminal_format standard-terminal '\nnonsemantic_plan if: considering condition ' index '/' conditions-length ': ' `one_condition]
				     [if [is-type `bug one_condition]
					 [prog [have multiple_possible_values        add_value one_condition]
					       [have result_multiple_possible_values add_value one_condition]]
				       [if [get one_condition value]
					   [prog [terminal_format standard-terminal '\nnonsemantic_plan if: condition ' index '/' conditions-length ' is true.']
						 [let [[true_result [with-new-cause [cause-define cause-last_decision_value one_condition]
										    [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-true [quote ,true_expression]]]]
										      [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
										      [let [[result ,true_expression-eval]]
											[have current_nonsemantic_plan_execution_node add_return_value result]
											result]]]]]
						   [if [null [get true_result nonbug_and_failure_values]]
						       [error bug_name    `nonsemantic_plan-if-true_branch_only_has_bug_values
							      is_plan_bug t
							      true_result true_result]]
						   [have multiple_possible_values        add_value true_result]
						   [have result_multiple_possible_values add_value true_result]]]
					 [prog [terminal_format standard-terminal '\nnonsemantic_plan if: condition ' index '/' conditions-length ' is false.']
					       [let [[false_result [with-new-cause [cause-define cause-last_decision_value one_condition]
										   [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-false [quote ,false_expression]]]]
										     [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
										     [let [[result ,false_expression-eval]]
										       [have current_nonsemantic_plan_execution_node add_return_value result]
										       result]]]]]
						 [if [null [get false_result nonbug_and_failure_values]]
						     [error bug_name     `nonsemantic_plan-if-true_branch_only_has_bug_values
							    is_plan_bug  t
							    false_result false_result]]
						 [have multiple_possible_values        add_value false_result]
						 [have result_multiple_possible_values add_value false_result]]]]]]
			       conditions]
			 result_multiple_possible_values]]]]]]]]

[defplancommand imagine ? [variable_name]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[? ,variable_name]]
  [eval `[funk [nonsemantic_plan]
	       [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
		 [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
		 [new multiple_possible_values [conslist [new nonsemantic_plan_value [have semantic_thought lookup_a_variable_value [quote ,variable_name]]]]]
		 ]]]]

[defplancommand imagine defplan [name_expression :rest arguments]
  [terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[defplan ,name_expression @arguments]]
  [let [[name_patterns        nil]
	[variable_definitions nil]
	[plan_body_expression nil]]
    [let [[argument_iter                   arguments]
	  [done_reading_optional_arguments nil]]
      [while [not done_reading_optional_arguments]
	[let [[optional_argument_key [car argument_iter]]]
	  [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
							    [= name_patterns [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
							    [= variable_definitions [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[t                                    [= done_reading_optional_arguments t]]]]]
      [if [== [length argument_iter] 1]
	  [= plan_body_expression [car argument_iter]]
	[= plan_body_expression `[prog @argument_iter]]]]
    [eval `[funk [nonsemantic_plan]
		 [terminal_format standard-terminal '\n' [conslist `defplan [quote ,name_expression]]]
		 [let* [[new_nonsemantic_plan [new nonsemantic_plan [get nonsemantic_plan mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]]
			[new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
		   [have [get nonsemantic_plan mental_layer] add_semantic_plan new_semantic_plan_object]
		   [let [[result [new multiple_possible_values [conslist [new nonsemantic_plan_value nil]]]]]
		     [terminal_format standard-terminal '\n']
		     result]]]]]]

[defplanfunk imagine wait-for-time [time_to_wait]
  [eval `[funk [nonsemantic_plan]
	       [let [[time_to_wait ,time_to_wait]]
		 [cond [[is-type `nonsemantic_plan_value time_to_wait] [let [[time_to_wait [get nonsemantic_plan_value value]]]
									 [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan imagining waiting for ' time_to_wait 'time steps.']
									 [new nonsemantic_plan_value nil]]]
		       [t                                              [error bug_name      `nonsemantic_plan-wait_for_time-invalid_type
									      correct_types `[nonsemantic_plan_value]
									      actual_type   [type time_to_wait]
									      time_to_wait  time_to_wait]]]]]]]

[defplanfunk imagine list [:rest expressions]
  [new multiple_possible_values [conslist [new nonsemantic_plan_value [conslist @expressions]]]]]

[defplanfunk imagine backquote-list [:rest expressions]
  [new multiple_possible_values [conslist [new nonsemantic_plan_value [conslist @expressions]]]]]

[defplanfunk imagine print [expression]
  [terminal_format standard-terminal '\nimagined plan printing expression: ' expression]
  expression]

[defplanfunk imagine call-below [action_name :rest action_arguments]
  [cond [[eq cause-nonsemantic_plan_execution_mode `execute] [let [[action_name [get action_name value]]]
							       [let [[action [have nonsemantic_plan lookup_action_below action_name]]]
								 [if [null action]
								     [error bug_name    `nonsemantic_plan-call_below-no_such_action
									    is_plan_bug t
									    action_name action_name]
								   [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
									 [let [[result [have action wait_to_call [cause-lookup cause-nonsemantic_plan_execution_node] action_arguments]]]
									   [new multiple_possible_values [conslist [new nonsemantic_plan_value result]]]]]]]]]
	[[eq cause-nonsemantic_plan_execution_mode `imagine] [let [[action_name [get action_name value]]]
							       [let [[action [have nonsemantic_plan lookup_action_below action_name]]]
								 [if [null action]
								     [error bug_name    `nonsemantic_plan-call_below-no_such_action
									    is_plan_bug t
									    action_name action_name]
								   [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
									 [let [[result [have action imagine_waiting_to_call [cause-lookup cause-nonsemantic_plan_execution_node] action_arguments]]]
									   [new multiple_possible_values [conslist [new nonsemantic_plan_value result]]]]]]]]]
	[t                                                   [error bug_name         `nonsemantic_plan-call_below-invalid_execution_mode
								    execution_mode   cause-nonsemantic_plan_execution_mode
								    action_name      action_name
								    action_arguments action_arguments]]]]

[defplanfunk imagine call [action_name :rest action_arguments]
  [cond [[eq cause-nonsemantic_plan_execution_mode `execute] [let [[action_name [get action_name value]]]
							       [let [[action [have nonsemantic_plan lookup_action action_name]]]
								 [if [null action]
								     [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									    is_plan_bug t
									    action_name action_name]
								   [prog [terminal_format standard-terminal '\nplan imagining waiting to call: "' [get action as-string] '."']
									 [let [[result [have action wait_to_call [cause-lookup cause-nonsemantic_plan_execution_node] action_arguments]]]
									   [new multiple_possible_values [conslist [new nonsemantic_plan_value result]]]]]]]]]
	[[eq cause-nonsemantic_plan_execution_mode `imagine] [let [[action_name [get action_name value]]]
							       [let [[action [have nonsemantic_plan lookup_action action_name]]]
								 [if [null action]
								     [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									    is_plan_bug t
									    action_name action_name]
								   [prog [terminal_format standard-terminal '\nplan imagining waiting to call: "' [get action as-string] '."']
									 [let [[result [have action imagine_waiting_to_call [cause-lookup cause-nonsemantic_plan_execution_node] action_arguments]]]
									   [new multiple_possible_values [conslist [new nonsemantic_plan_value result]]]]]]]]]
	[t                                                   [error bug_name         `nonsemantic_plan-call-invalid_execution_mode
								    execution_mode   cause-nonsemantic_plan_execution_mode
								    action_name      action_name
								    action_arguments action_arguments]]]]


[defplanfunk imagine plan [plan_name]
  [cond [[is-type `nonsemantic_plan_value plan_name] [let [[plan_name [get plan_name value]]]
						       [let [[semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
							     [variable_frame                       [new frame]]
							     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
							 [if semantic_plan_matches
							     [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
							       [mapc [funk [semantic_plan_match]
									   [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' `semantic_plan_match]
									   [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
										 [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
										 [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
									     [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
									     [if [null match-semantic_plan_object]
										 [error bug_name    `nonsemantic_plan-plan-no_such_plan
											action_name semantic_plan_object-phenomenal_name]
									       [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
										      [new_nonsemantic_plan   [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
										      [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
										 [have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
								     semantic_plan_matches]
							       result_multiple_possible_values]
							   [error bug_name    `could_not_find_matching_semantic_plans
								  is_plan_bug t
								  funkname    `plan
								  plan_name   plan_name]]]]]
	[t                                           [error bug_name `nonsemantic_plan-plan-invalid_type
							    correct_types `[nonsemantic_plan_value]
							    actual_type   [type plan_name]
							    plan_name     plan_name]]]]

[defplanfunk imagine plan-below [plan_name]
  [cond [[is-type `nonsemantic_plan_value plan_name] [let [[plan_name [get plan_name value]]]
						       [let [[semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
							     [variable_frame                       [new frame]]
							     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
							 [if semantic_plan_matches
							     [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
							       [mapc [funk [semantic_plan_match]
									   [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' `semantic_plan_match]]
								     semantic_plan_matches]
							       [mapc [funk [semantic_plan_match]
									   [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
										 [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
										 [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
									     [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
									     [if [null semantic_plan_object]
										 [error bug_name    `nonsemantic_plan-plan-no_such_plan
											action_name semantic_plan_object-phenomenal_name]
									       [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
										      [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
										      [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
										 [have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
								     semantic_plan_matches]
							       result_multiple_possible_values]
							   [error bug_name    `could_not_find_matching_semantic_plans
								  is_plan_bug t
								  funkname    `plan-below
								  plan_name   plan_name]]]]]
	[t                                           [error bug_name `nonsemantic_plan-plan_below-invalid_argument_type
							    correct_types `[nonsemantic_plan_value]
							    actual_type   [type plan_name]
							    plan_name     plan_name]]]]

[defplanfunk imagine plan-call [plan]
  [cond [[is-type `nonsemantic_plan_value plan] [let* [[semantic_plan_object [get plan value]]
						       [nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
						  [terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
						  [have nonsemantic_plan imagine_as_thought [frame]]]]
	[t                                      [error bug_name      `nonsemantic_plan-plan_call-invalid_argument_type
						       correct_types `[semantic_plan_object multiple_possible_values]
						       actual_type   [type plan]
						       plan          plan]]]]

[defplanfunk imagine not [truth_value]
  [cond [[is-type `nonsemantic_plan_value truth_value] [get truth_value negative]]
	[t                                             [error bug_name      `nonsemantic_plan-not-invalid_type
							      correct_types `[nonsemantic_plan_value]
							      truth_value   truth_value]]]]

[defplanfunk imagine exists [partial_state]
  [cond [[is-type `nonsemantic_plan_value partial_state] [let [[partial_state [get partial_state value]]]
							   [have nonsemantic_plan check_exists partial_state]]]
	[t                                               [error bug_name nonsemantic_plan-exists-invalid_type
								correct_types `[nonsemantic_plan_value]
								actual_type   [type partial_state]
								partial_state partial_state]]]]

[defplanfunk imagine wait-for [partial_state]
  [cond [[eq cause-nonsemantic_plan_execution_mode `execute] [prog [terminal_format standard-terminal '\nplan waiting for: "' [get [get partial_state value] as-declarative_natural_language_string] '."']
								   [have nonsemantic_plan wait_for [get partial_state value]]
								   [new multiple_possible_values [conslist [new nonsemantic_plan_value nil]]]]]
	[[eq cause-nonsemantic_plan_execution_mode `imagine] [prog [terminal_format standard-terminal '\nplan imagining waiting for: "' [get [get partial_state value] as-declarative_natural_language_string] '."  (not yet implemented)']
								   [new multiple_possible_values [conslist [new nonsemantic_plan_value nil]]]]]
	[t                                                   [error bug_name         `nonsemantic_plan-wait_for-invalid_execution_mode
								    execution_mode   cause-nonsemantic_plan_execution_mode
								    action_name      action_name
								    action_arguments action_arguments]]]]

[defplanfunk imagine fail []
  [error bug_name        `failure
	 is_plan_bug     t
	 is_plan_failure t]]

[defplanfunk imagine property [source_type
			       source_key_type
			       source_key
			       source_value
			       key_type
			       key
			       value]
  [new nonsemantic_plan_value [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_type     value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_key_type value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_key      value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_value    value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get key_type        value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get key             value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get value           value]]]]]]

[defplanfunk imagine relationship [source_type
				   source_key_type
				   source_key
				   source_value
				   key_type
				   key
				   target_type
				   target_key_type
				   target_key
				   target_value]
  [new nonsemantic_plan_value [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_type     value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_key_type value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_key      value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get source_value    value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get key_type        value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get key             value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get target_type     value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get target_key_type value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get target_key      value]]]
				   [get nonsemantic_plan layer_knowledge_symbol [name_expression-as-symbol [get target_value    value]]]]]]


































































































































`[


[defplancommand eval [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[eval ,expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog ]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    ,expression]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[expression [quote ,expression]]]
							      [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' expression '.']
							      ]]]]
	  [[eq compile-mode `natural_language] 'evaluate funk expression']
	  [[eq compile-mode `semantic]         [semantic_plan_operator_activation-new_with_resource_dependency [get [get nonsemantic_plan mind] semantic_realm] `eval]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand quote [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[quote ,expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog ]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [quote ,expression]
							    ]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [quote ,quote-expression]
							    ]]]
	  [[eq compile-mode `natural_language] [get expression as-string]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand list [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[list @expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expression]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'a list of '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [let [[separator [if [== index 0]
													       ''
													     [if [== index [- expressions-length 1]]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [mapcar [funk [expression]
							     [get nonsemantic_plan expression-compile expression compile_option_frame]]
						       expressions]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand backquote-list [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[backquote-list @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [conslist @[mapcar [funk [expression]
										     `[funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]
									       expression]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'a list of '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [let [[separator [if [== index 0]
													       ''
													     [if [== index [- expressions-length 1]]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [mapcar [funk [expression]
							     [get nonsemantic_plan expression-compile expression compile_option_frame]]
						       expressions]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand print [expression]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[print expression]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile expression compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[eval-expression [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
							      [terminal_format standard-terminal '\nplan printing expression: ' eval-expression]
							      eval-expression]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[eval-expression [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
							      [terminal_format standard-terminal '\nimagined plan printing expression: ' eval-expression]
							      eval-expression]]]]
	  [[eq compile-mode `natural_language] [string-concat 'print ' [get nonsemantic_plan expression-compile expression compile_option_frame]]] 
	  [[eq compile-mode `semantic]         [get nonsemantic_plan expression-compile expression compile_option_frame]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand prog [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[prog @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating serial process.']
							    [let [[current_nonsemantic_plan_execution_node  nil]
								  [previous_nonsemantic_plan_execution_node nil]]
							      @[mapcar [funk [expression]
									     `[with-new-cause [= previous_nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [= current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `prog-sequence [quote ,expression]]]
											      [if previous_nonsemantic_plan_execution_node
												  [set current_nonsemantic_plan_execution_node previous_node previous_nonsemantic_plan_execution_node]
												[if [cause-lookup cause-nonsemantic_plan_execution_node]
												    [set cause-nonsemantic_plan_execution_node first_subnode current_nonsemantic_plan_execution_node]]]
											      [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
								       expressions]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating serial process.']
							    [let [[current_nonsemantic_plan_execution_node  nil]
								  [previous_nonsemantic_plan_execution_node nil]]
							      @[mapcar [funk [expression]
									     `[with-new-cause [= previous_nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [= current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `prog-sequence [quote ,expression]]]
											      [if previous_nonsemantic_plan_execution_node
												  [set current_nonsemantic_plan_execution_node previous_node previous_nonsemantic_plan_execution_node]
												[if [cause-lookup cause-nonsemantic_plan_execution_node]
												    [set cause-nonsemantic_plan_execution_node first_subnode current_nonsemantic_plan_execution_node]]]
											      [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
											      [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
								       expressions]]]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'do the following in serial: '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [= index [+ index 1]]
											  [let [[separator [if [== index 1]
													       ''
													     [if [== index expressions-length]
														 ', and finally '
													       ', ']]]]
											    [string-concat separator
													   '(' [get index as-string] ') '
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand parog [:rest expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[parog @expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [mapc [funk [expression]
							   [get nonsemantic_plan expression-compile expression compile_option_frame]]
						     expressions]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating parallel process.']
							    [parog @[mapcar [funk [expression]
										  `[let [[result [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]
										     [if [is-type `bug result]
											 [let [[bug result]]
											   [if [have [get bug frame] lookup `is_plan_bug]
											       bug
											     [bug bug]]]
										       result]]]
									    expressions]]
							    nil]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [terminal_format standard-terminal '\nplan evaluating parallel process.']
							    [parog @[mapcar [funk [expression]
										  `[let [[result [with-new-cause [cause-define cause-imagine_time                                     cause-imagine_time]
														 [cause-define cause-imagine_semantic_event_tree                      [new semantic_event_tree]]
														 [cause-define cause-imagine_potential_effect_partial_state_set_mutex [new mutex]]
														 [cause-define cause-imagine_potential_effect_partial_state_set       [new set]]
														 [funkall ,[get nonsemantic_plan expression-compile expression compile_option_frame] nonsemantic_plan]]]]
										     [if [is-type `bug result]
											 [let [[bug result]]
											   [if [have [get bug frame] lookup `is_plan_bug]
											       bug
											     [bug bug]]]
										       result]]]
									    expressions]]
							    nil]]]
	  [[eq compile-mode `natural_language] [let [[expressions-length [length expressions]]]
						 [stringlist-concat [cons 'do the following at the same time: '
									  [let [[index 0]]
									    [mapcar [funk [expression]
											  [= index [+ index 1]]
											  [let [[separator [if [== index 1]
													       ''
													     [if [== index expressions-length]
														 ', and '
													       ', ']]]]
											    [string-concat separator
													   '(' [get index as-string] ') '
													   [get nonsemantic_plan expression-compile expression compile_option_frame]]]]
										    expressions]]]]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand wait-for-time [time_to_wait]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[wait-for-time ,time_to_wait]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [if [not [is-type `integer time_to_wait]]
						   [error bug_name     `nonsemantic_plan-wait_for_time-time_must_be_integer
							  time_to_wait time_to_wait]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[time_to_wait ,time_to_wait]
								  [time_step    [get [get nonsemantic_plan mind] time_step]]]
							      [dotimes [i [+ time_to_wait 1]]
								[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan waiting for time step ' i `/ time_to_wait '.']
								[= time_step [have [get nonsemantic_plan mind] wait_for_time_step [+ time_step 1]]]]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[time_to_wait ,time_to_wait]]
							      [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' layer nonsemantic_plan imagining waiting for ' time_to_wait 'time steps.']
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat 'wait for ' [get time_to_wait as-string] ' physical world steps']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand call-below [action_name :rest action_arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[call-below ,action_name @action_arguments]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile action_name compile_option_frame]
						     [mapc [funk [action_argument]
								 [get nonsemantic_plan expression-compile action_argument compile_option_frame]]
							   action_arguments]]]
	  [[eq compile-mode `execute]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action_below ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-call_below-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
									[have action wait_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `imagine]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    [cdr arguments]]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action_below ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-call_below-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
									[have action imagine_waiting_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'activate "' [get nonsemantic_plan expression-compile action_name compile_option_frame] '" resource in layer below']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand call [action_name :rest action_arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[call ,action_name @action_arguments]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile action_name compile_option_frame]
						     [mapc [funk [action_argument]
								 [get nonsemantic_plan expression-compile action_argument compile_option_frame]]
							   action_arguments]]]
	  [[eq compile-mode `execute]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
									[have action wait_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `imagine]          [let [[action_name-eval      `[funkall ,[get nonsemantic_plan expression-compile action_name compile_option_frame] nonsemantic_plan]]
						     [action_arguments-eval [mapcar [funk [action_argument]
											  `[funkall ,[get nonsemantic_plan expression-compile action_argument compile_option_frame] nonsemantic_plan]]
										    action_arguments]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[action [have nonsemantic_plan lookup_action ,action_name-eval]]]
								[if [null action]
								    [error bug_name    `nonsemantic_plan-wait_to_call-no_such_action
									   is_plan_bug t
									   action_name ,action_name-eval]
								  [prog [terminal_format standard-terminal '\nplan imagining waiting to call: "' [get action as-string] '."']
									[have action imagine_waiting_to_call @action_arguments-eval]
									]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'activate "' [get nonsemantic_plan expression-compile action_name compile_option_frame] '" resource in this layer']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan [plan_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan ,plan_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan_name compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null match-semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `imagine]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null match-semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan   [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'a plan in this layer to ' [get nonsemantic_plan expression-compile plan_name compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan-below [plan_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan-below ,plan_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan_name compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan-below
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `imagine]          [let [[plan_name-eval `[funkall ,[get nonsemantic_plan expression-compile plan_name compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let* [[plan_name                            ,plan_name-eval]
								     [semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]
								     [variable_frame                       [new frame]]
								     [semantic_plan_matches                [have [get nonsemantic_plan mental_layer_below] lookup_semantic_plan_matches plan_name]]]
								[if semantic_plan_matches
								    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
								      [mapc [funk [semantic_plan_match]
										  [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan: semantic_plan_match = ' semantic_plan_match]]
									    semantic_plan_matches]
								      [mapc [funk [semantic_plan_match]
										  [let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
											[match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
											[match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
										    [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' variable_frame]
										    [if [null semantic_plan_object]
											[error bug_name    `nonsemantic_plan-plan-no_such_plan
											       action_name semantic_plan_object-phenomenal_name]
										      [let* [[nonsemantic_plan         [get semantic_plan_object nonsemantic_plan]]
											     [new_nonsemantic_plan     [get nonsemantic_plan new_copy_given_variable_frame variable_frame]]
											     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
											[have result_multiple_possible_values add_value [new nonsemantic_plan_value new_semantic_plan_object]]]]]]
									    semantic_plan_matches]
								      result_multiple_possible_values]
								  [error bug_name    `could_not_find_matching_semantic_plans
									 is_plan_bug t
									 funkname    `plan-below
									 plan_name   plan_name]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'a plan in the layer below to ' [get nonsemantic_plan expression-compile plan_name compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand plan-call [plan]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[plan-call ,plan]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile plan compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[plan [funkall ,[get nonsemantic_plan expression-compile plan compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `nonsemantic_plan_value   plan] [let* [[semantic_plan_object [get plan value]]
														     [nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
														[terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
														[have nonsemantic_plan execute_as_thought [frame]]]]
								    [[is-type `multiple_possible_values plan] [let* [[multiple_possible_values        plan]
														     [semantic_plan_objects           [get multiple_possible_values nonbug_values]]
														     [result_multiple_possible_values [new multiple_possible_values nil]]]
														[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call ' [length semantic_plan_objects] ' possible plans.']
														[let [[index 0]]
														  [mapc [funk [nonsemantic_plan_value]
															      [let [[semantic_plan_object [get nonsemantic_plan_value value]]]
																[= index [+ index 1]]
																[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call possible plan '
																		 index '/' [length semantic_plan_objects] '.']
																[with-new-cause [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `call-plan-decision [quote ,plan]]]]
																		  [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																		  [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
																		    [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: '
																				     'attempting to execute plan: "' [get nonsemantic_plan as-string] '"']
																		    [let [[result [shelter [have nonsemantic_plan execute_as_thought [frame]]]]]
																		      [if [is-type `bug result]
																			  [let [[bug result]]
																			    [if [not [have [get bug frame] lookup `is_plan_bug]]
																				[bug bug]
																			      [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: found bug executing plan: '
																						     '\n  ' bug]
																				    [have result_multiple_possible_values add_value bug]]]]
																			[have result_multiple_possible_values add_value_with_dependency result [new value_dependency semantic_plan_object multiple_possible_values]]]]]]]]]
															semantic_plan_objects]]
														[if [get result_multiple_possible_values nonbug_values]
														    result_multiple_possible_values
														  [error bug_name         `nonsemantic_plan-plan_call-no_possible_results
															 is_plan_bug      t
															 nonsemantic_plan nonsemantic_plan
															 plan             plan]]]]
								    [t                                        [error bug_name `nonsemantic_plan-plan_call-invalid_argument_type
														     correct_type `[or `semantic_plan_object multiple_possible_values]
														     actual_type  [type plan]
														     plan         plan]]]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[plan [funkall ,[get nonsemantic_plan expression-compile plan compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `nonsemantic_plan_value   plan] [let* [[semantic_plan_object [get plan value]]
														     [nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
														[terminal_format standard-terminal '\nexecuting plan: "' [get nonsemantic_plan as-string] '"']
														[have nonsemantic_plan imagine_as_thought [frame]]]]
								    [[is-type `multiple_possible_values plan] [let* [[multiple_possible_values        plan]
														     [semantic_plan_objects           [get multiple_possible_values nonbug_values]]
														     [result_multiple_possible_values [new multiple_possible_values nil]]]
														[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call ' [length semantic_plan_objects] ' possible plans.']
														[let [[index 0]]
														  [mapc [funk [nonsemantic_plan_value]
															      [let [[semantic_plan_object [get nonsemantic_plan_value value]]]
																[= index [+ index 1]]
																[terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: attempting to call possible plan '
																		 index '/' [length semantic_plan_objects] '.']
																[with-new-cause [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `call-plan-decision [quote ,plan]]]]
																		  [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																		  [let [[nonsemantic_plan     [get semantic_plan_object nonsemantic_plan]]]
																		    [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: '
																				     'attempting to execute plan: "' [get nonsemantic_plan as-string] '"']
																		    [let [[result [shelter [have nonsemantic_plan imagine_as_thought [frame]]]]]
																		      [if [is-type `bug result]
																			  [let [[bug result]]
																			    [if [not [have [get bug frame] lookup `is_plan_bug]]
																				[bug bug]
																			      [prog [terminal_format standard-terminal '\n' [get [get nonsemantic_plan mental_layer] name] ' nonsemantic_plan-plan_call: found bug executing plan: '
																						     '\n  ' bug]
																				    [have multiple_possible_values add_value_bug semantic_plan_object bug]]]]
																			[have result_multiple_possible_values add_value_with_dependency result [new value_dependency semantic_plan_object multiple_possible_values]]]]]]]]]
															semantic_plan_objects]]
														[if [get result_multiple_possible_values nonbug_values]
														    result_multiple_possible_values
														  [error bug_name         `nonsemantic_plan-plan_call-no_possible_results
															 is_plan_bug      t
															 nonsemantic_plan nonsemantic_plan
															 plan             plan]]]]
								    [t                                        [error bug_name `nonsemantic_plan-plan_call-invalid_argument_type
														     correct_type `[or `semantic_plan_object multiple_possible_values]
														     actual_type  [type plan]
														     plan         plan]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'call ' [get nonsemantic_plan expression-compile plan compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand not [truth_value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[not ,truth_value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile truth_value compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[truth_value [funkall ,[get nonsemantic_plan expression-compile truth_value compile_option_frame] nonsemantic_plan]]]
							      [if [not [is-type `nonsemantic_plan_value truth_value]]
								  [error bug_name     `nonsemantic_plan-not-truth_value_of_wrong_type
									 correct_type `nonsemantic_plan_value
									 actual_type  [type truth_value]
									 truth_value  truth_value]
								[get truth_value negative]]]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[truth_value [funkall ,[get nonsemantic_plan expression-compile truth_value compile_option_frame] nonsemantic_plan]]]
							      [cond [[is-type `nonsemantic_plan_value   truth_value] [get truth_value negative]]
								    [[is-type `multiple_possible_values truth_value] [let [[multiple_possible_values        truth_value]
															   [result_multiple_possible_values [new multiple_possible_values nil]]]
														       [mapc [funk [one_truth_value]
																   [have result_multiple_possible_values add_value_with_dependency [get one_truth_value negative] [new value_dependency one_truth_value multiple_possible_values]]]
															     [get multiple_possible_values nonbug_values]]
														       result_multiple_possible_values]]
								    [t                                               [error bug_name      `nonsemantic_plan-not-invalid_type
															    correct_types `[nonsemantic_plan_value
																	    multiple_possible_values]
															    truth_value   truth_value]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'not ' [get nonsemantic_plan expression-compile truth_value compile_option_frame]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand exists [partial_state]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[exists ,partial_state]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile partial_state compile_option_frame]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[partial_state [funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
							      [have nonsemantic_plan check_exists partial_state]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[partial_state [funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
							      [have nonsemantic_plan imagine_check_exists partial_state]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat [get nonsemantic_plan expression-compile partial_state compile_option_frame] ' exists']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand wait-for [partial_state]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[wait-for ,partial_state]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [get nonsemantic_plan expression-compile partial_state compile_option_frame]]
	  [[eq compile-mode `execute]          [let [[partial_state-eval `[funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[partial_state ,partial_state-eval]]
								[terminal_format standard-terminal '\nplan waiting for: "' [get partial_state as-declarative_natural_language_string] '."']
								[have nonsemantic_plan wait_for partial_state]]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[partial_state-eval `[funkall ,[get nonsemantic_plan expression-compile partial_state compile_option_frame] nonsemantic_plan]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[partial_state ,partial_state-eval]]
								[terminal_format standard-terminal '\nplan imagining waiting for: "' [get partial_state as-declarative_natural_language_string] '."  (not yet implemented)']
								`[have nonsemantic_plan wait_for partial_state]]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat 'wait for ' [get nonsemantic_plan expression-compile partial_state compile_option_frame] ' to exist']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand if [condition true_expression :rest false_expressions]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[if ,condition ,true_expression @false_expressions]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile condition       compile_option_frame]
						     [get nonsemantic_plan expression-compile true_expression compile_option_frame]
						     [mapc [funk [false_expression]
								 [get nonsemantic_plan expression-compile false_expression compile_option_frame]]
							   false_expressions]]]
	  [[eq compile-mode `execute]          [let [[condition-eval         `[funkall ,[get nonsemantic_plan expression-compile condition       compile_option_frame] nonsemantic_plan]]
						     [true_expression-eval   `[funkall ,[get nonsemantic_plan expression-compile true_expression compile_option_frame] nonsemantic_plan]]
						     [false_expressions-eval [mapcar [funk [false_expression]
											   `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]
										     false_expressions]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[condition ,condition-eval]]
								[if [not [is-type `nonsemantic_plan_value condition]]
								    [error bug_name        `nonsemantic_plan-if-truth_value_must_be_of_type_nonsemantic_plan_value
									   condition       condition
									   quote-condition [quote ,condition]]
								  [if [get condition value]
								      ,true_expression-eval
								    @false_expressions-eval]]]]]]]
	  [[eq compile-mode `imagine]          [let [[condition-eval         `[funkall ,[get nonsemantic_plan expression-compile condition       compile_option_frame] nonsemantic_plan]]
						     [true_expression-eval   `[funkall ,[get nonsemantic_plan expression-compile true_expression compile_option_frame] nonsemantic_plan]]
						     [false_expressions-eval [mapcar [funk [false_expression]
											   `[funkall ,[get nonsemantic_plan expression-compile false_expression compile_option_frame] nonsemantic_plan]]
										     false_expressions]]]
						 [eval `[funk [nonsemantic_plan]
							      [let [[condition ,condition-eval]]
								[cond [[is-type `nonsemantic_plan_value   condition] [if [get condition value]
															 [with-new-cause [cause-define cause-last_decision_value condition]
																	 [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-true [quote ,true_expression]]]]
																	   [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																	   ,true_expression-eval]]
														       [with-new-cause [cause-define cause-last_decision_value condition]
																       [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-false [quote ,false_expressions]]]]
																	 [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																	 @false_expressions-eval]]]]
								      [[is-type `multiple_possible_values condition] [let* [[multiple_possible_values        condition]
															    [result_multiple_possible_values [new multiple_possible_values nil]]
															    [conditions                      [get multiple_possible_values nonbug_values]]
															    [conditions-length               [length conditions]]
															    [index                           0]]
														       
														       [terminal_format standard-terminal '\nnonsemantic_plan if: considering ' conditions-length ' conditions.']
														       [mapc [funk [one_condition]
																   [++ index]
																   [terminal_format standard-terminal '\nnonsemantic_plan if: considering condition ' index '/' conditions-length ': ' one_condition]
																   [if [get one_condition value]
																       [let [[true_result [shelter [with-new-cause [cause-define cause-last_decision_value one_condition]
																						   [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-true [quote ,true_expression]]]]
																						     [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																						     ,true_expression-eval]]]]]
																	 [if [is-type `bug true_result]
																	     [let [[bug true_result]]
																	       [terminal_format standard-terminal '\nnonsemantic_plan if true_result bug: ' bug]
																	       [if [not [have [get bug frame] lookup `is_plan_bug]]
																		   [bug bug]
																		 [have multiple_possible_values add_value_bug one_condition bug]]]
																	   [have result_multiple_possible_values add_value_with_dependency true_result [new value_dependency one_condition multiple_possible_values]]]]
																     [let [[false_result [shelter [with-new-cause [cause-define cause-last_decision_value one_condition]
																						  [let [[current_nonsemantic_plan_execution_node [new nonsemantic_plan_execution_node `if-false [quote ,false_expressions]]]]
																						    [cause-define cause-nonsemantic_plan_execution_node current_nonsemantic_plan_execution_node]
																						    @false_expressions-eval]]]]]
																       [if [is-type `bug false_result]
																	   [let [[bug false_result]]
																	     [terminal_format standard-terminal '\nnonsemantic_plan if false_result bug: ' bug]
																	     [if [not [have [get bug frame] lookup `is_plan_bug]]
																		 [bug bug]
																	       [have multiple_possible_values add_value_bug one_condition bug]]]
																	 [have result_multiple_possible_values add_value_with_dependency false_result [new value_dependency one_condition multiple_possible_values]]]]]]
															     [get multiple_possible_values nonbug_values]]
														       
														       [if [null [get result_multiple_possible_values nonbug_values]]
															   [error bug_name    `if-no_possible_good_results
																  is_plan_bug t
																  expression  [cons `if [cons [quote ,condition]
																			      [cons [quote ,true_expression]
																				    [conslist @false_expressions]]]]]
															 result_multiple_possible_values]]]
								      [t                                             [error bug_name        `nonsemantic_plan-if-truth_value_must_be_of_type_nonsemantic_plan_value
															    condition       condition
															    quote-condition [quote ,condition]]]]]]]]]
	  [[eq compile-mode `natural_language] [string-concat 'if ' [get nonsemantic_plan expression-compile condition       compile_option_frame]
							      ', '  [get nonsemantic_plan expression-compile true_expression compile_option_frame]
							      [if false_expressions
								  [string-concat ', otherwise '
										 [stringlist-concat [let [[false_expressions-length [length false_expressions]]
													  [index                    0]]
												      [mapcar [funk [false_expression]
														    [= index [+ index 1]]
														    [let [[separator [if [== index 1]
																	 ''
																       [if [== index false_expressions-length]
																	   ', and '
																	 ', ']]]]
														      [string-concat separator
																     [get nonsemantic_plan expression-compile false_expression compile_option_frame]]]]
													      false_expressions]]]]
								'']]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name     `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand fail []
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[fail]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     nil]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [error bug_name                     `failure
								   is_plan_bug                  t]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [error bug_name                     `failure
								   is_plan_bug                  t]]]]
	  [[eq compile-mode `natural_language] 'fail']
	  [[eq compile-mode `semantic]         nil]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand ? [variable_name]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[? ,variable_name]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [if [not [is-type `symbol variable_name]]
						   [error bug_name      `nonsemantic_plan-?-variable_name_must_be_symbol
							  variable_name variable_name]]]
	  [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
							      [have semantic_thought lookup_a_variable_value [quote ,variable_name]]
							      ]]]]
	  [[eq compile-mode `imagine]          [eval `[funk [nonsemantic_plan]
							    [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
							      [terminal_format standard-terminal '\nplan looking up variable value, ' [quote ,variable_name] '.']
							      [have semantic_thought lookup_a_variable_value [quote ,variable_name]]
							      ]]]]
	  [[eq compile-mode `natural_language] [string-concat '[? ' [get variable_name as-string] ']']]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand property [source_type
			  source_key_type
			  source_key
			  source_value
			  key_type
			  key
			  value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[property ,source_type
											,source_key_type
											,source_key
											,source_value
											,key_type
											,key
											,value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile source_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile source_value    compile_option_frame]
						     [get nonsemantic_plan expression-compile key_type        compile_option_frame]
						     [get nonsemantic_plan expression-compile key             compile_option_frame]
						     [get nonsemantic_plan expression-compile value           compile_option_frame]]]
	  [[eq compile-mode `execute]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [value-eval           `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile value           compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,value-eval]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [value-eval           `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile value           compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,value-eval]
							      ]]]]
	  [[eq compile-mode `natural_language] [let [[source_type-eval     [get nonsemantic_plan expression-compile source_type     compile_option_frame]]
						     [source_key_type-eval [get nonsemantic_plan expression-compile source_key_type compile_option_frame]]
						     [source_key-eval      [get nonsemantic_plan expression-compile source_key      compile_option_frame]]
						     [source_value-eval    [get nonsemantic_plan expression-compile source_value    compile_option_frame]]
						     [key_type-eval        [get nonsemantic_plan expression-compile key_type        compile_option_frame]]
						     [key-eval             [get nonsemantic_plan expression-compile key             compile_option_frame]]
						     [value-eval           [get nonsemantic_plan expression-compile value           compile_option_frame]]]
						 [get [new semantic_partial_state_property [get [get nonsemantic_plan mind] semantic_realm]
							   source_type-eval0
							   source_key_type-eval
							   source_key-eval
							   source_value-eval
							   key_type-eval
							   key-eval
							   value-eval] as-natural_language_string]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand relationship [source_type
			      source_key_type
			      source_key
			      source_value
			      key_type
			      key
			      target_type
			      target_key_type
			      target_key
			      target_value]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[relationship ,source_type
											    ,source_key_type
											    ,source_key
											    ,source_value
											    ,key_type
											    ,key
											    ,target_type
											    ,target_key_type
											    ,target_key
											    ,target_value]]
  [let [[compile-mode [have compile_option_frame lookup `mode]]]
    [cond [[eq compile-mode `syntax_check]     [prog [get nonsemantic_plan expression-compile source_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile source_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile source_value    compile_option_frame]
						     [get nonsemantic_plan expression-compile key_type        compile_option_frame]
						     [get nonsemantic_plan expression-compile key             compile_option_frame]
						     [get nonsemantic_plan expression-compile target_type     compile_option_frame]
						     [get nonsemantic_plan expression-compile target_key_type compile_option_frame]
						     [get nonsemantic_plan expression-compile target_key      compile_option_frame]
						     [get nonsemantic_plan expression-compile target_value    compile_option_frame]]]
	  [[eq compile-mode `execute]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [target_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_type     compile_option_frame] nonsemantic_plan]]]
						     [target_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key_type compile_option_frame] nonsemantic_plan]]]
						     [target_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key      compile_option_frame] nonsemantic_plan]]]
						     [target_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_value    compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,target_type-eval
								   ,target_key_type-eval
								   ,target_key-eval
								   ,target_value-eval]
							      ]]]]
	  [[eq compile-mode `imagine]          [let [[source_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_type     compile_option_frame] nonsemantic_plan]]]
						     [source_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key_type compile_option_frame] nonsemantic_plan]]]
						     [source_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_key      compile_option_frame] nonsemantic_plan]]]
						     [source_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile source_value    compile_option_frame] nonsemantic_plan]]]
						     [key_type-eval        `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key_type        compile_option_frame] nonsemantic_plan]]]
						     [key-eval             `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile key             compile_option_frame] nonsemantic_plan]]]
						     [target_type-eval     `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_type     compile_option_frame] nonsemantic_plan]]]
						     [target_key_type-eval `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key_type compile_option_frame] nonsemantic_plan]]]
						     [target_key-eval      `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_key      compile_option_frame] nonsemantic_plan]]]
						     [target_value-eval    `[name_expression-as-symbol [funkall ,[get nonsemantic_plan expression-compile target_value    compile_option_frame] nonsemantic_plan]]]]
						 [eval `[funk [nonsemantic_plan]
							      [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
								   ,source_type-eval
								   ,source_key_type-eval
								   ,source_key-eval
								   ,source_value-eval
								   ,key_type-eval
								   ,key-eval
								   ,target_type-eval
								   ,target_key_type-eval
								   ,target_key-eval
								   ,target_value-eval]
							      ]]]]
	  [[eq compile-mode `natural_language] [let [[source_type-eval     [get nonsemantic_plan expression-compile source_type     compile_option_frame]]
						     [source_key_type-eval [get nonsemantic_plan expression-compile source_key_type compile_option_frame]]
						     [source_key-eval      [get nonsemantic_plan expression-compile source_key      compile_option_frame]]
						     [source_value-eval    [get nonsemantic_plan expression-compile source_value    compile_option_frame]]
						     [key_type-eval        [get nonsemantic_plan expression-compile key_type        compile_option_frame]]
						     [key-eval             [get nonsemantic_plan expression-compile key             compile_option_frame]]
						     [target_type-eval     [get nonsemantic_plan expression-compile target_type     compile_option_frame]]
						     [target_key_type-eval [get nonsemantic_plan expression-compile target_key_type compile_option_frame]]
						     [target_key-eval      [get nonsemantic_plan expression-compile target_key      compile_option_frame]]
						     [target_value-eval    [get nonsemantic_plan expression-compile target_value    compile_option_frame]]]
						 [get [new semantic_partial_state_property_relation [get [get nonsemantic_plan mind] semantic_realm]
							   source_type-eval
							   source_key_type-eval
							   source_key-eval
							   source_value-eval
							   key_type-eval
							   key-eval
							   target_type-eval
							   target_key_type-eval
							   target_key-eval
							   target_value-eval] as-natural_language_string]]]
	  [[eq compile-mode `semantic]         [prog ]]
	  [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
						      compile-mode compile-mode]]]]]

[defplancommand defplan [name_expression :rest arguments]
  `[terminal_format standard-terminal '\nnonsemantic_plan_command compiling ' `[defplan ,name_expression @arguments]]
  [let [[name_patterns        nil]
	[variable_definitions nil]
	[plan_body_expression nil]]
    [let [[argument_iter                   arguments]
	  [done_reading_optional_arguments nil]]
      [while [not done_reading_optional_arguments]
	[let [[optional_argument_key [car argument_iter]]]
	  [cond [[eq optional_argument_key `:matches] [prog [= argument_iter [cdr argument_iter]]
							    [= name_patterns [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[[eq optional_argument_key `:frame]   [prog [= argument_iter [cdr argument_iter]]
							    [= variable_definitions [car argument_iter]]
							    [= argument_iter [cdr argument_iter]]]]
		[t                                    [= done_reading_optional_arguments t]]]]]
      [if [== [length argument_iter] 1]
	  [= plan_body_expression [car argument_iter]]
	[= plan_body_expression `[prog @argument_iter]]]]
    [let [[compile-mode [have compile_option_frame lookup `mode]]]
      [cond [[eq compile-mode `syntax_check]     [prog ]]
	    [[eq compile-mode `execute]          [eval `[funk [nonsemantic_plan]
							      [terminal_format standard-terminal '\n' [conslist `defplan [quote ,name_expression]]]
							      [let* [[new_nonsemantic_plan [new nonsemantic_plan [get nonsemantic_plan mental_layer] [quote ,name_expression] [quote ,name_patterns] [quote ,variable_definitions] [quote ,plan_body_expression]]]
								     [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
								[have [get nonsemantic_plan mental_layer] add_semantic_plan new_semantic_plan_object]]]]]
	    [[eq compile-mode `imagine]          [prog ]]
	    [[eq compile-mode `natural_language] [string-concat 'define a plan to ' [if [is-type `string name_expression]
											name_expression
										      [get name_expression as-string]]]]
	    [[eq compile-mode `semantic]         [prog ]]
	    [t                                   [error bug_name `nonsemantic_plan-compile_error-invalid_compile_mode
							compile-mode compile-mode]]]]]]

]