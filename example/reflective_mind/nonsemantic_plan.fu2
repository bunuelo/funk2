'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


[defunk name_expression-as-string [this]
  [cond [[is-type `string this] this]
	[[is-type `cons   this] [conslist-as-english_string [have this flatten]]]
	[t                      [get this as-string]]]]

[defunk name_expression-as-symbol [this]
  [get [name_expression-as-string this] as-symbol]]

[defunk nonsemantic_plan-unique_name_from_name_expression [name_expression]
  [name_expression-as-symbol name_expression]]

'nonsemantic_plan'

[deframe nonsemantic_plan [frame] [mental_layer
				   name_expression
				   variables
				   expression
				   [internal-unique_name           nil]
				   [internal-semantic_plan_object  nil]
				   [internal-compiled_funk         nil]
				   [internal-compiled_imagine_funk nil]
				   [internal-english_conslist      `uninitialized]
				   [internal-english_string        nil]]
  [new [initial-mental_layer
	initial-name_expression
	initial-variables
	initial-expression]
       [= mental_layer    initial-mental_layer]
       [= name_expression initial-name_expression]
       [= variables       initial-variables]
       [= expression      initial-expression]
       ]]

[deftypefunk nonsemantic_plan get unique_name []
  [if [null internal-unique_name]
      [= internal-unique_name [nonsemantic_plan-unique_name_from_name_expression name_expression]]]
  internal-unique_name]

[deftypefunk nonsemantic_plan get mind []
  [get mental_layer mind]]

[deftypefunk nonsemantic_plan get expression-as_english_conslist [expression]
  [cond [[is-type `symbol expression] expression]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[eval-expression [elt arguments 0]]]
												  `[eval]]]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[print-expression [elt arguments 0]]]
												  [get this expression-as_english_conslist print-expression]]]]
						[[eq `prog                           command] [apply &append
												     [append `[[do the following in serial punctuation-colon]]
													     [let [[step_number 1]]
													       [mapcar [funk [argument]
															     [let [[argument-result [append `[,[get step_number as-symbol] punctuation-period]
																			    [get this expression-as_english_conslist argument]
																			    [if [not [eq step_number arguments-length]]
																				`[punctuation-comma]]]]]
															       [++ step_number]
															       argument-result]]
														       arguments]]]]]
						[[eq `parog                          command] [apply &append
												     [append `[[do the following in parallel punctuation-colon]]
													     [let [[step_number 1]]
													       [mapcar [funk [argument]
															     [let [[argument-result [append `[* punctuation-period]
																			    [get this expression-as_english_conslist argument]
																			    [if [not [eq step_number arguments-length]]
																				`[punctuation-comma]]]]]
															       argument-result]]
														       arguments]]]]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[time_to_wait [elt arguments 0]]]
												  [append `[wait for]
													  `[,time_to_wait]]]]]
						[[eq `wait-to-call-below             command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[action_name [elt arguments 0]]]
												  [flatten_constree `[,action_name]]]]]
						[[eq `wait-to-call                   command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[action_name [elt arguments 0]]]
												  [flatten_constree `[,action_name]]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let* [[semantic_plan_object-phenomenal_name `[quote, [nonsemantic_plan-unique_name_from_name_expression [elt arguments 0]]]]]
												  `[call plan to ,semantic_plan_object-phenomenal_name]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[exists-expression [elt arguments 0]]]
												  [get this expression-as_english_conslist exists-expression]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[partial_state [get this expression-as_english_conslist [elt arguments 0]]]]
												  [append `[wait for]
													  partial_state]]]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[if-condition    [get this expression-as_english_conslist [elt arguments 0]]]
												      [if-true_branch  [get this expression-as_english_conslist [elt arguments 1]]]
												      [if-false_branch [if [== arguments-length 3]
															   [get this expression-as_english_conslist [elt arguments 2]]]]]
												  [append `[if]
													  if-condition
													  `[punctuation-comma]
													  if-true_branch
													  [if if-false_branch
													      [append `[otherwise]
														      if-false_branch]]]]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[assert-expression [get this expression-as_english_conslist [elt arguments 0]]]]
												  [append `[assert that]
													  assert-expression]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[quote-expression [elt arguments 0]]]
												  `[]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[variable-symbol [elt arguments 0]]]
												  `[? ,variable-symbol]]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[source_type     [get this expression-as_english_conslist [elt arguments 0]]]
												      [source_key_type [get this expression-as_english_conslist [elt arguments 1]]]
												      [source_key      [get this expression-as_english_conslist [elt arguments 2]]]
												      [source_value    [get this expression-as_english_conslist [elt arguments 3]]]
												      [key_type        [get this expression-as_english_conslist [elt arguments 4]]]
												      [key             [get this expression-as_english_conslist [elt arguments 5]]]
												      [value           [get this expression-as_english_conslist [elt arguments 6]]]]
												  [get [new semantic_partial_state_property [get [get this mind] semantic_realm]
													    source_type
													    source_key_type
													    source_key
													    source_value
													    key_type
													    key
													    value]
												       as-declarative_english_conslist]]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  `[error punctuation-colon ,[flatten_constree expression]]
												[let [[source_type     [get this expression-as_english_conslist [elt arguments 0]]]
												      [source_key_type [get this expression-as_english_conslist [elt arguments 1]]]
												      [source_key      [get this expression-as_english_conslist [elt arguments 2]]]
												      [source_value    [get this expression-as_english_conslist [elt arguments 3]]]
												      [key_type        [get this expression-as_english_conslist [elt arguments 4]]]
												      [key             [get this expression-as_english_conslist [elt arguments 5]]]
												      [target_type     [get this expression-as_english_conslist [elt arguments 6]]]
												      [target_key_type [get this expression-as_english_conslist [elt arguments 7]]]
												      [target_key      [get this expression-as_english_conslist [elt arguments 8]]]
												      [target_value    [get this expression-as_english_conslist [elt arguments 9]]]]
												  [get [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
													    source_type
													    source_key_type
													    source_key
													    source_value
													    key_type
													    key
													    target_type
													    target_key_type
													    target_key
													    target_value]
												       as-declarative_english_conslist]]]]
						[t                                            `[error ,[flatten_constree expression]]]]]]]
	[t                            `[error punctuation-colon ,[flatten_constree expression]]]]]

[deftypefunk nonsemantic_plan get as-english_conslist []
  [if [eq `uninitialized internal-english_conslist]
      [= internal-english_conslist [get this expression-as_english_conslist expression]]]
  internal-english_conslist]

[deftypefunk nonsemantic_plan get as-english_string []
  [if [null internal-english_string]
      [= internal-english_string [conslist-as-english_string [get this as-english_conslist]]]]
  internal-english_string]

[deftypefunk nonsemantic_plan get as-string []
  [get this as-english_string]]

[deftypefunk nonsemantic_plan get as-graphviz_label []
  [string-concat '<' [get [get this unique_name] as-string] '>']]



[deftypefunk nonsemantic_plan execute expression-syntax_check [expression]
  [cond [[is-type `symbol expression] `[quote ,expression]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `eval
													 expression expression]
												[let [[eval-expression `[quote ,[elt arguments 0]]]]
												  `cannot_determine_syntax]]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `print
													 expression expression]
												[let [[print-expression [elt arguments 0]]]
												  [have this expression-syntax_check print-expression]]]]
						[[eq `prog                           command] [let [[last_argument nil]]
												[mapc [funk [argument]
													    [= last_argument [have this expression-syntax_check argument]]]
												      arguments]
												last_argument]]
						[[eq `parog                          command] [prog [mapc [funk [argument]
														[have this expression-syntax_check argument]]
													  arguments]
												    nil]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-for-time
													 expression expression]
												[let [[time_to_wait [elt arguments 0]]]
												  [if [not [is-type `integer time_to_wait]]
												      [terminal_format standard-terminal '\nplan syntax warning: time_to_wait is not an integer (' time_to_wait ').']]
												  nil]]]
						[[eq `wait-to-call-below             command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-to-call-below
													 expression expression]
												[let [[action_name [elt arguments 0]]]
												  [let [[action [have this lookup_action_below action_name]]]
												    [if [null action]
													[terminal_format standard-terminal '\nplan syntax warning: "' [conslist-as-english_string [have [cons action_name nil] flatten]] '" action not defined.']]
												    nil]]]]
						[[eq `wait-to-call                   command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-to-call
													 expression expression]
												[let [[action_name [elt arguments 0]]]
												  [let [[action [have this lookup_action action_name]]]
												    [if [null action]
													[terminal_format standard-terminal '\nplan syntax warning: "' [conslist-as-english_string [have [cons action_name nil] flatten]] '" action not defined.']]
												    nil]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `plan-call
													 expression expression]
												[let* [[semantic_plan_object-phenomenal_name `[quote, [nonsemantic_plan-unique_name_from_name_expression [elt arguments 0]]]]
												       [semantic_plan_object                 [have [get this mental_layer] lookup_semantic_plan semantic_plan_object-phenomenal_name]]]
												  [if [null semantic_plan_object]
												      [terminal_format standard-terminal '\nplan syntax warning: "' [get semantic_plan_object-phenomenal_name as-string] '" plan not defined.']]
												  ]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `exists
													 expression expression]
												[let [[exists-expression [elt arguments 0]]]
												  [have this expression-syntax_check exists-expression]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `wait-for
													 expression expression]
												`cannot_determine_syntax]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `if
													 expression expression]
												[let [[if-condition    [have this expression-syntax_check [elt arguments 0]]]
												      [if-true_branch  [have this expression-syntax_check [elt arguments 1]]]
												      [if-false_branch [if [== arguments-length 3]
															   [have this expression-syntax_check [elt arguments 2]]]]]
												  `cannot_determine_syntax]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `assert
													 expression expression]
												[let [[assert-expression [elt arguments 0]]]
												  [have this expression-syntax_check assert-expression]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `quote
													 expression expression]
												[let [[quote-expression [elt arguments 0]]]
												  `[quote, quote-expression]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `?
													 expression expression]
												[let [[variable-symbol `[quote ,[elt arguments 0]]]]
												  `cannot_determine_syntax]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `property
													 expression expression]
												[let [[source_type     [have this expression-syntax_check [elt arguments 0]]]
												      [source_key_type [have this expression-syntax_check [elt arguments 1]]]
												      [source_key      [have this expression-syntax_check [elt arguments 2]]]
												      [source_value    [have this expression-syntax_check [elt arguments 3]]]
												      [key_type        [have this expression-syntax_check [elt arguments 4]]]
												      [key             [have this expression-syntax_check [elt arguments 5]]]
												      [value           [have this expression-syntax_check [elt arguments 6]]]]
												  `cannot_determine_syntax]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  [error bug_name   `plan_syntax_error-wrong_number_of_arguments
													 funkname   `relationship
													 expression expression]
												[let [[source_type     [have this expression-syntax_check [elt arguments 0]]]
												      [source_key_type [have this expression-syntax_check [elt arguments 1]]]
												      [source_key      [have this expression-syntax_check [elt arguments 2]]]
												      [source_value    [have this expression-syntax_check [elt arguments 3]]]
												      [key_type        [have this expression-syntax_check [elt arguments 4]]]
												      [key             [have this expression-syntax_check [elt arguments 5]]]
												      [target_type     [have this expression-syntax_check [elt arguments 6]]]
												      [target_key_type [have this expression-syntax_check [elt arguments 7]]]
												      [target_key      [have this expression-syntax_check [elt arguments 8]]]
												      [target_value    [have this expression-syntax_check [elt arguments 9]]]]
												  `cannot_determine_syntax]]]
						[t                                            [error bug_name `nonsemantic_plan_syntax_error]]]]]]
	[t                            [error bug_name `nonsemantic_plan_syntax_error]]]]

[deftypefunk nonsemantic_plan execute syntax_check []
  [have this expression-syntax_check expression]]


[deftypefunk nonsemantic_plan execute check_exists [semantic_partial_state]
  [have [get this mental_layer] check_exists semantic_partial_state]]

[deftypefunk nonsemantic_plan execute wait_for [semantic_partial_state]
  [have [get this mental_layer] wait_for semantic_partial_state]]

[deftypefunk nonsemantic_plan execute assert [semantic_partial_state]
  [have [get this mental_layer] assert semantic_partial_state]]

[deftypefunk nonsemantic_plan execute imagine_asserting [semantic_partial_state]
  [have [get this mental_layer] imagine_assuring semantic_partial_state]]


[deftypefunk nonsemantic_plan execute __execute_funk_as_thought_in_semantic_planner [semantic_planner funk args]
  [terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.']
  [shelter [let* [[semantic_knowledge_base_set [have semantic_planner lookup `semantic_knowledge_base_set]]
		  [semantic_knowledge_bases    [get semantic_knowledge_base_set elements]]]
	     [if [null semantic_knowledge_bases]
		 [error funkname `semantic_planner-new_semantic_thought
			bug_name `semantic_knowledge_bases-is-nil]]
	     
	     [let* [[execute_now-conditionlock   [new conditionlock]]
		    [execute_now                 nil]
		    [thought_fiber               [fiber [funk []
							      [have execute_now-conditionlock lock]
							      [while [not execute_now]
								[have execute_now-conditionlock wait]]
							      [have execute_now-conditionlock unlock]
							      [cause-define cause-name [get this unique_name]]
							      [apply funk args]]
							[]]]
		    [semantic_thought            [let [[this [new semantic_thought [get semantic_planner semantic_realm]]]]
						   [set this fiber thought_fiber]
						   this]]]
	       
	       [let [[semantic_environment [new semantic_environment [get semantic_planner semantic_realm]]]]
		 [have [get this semantic_plan_object] add_default_frame_to_environment semantic_environment]
		 [set semantic_thought environment semantic_environment]]
	       
	       [mapc [funk [semantic_knowledge_base]
			   [have semantic_knowledge_base add_semantic_frame semantic_thought]]
		     semantic_knowledge_bases]
	       [semantic-add semantic_planner thought semantic_thought]
	       
	       [have [get thought_fiber cause_reg] define `cause-semantic_thought semantic_thought]
	       
	       [terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (telling thought_fiber to execute now)']
	       [have execute_now-conditionlock lock]
	       [= execute_now t]
	       [have execute_now-conditionlock signal]
	       [have execute_now-conditionlock unlock]
	       [let [[result [fiber-sheltered_join thought_fiber]]]
		 [terminal_format standard-terminal '\nnonsemantic_plan: executing funk as thought in semantic_planner.  (joined thought_fiber)']
		 
		 [semantic-remove semantic_planner thought semantic_thought]
		 [mapc [funk [semantic_knowledge_base]
			     [have semantic_knowledge_base remove_semantic_frame semantic_thought]]
		       semantic_knowledge_bases]
		 
		 result]]]]]




[defunk nonsemantic_plan-expression-compile [expression]
  [cond [[is-type `symbol expression] [eval `[funk []
						   [quote ,expression]]]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
					[let [[arguments-length [length arguments]]]
					  [cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `eval
													 expression expression]
												[let [[eval-expression `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [eval ,eval-expression]]]]]]
						[[eq `print                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `print
													 expression expression]
												[let [[print-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-print-expression [funkall ,[nonsemantic_plan-expression-compile print-expression] this]]]
														 [terminal_format standard-terminal '\nplan printing expression: ' eval-print-expression]
														 eval-print-expression]]]]]]
						[[eq `prog                           command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan evaluating serial process.']
													   @[mapcar [funk [argument]
															  `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
														    arguments]]]]
						[[eq `parog                          command] [eval `[funk [this]
													   [terminal_format standard-terminal '\nplan evaluating parallel process.']
													   [parog @[mapcar [funk [argument]
																 `[funkall ,[nonsemantic_plan-expression-compile argument] this]]
															   arguments]]
													   nil]]]
						[[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-for-time
													 expression expression]
												[let [[time_to_wait [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[time_to_wait ,time_to_wait]]
														 [dotimes [i time_to_wait]
														   `[terminal_format standard-terminal '\nplan waiting for time step ' i `/ time_to_wait '.']
														   [wait-for-trigger [get [get [get this mind] body] time_step_trigger]]]
														 ]]]]]]
						[[eq `wait-to-call-below             command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-to-call-below
													 expression expression]
												[let [[action_name `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action_below ,action_name]]]
														 [if [null action]
														     [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															    action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														   [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
															 [have action wait_to_call]
															 ]]]]]]]]
						[[eq `wait-to-call                   command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-to-call
													 expression expression]
												[let [[action_name `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [let [[action [have this lookup_action ,action_name]]]
														 [if [null action]
														     [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															    action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														   [prog [terminal_format standard-terminal '\nplan waiting to call: "' [get action as-string] '."']
															 [have action wait_to_call]
															 ]]]]]]]]
						[[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `plan-call
													 expression expression]
												[let* [[semantic_plan_object-phenomenal_name `[quote, [nonsemantic_plan-unique_name_from_name_expression [elt arguments 0]]]]]
												  [eval `[funk [this]
													       [let [[semantic_plan_object [have [get this mental_layer] lookup_semantic_plan ,semantic_plan_object-phenomenal_name]]]
														 [if [null semantic_plan_object]
														     [error bug_name           `nonsemantic_plan-plan_call-no_such_plan
															    action_description [conslist-as-english_string [have [cons ,semantic_plan_object-phenomenal_name nil] flatten]]]
														   [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]
															 [semantic_planner [get [get [get this mental_layer] agency `plan] semantic_planner]]]
														     [terminal_format standard-terminal '\nexecuting plan: "' [get ,semantic_plan_object-phenomenal_name as-string] '."']
														     [have nonsemantic_plan execute_as_thought_in_semantic_planner semantic_planner]
														     ]]]]]]]]
						[[eq `exists                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `exists
													 expression expression]
												[let [[exists-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [let [[eval-exists-expression [funkall ,[nonsemantic_plan-expression-compile exists-expression] this]]]
														 [have this check_exists eval-exists-expression]
														 ]]]]]]
						[[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `wait-for
													 expression expression]
												[let [[partial_state `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[partial_state ,partial_state]]
														 [terminal_format standard-terminal '\nplan waiting for: "' [get partial_state as-declarative_english_string] '."']
														 [have this wait_for partial_state]]
													       ]]]]]
						[[eq `if                             command] [if [not [or [== arguments-length 2]
													   [== arguments-length 3]]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `if
													 expression expression]
												[let [[if-condition    `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]
												      [if-true_branch  `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]
												      [if-false_branch [if [== arguments-length 3]
															   `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]]]
												  [eval `[funk [this]
													       [if ,if-condition
														   ,if-true_branch
														 ,if-false_branch]]]]]]
						[[eq `assert                         command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `assert
													 expression expression]
												[let [[assert-expression `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]]
												  [eval `[funk [this]
													       [let [[assert-expression ,assert-expression]]
														 [if [not assert-expression]
														     [error bug_name    `assertion-failed
															    description [conslist `assert [quote ,assert-expression]]]]]]]]]]
						[[eq `quote                          command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `quote
													 expression expression]
												[let [[quote-expression [elt arguments 0]]]
												  [eval `[funk [this]
													       [quote ,quote-expression]
													       ]]]]]
						[[eq `?                              command] [if [not [eq 1 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `?
													 expression expression]
												[let [[variable-symbol `[quote ,[elt arguments 0]]]]
												  [eval `[funk [this]
													       [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
														 [terminal_format standard-terminal '\nplan looking up variable value, ' ,variable-symbol '.']
														 [have semantic_thought lookup_a_variable_value ,variable-symbol]
														 ]]]]]]
						[[eq `property                       command] [if [not [eq 7 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `property
													 expression expression]
												[let [[source_type     `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]
												      [source_key_type `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]
												      [source_key      `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]
												      [source_value    `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 3]] this]]
												      [key_type        `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 4]] this]]
												      [key             `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 5]] this]]
												      [value           `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 6]] this]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,value]
													       ]]]]]
						[[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												  [error bug_name   `plan_compile_error-wrong_number_of_arguments
													 funkname   `relationship
													 expression expression]
												[let [[source_type     `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 0]] this]]
												      [source_key_type `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 1]] this]]
												      [source_key      `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 2]] this]]
												      [source_value    `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 3]] this]]
												      [key_type        `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 4]] this]]
												      [key             `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 5]] this]]
												      [target_type     `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 6]] this]]
												      [target_key_type `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 7]] this]]
												      [target_key      `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 8]] this]]
												      [target_value    `[funkall ,[nonsemantic_plan-expression-compile [elt arguments 9]] this]]]
												  [eval `[funk [this]
													       [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
														    ,source_type
														    ,source_key_type
														    ,source_key
														    ,source_value
														    ,key_type
														    ,key
														    ,target_type
														    ,target_key_type
														    ,target_key
														    ,target_value]
													       ]]]]]
						[t                                            [error bug_name `nonsemantic_plan_compile_error]]]]]]
	[t                            [error bug_name `nonsemantic_plan_compile_error]]]]

[deftypefunk nonsemantic_plan get __compiled_funk []
  [nonsemantic_plan-expression-compile expression]]

[deftypefunk nonsemantic_plan get compiled_funk []
  [if [null internal-compiled_funk]
      [= internal-compiled_funk [get this __compiled_funk]]]
  internal-compiled_funk]

[deftypefunk nonsemantic_plan execute eval []
  [funkall [get this compiled_funk] this]]

[deftypefunk nonsemantic_plan execute execute_as_thought_in_semantic_planner [semantic_planner]
  [have this __execute_funk_as_thought_in_semantic_planner semantic_planner
	[funk []
	      [have this eval]]
	[]]]


[deftypefunk nonsemantic_plan execute lookup_action_below [action_name_expression]
  [have mental_layer lookup_action_below action_name_expression]]

[deftypefunk nonsemantic_plan execute lookup_action [action_name_expression]
  [have mental_layer lookup_action action_name_expression]]


[defunk nonsemantic_plan-expression-compile_imagine [expression]
  [cond [[is-type `symbol expression] [eval `[funk []
						   [quote ,expression]]]]
	[[is-type `cons   expression] [let [[command   [car expression]]
					    [arguments [cdr expression]]]
				      [let [[arguments-length [length arguments]]]
					[cond [[eq `eval                           command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `eval
												       expression expression]
											      [let [[eval-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[eval-expression [quote ,eval-expression]]]
													       [terminal_format standard-terminal '\nplan imagine warning: not imagining eval, ' eval_expression '.']
													       ]]]]]]
					      [[eq `print                          command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `print
												       expression expression]
											      [let [[print-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[eval-print-expression [funkall ,[nonsemantic_plan-expression-compile_imagine print-expression] this]]]
													       [terminal_format standard-terminal '\nplan imagine printing expression: ' eval-print-expression]
													       eval-print-expression]]]]]]
					      [[eq `prog                           command] [eval `[funk [this]
													 [terminal_format standard-terminal '\nplan imagining serial process.']
													 @[mapcar [funk [argument]
															`[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
														  arguments]]]]
					      [[eq `parog                          command] [eval `[funk [this]
													 [terminal_format standard-terminal '\nplan imagining parallel process.']
													 [parog @[mapcar [funk [argument]
															       `[funkall ,[nonsemantic_plan-expression-compile_imagine argument] this]]
															 arguments]]
													 nil]]]
					      [[eq `wait-for-time                  command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `wait-for-time
												       expression expression]
											      [let [[time_to_wait [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[time_to_wait ,time_to_wait]]
													       'no imaginative effects'
													       ]]]]]]
					      [[eq `wait-to-call-below             command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `wait-to-call-below
												       expression expression]
											      [let [[action_name `[quote ,[elt arguments 0]]]]
												[eval `[funk [this]
													     [let [[action [have this lookup_action_below ,action_name]]]
													       [if [null action]
														   [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															  action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														 [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
														       [have action imagine_waiting_to_call]
														       ]]]]]]]]
					      [[eq `wait-to-call                   command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `wait-to-call
												       expression expression]
											      [let [[action_name `[quote ,[elt arguments 0]]]]
												[eval `[funk [this]
													     [let [[action [have this lookup_action ,action_name]]]
													       [if [null action]
														   [error bug_name           `nonsemantic_plan-wait_to_call-no_such_action
															  action_description [conslist-as-english_string [have [cons ,action_name nil] flatten]]]
														 [prog [terminal_format standard-terminal '\nplan imagining calling: "' [get action as-string] '."']
														       [have action imagine_waiting_to_call]
														       ]]]]]]]]
					      [[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan-call
												       expression expression]
											      [let* [[semantic_plan_object-phenomenal_name `[quote, [nonsemantic_plan-unique_name_from_name_expression [elt arguments 0]]]]]
												[eval `[funk [this]
													     [let [[semantic_plan_object [have [get this mental_layer] lookup_semantic_plan ,semantic_plan_object-phenomenal_name]]]
													       [if [null semantic_plan_object]
														   [error bug_name           `nonsemantic_plan-plan_call-no_such_plan
															  action_description [conslist-as-english_string [have [cons ,semantic_plan_object-phenomenal_name nil] flatten]]]
														 [let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]
														       [semantic_planner [get [get [get this mental_layer] agency `plan] semantic_planner]]]
														   [terminal_format standard-terminal '\nimagining executing plan: "' [get ,semantic_plan_object-phenomenal_name as-string] '."']
														   [have nonsemantic_plan imagine_as_thought_in_semantic_planner semantic_planner]
														   ]]]]]]]]
					      [[eq `exists                         command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `exists
												       expression expression]
											      [let [[exists-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [let [[eval-exists-expression [funkall ,[nonsemantic_plan-expression-compile_imagine exists-expression] this]]]
													       [have this imagine_check_exists eval-exists-expression]
													       ]]]]]]
					      [[eq `wait-for                       command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `wait-for
												       expression expression]
											      [let [[partial_state `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												[eval `[funk [this]
													     [let [[partial_state ,partial_state]]
													       [terminal_format standard-terminal '\nplan imagining waiting for: "'
																[get partial_state as-declarative_english_string] '."']
													       [have this wait_for partial_state]
													       ]
													     ]]]]]
					      [[eq `if                             command] [if [not [or [== arguments-length 2]
													 [== arguments-length 3]]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `if
												       expression expression]
											      [let [[if-condition    `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]
												    [if-true_branch  `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]
												    [if-false_branch [if [== arguments-length 3]
															 `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]]]
												[eval `[funk [this]
													     [if ,if-condition
														 ,if-true_branch
													       ,if-false_branch]]]]]]
					      [[eq `assert                         command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `assert
												       expression expression]
											      [let [[assert-expression `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]]
												[eval `[funk [this]
													     [let [[assert-expression ,assert-expression]]
													       [if [not assert-expression]
														   [error bug_name    `assertion-failed
															  description [conslist `imagine_asserting [quote ,assert-expression]]]]]]]]]]
					      [[eq `quote                          command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `quote
												       expression expression]
											      [let [[quote-expression [elt arguments 0]]]
												[eval `[funk [this]
													     [quote ,quote-expression]
													     ]]]]]
					      [[eq `?                              command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `?
												       expression expression]
											      [let [[variable-symbol `[quote ,[elt arguments 0]]]]
												[eval `[funk [this]
													     [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
													       [terminal_format standard-terminal '\nplan imagining looking up variable value, ' ,variable-symbol '.']
													       [have semantic_thought lookup_a_variable_value ,variable-symbol]
													       ]]]]]]
					      [[eq `property                       command] [if [not [eq 7 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `property
												       expression expression]
											      [let [[source_type     `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]
												    [source_key_type `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]
												    [source_key      `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]
												    [source_value    `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 3]] this]]
												    [key_type        `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 4]] this]]
												    [key             `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 5]] this]]
												    [value           `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 6]] this]]]
												[eval `[funk [this]
													     [new semantic_partial_state_property [get [get this mind] semantic_realm]
														  ,source_type
														  ,source_key_type
														  ,source_key
														  ,source_value
														  ,key_type
														  ,key
														  ,value]
													     ]]]]]
					      [[eq `relationship                   command] [if [not [eq 10 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `relationship
												       expression expression]
											      [let [[source_type     `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 0]] this]]
												    [source_key_type `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 1]] this]]
												    [source_key      `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 2]] this]]
												    [source_value    `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 3]] this]]
												    [key_type        `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 4]] this]]
												    [key             `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 5]] this]]
												    [target_type     `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 6]] this]]
												    [target_key_type `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 7]] this]]
												    [target_key      `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 8]] this]]
												    [target_value    `[funkall ,[nonsemantic_plan-expression-compile_imagine [elt arguments 9]] this]]]
												[eval `[funk [this]
													     [new semantic_partial_state_property_relation [get [get this mind] semantic_realm]
														  ,source_type
														  ,source_key_type
														  ,source_key
														  ,source_value
														  ,key_type
														  ,key
														  ,target_type
														  ,target_key_type
														  ,target_key
														  ,target_value]
													     ]]]]]
					      [t                                            [error bug_name `nonsemantic_plan_compile_imagine_error]]]]]]
	[t                          [error bug_name `nonsemantic_plan_compile_imagine_error]]]]

[deftypefunk nonsemantic_plan get __compiled_imagine_funk []
  [nonsemantic_plan-expression-compile_imagine expression]]

[deftypefunk nonsemantic_plan get compiled_imagine_funk []
  [if [null internal-compiled_imagine_funk]
      [= internal-compiled_imagine_funk [get this __compiled_imagine_funk]]]
  internal-compiled_imagine_funk]

[deftypefunk nonsemantic_plan execute imagine_eval []
  [funkall [get this compiled_imagine_funk] this]]

[deftypefunk nonsemantic_plan execute imagine_as_thought_in_semantic_planner [semantic_planner]
  [have this __execute_funk_as_thought_in_semantic_planner semantic_planner
	[funk []
	      [have this imagine_eval]]
	[]]]




[defunk semantic_plan_operator_activation-new_with_resource_dependency [semantic_realm resource_activation_dependency]
  [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]
	[semantic_counterfactual_transframe [new semantic_counterfactual_transframe semantic_realm]]]
    [set semantic_counterfactual_transframe resource_activation_dependency resource_activation_dependency]
    [set semantic_plan_operator counterfactual_transframe semantic_counterfactual_transframe]
    semantic_plan_operator_activation]]

[defunk nonsemantic_plan-expression-semantic_compile [expression semantic_realm]
  [cond [[is-type `symbol expression] [let [[semantic_thought [cause-lookup cause-semantic_thought]]]
					,expression]]
	[[is-type `cons expression] [let [[command           [car expression]]
					  [command_arguments [cdr expression]]]
				      [let [[command_arguments-length [length command_arguments]]]
					[cond [[eq `eval                           command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `eval
												       expression expression]
											      [let [[eval-expression [elt command_arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `eval]]]]
					      [[eq `print                          command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `print
												       expression expression]
											      [let [[print-expression [elt arguments 0]]]
												[nonsemantic_plan-expression-semantic_compile print-expression]]]]
					      [[eq `prog                           command] [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]]
											      semantic_plan_operator_activation]]
					      [[eq `parog                          command] [let [[semantic_plan_operator_activation [new semantic_plan_operator_activation semantic_realm]]]
											      semantic_plan_operator_activation]]
					      [[eq `wait-for-time                  command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `wait-for-time
												       expression expression]
											      [let [[time_to_wait [elt command_arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-for-time]]]]
					      [[eq `wait-to-call-below             command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `wait-to-call-below
												       expression expression]
											      [let [[action_name `[quote ,[elt command_arguments 0]]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-to-call-below]]]]
					      [[eq `wait-to-call                   command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `wait-to-call
												       expression expression]
											      [let [[action_name `[quote ,[elt command_arguments 0]]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-to-call]]]]
					      [[eq `plan-call                      command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_imagine_error-wrong_number_of_arguments
												       funkname   `plan-call
												       expression expression]
											      [let* [[semantic_plan_object-phenomenal_name `[quote, [nonsemantic_plan-unique_name_from_name_expression [elt arguments 0]]]]]
												nil]]]
					      [[eq `exists                         command] [if [not [eq 1 arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `exists
												       expression expression]
											      [let [[exists-expression [elt arguments 0]]]
												[nonsemantic_plan-expression-semantic_compile exists-expression]]]]
					      [[eq `wait-for                       command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `wait-for
												       expression expression]
											      [let [[partial_state [elt command_arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `wait-for]]]]
					      [[eq `if                             command] [if [not [or [== arguments-length 2]
													 [== arguments-length 3]]]
												[error bug_name   `plan_compile_error-wrong_number_of_arguments
												       funkname   `if
												       expression expression]
											      nil]]
					      [[eq `assert                         command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `assert
												       expression expression]
											      [let [[assert-expression [elt command_arguments 0]]]
												[semantic_plan_operator_activation-new_with_resource_dependency semantic_realm `assert]]]]
					      [[eq `quote                          command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `quote
												       expression expression]
											      [let [[quote-expression [elt command_arguments 0]]]
												nil]]]
					      [[eq `?                              command] [if [not [eq 1 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `?
												       expression expression]
											      [let [[variable-symbol [elt command_arguments 0]]]
												`[? ,variable-symbol]]]]
					      [[eq `property                       command] [if [not [eq 7 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `property
												       expression expression]
											      [let [[source_type     [elt command_arguments 0]]
												    [source_key_type [elt command_arguments 1]]
												    [source_key      [elt command_arguments 2]]
												    [source_value    [elt command_arguments 3]]
												    [key_type        [elt command_arguments 4]]
												    [key             [elt command_arguments 5]]
												    [value           [elt command_arguments 6]]]
												nil]]]
					      [[eq `relationship                   command] [if [not [eq 10 command_arguments-length]]
												[error bug_name   `plan_compile_error-wrong_number_of_command_arguments
												       funkname   `relationship
												       expression expression]
											      [let [[source_type     [elt command_arguments 0]]
												    [source_key_type [elt command_arguments 1]]
												    [source_key      [elt command_arguments 2]]
												    [source_value    [elt command_arguments 3]]
												    [key_type        [elt command_arguments 4]]
												    [key             [elt command_arguments 5]]
												    [target_type     [elt command_arguments 6]]
												    [target_key_type [elt command_arguments 7]]
												    [target_key      [elt command_arguments 8]]
												    [target_value    [elt command_arguments 9]]]
												nil]]]
					      [t                                            [error bug_name `nonsemantic_plan_compile_error]]]]]]
	[t                          [error bug_name `nonsemantic_plan_compile_error]]]]

[deftypefunk nonsemantic_plan get __semantic_plan_object []
  [let [[semantic_plan_object [new semantic_plan_object [get [get this mind] semantic_realm] [get this unique_name] this]]
	[start_plan_operator  [nonsemantic_plan-expression-semantic_compile expression [get [get this mind] semantic_realm]]]]
    [set semantic_plan_object start_plan_operator start_plan_operator]
    semantic_plan_object]]

[deftypefunk nonsemantic_plan get semantic_plan_object []
  [if [null internal-semantic_plan_object]
      [= internal-semantic_plan_object [get this __semantic_plan_object]]]
  internal-semantic_plan_object]

