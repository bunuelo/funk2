'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'plan_mental_layer'

[deframe plan_mental_layer [mental_layer] [object_knowledge_base_name
					   object_type_knowledge_base_name
					   object_type_counterfactual_knowledge_base_name
					   deliberative_knowledge_base_name
					   deliberative_type_knowledge_base_name
					   trace_knowledge_base_names
					   [plan_action_natural_language_symbol_ptypehash     [new ptypehash]]
					   [semantic_plan_phenomenal_name_frame               [new frame]]
					   [knowledge_symbol_set_initialized_mutex            [new mutex]]
					   [knowledge_symbol_set_initialized                  nil]
					   [knowledge_symbol_set                              [new set]]
					   [memoized_plans_by_name_ptypehash                  [new ptypehash]]]
  [new [initial-number initial-name
		       initial-object_knowledge_base_name
		       initial-object_type_knowledge_base_name
		       initial-object_type_counterfactual_knowledge_base_name
		       initial-deliberative_knowledge_base_name
		       initial-deliberative_type_knowledge_base_name
		       initial-trace_knowledge_base_names]
       [construct mental_layer initial-number initial-name]
       [= object_knowledge_base_name                     initial-object_knowledge_base_name]
       [= object_type_knowledge_base_name                initial-object_type_knowledge_base_name]
       [= object_type_counterfactual_knowledge_base_name initial-object_type_counterfactual_knowledge_base_name]
       [= deliberative_knowledge_base_name               initial-deliberative_knowledge_base_name]
       [= deliberative_type_knowledge_base_name          initial-deliberative_type_knowledge_base_name]
       [= trace_knowledge_base_names                     initial-trace_knowledge_base_names]
       [parog [have this add_agency [new plan_mental_layer_object_type_agency
					 object_knowledge_base_name
					 object_type_knowledge_base_name
					 object_type_counterfactual_knowledge_base_name]]
	      [have this add_agency [new plan_mental_layer_plan_agency
					 deliberative_knowledge_base_name
					 deliberative_type_knowledge_base_name
					 trace_knowledge_base_names]]
	      [have this add_agency [new plan_mental_layer_execution_agency   trace_knowledge_base_names]]
	      [have this add_agency [new plan_mental_layer_imagination_agency trace_knowledge_base_names]]]]]




[deftypefunk plan_mental_layer execute add_plan_action [action]
  [terminal_format standard-terminal '\n' [get this name] ': adding plan action, "' [get action as-string] '."']
  [have plan_action_natural_language_symbol_ptypehash add [get action as-natural_language_symbol] action]]

[deftypefunk plan_mental_layer get plan_actions []
  [get plan_action_natural_language_symbol_ptypehash values]]

[deftypefunk plan_mental_layer execute lookup_plan_action [natural_language_string]
  [have plan_action_natural_language_symbol_ptypehash lookup [string-as-natural_language_symbol natural_language_string]]]

[deftypefunk plan_mental_layer execute create_plan_action [layer_name agency_name resource_name :rest resource_arguments]
  [let [[action [new deliberative_action
		     [get this mind]
		     layer_name
		     agency_name
		     resource_name
		     resource_arguments]]]
    [have this add_plan_action action]]]

[deftypefunk plan_mental_layer execute lookup_action [natural_language_string]
  [have this lookup_plan_action natural_language_string]]


[deftypefunk plan_mental_layer execute add_semantic_object_recursive [semantic_object]
  [cond [[is-type `semantic_plan_operator_sequence    semantic_object] [prog [have [get [get this mind] semantic_knowledge_base deliberative_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[past_operator   [get semantic_object past_operator]]
										   [future_operator [get semantic_object future_operator]]]
									       [have this add_semantic_object_recursive past_operator]
									       [have this add_semantic_object_recursive future_operator]]]]
	[[is-type `semantic_plan_operator_parallel    semantic_object] [prog [have [get [get this mind] semantic_knowledge_base deliberative_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[plan_operator_set [semantic-lookup_set semantic_object plan_operator]]]
									       [mapc [funk [plan_operator]
											   [have this add_semantic_object_recursive plan_operator]]
										     [get plan_operator_set elements]]]]]
	[[is-type `semantic_plan_operator_activation  semantic_object] [prog [have [get [get this mind] semantic_knowledge_base deliberative_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[counterfactual_transframe [get semantic_object counterfactual_transframe]]]
									       [have this add_semantic_object_recursive counterfactual_transframe]]]]
	[[is-type `semantic_plan_operator_suppression semantic_object] [prog [have [get [get this mind] semantic_knowledge_base deliberative_knowledge_base_name] add_semantic_frame semantic_object]
									     ]]
	[[is-type `semantic_counterfactual_transframe semantic_object] [prog [have [get [get this mind] semantic_knowledge_base deliberative_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[resource_activation_dependency [get semantic_object resource_activation_dependency]]]
									       [have this add_semantic_object_recursive resource_activation_dependency]]]]
	[[is-type `semantic_resource                  semantic_object] [prog [have [get [get this mind] semantic_knowledge_base deliberative_knowledge_base_name] add_semantic_frame semantic_object]
									     ]]
	]]

[deftypefunk plan_mental_layer execute add_semantic_plan [semantic_plan]
  [terminal_format standard-terminal '\n' [type this] ': adding plan, "' [get [get [get semantic_plan nonsemantic_plan] unique_name] as-string] '."']
  [have [get [get this mind] semantic_knowledge_base deliberative_knowledge_base_name] add_semantic_frame semantic_plan]
  [let [[start_plan_operator [get semantic_plan start_plan_operator]]]
    [have this add_semantic_object_recursive start_plan_operator]]
  [have semantic_plan_phenomenal_name_frame add [get semantic_plan phenomenal_name] semantic_plan]
  [have [get [get this mental_layer] agency `plan] create_plan_propositionalized_actions [get semantic_plan phenomenal_name]]]

[deftypefunk plan_mental_layer execute lookup_semantic_plan [phenomenal_name]
  [have semantic_plan_phenomenal_name_frame lookup phenomenal_name]]

[deftypefunk plan_mental_layer get semantic_plan [phenomenal_name]
  [let [[semantic_plan [have this lookup_semantic_plan phenomenal_name]]]
    [if [null semantic_plan]
	[error bug_type             `plan_mental_layer-semantic_plan-not_found
	       plan_phenomenal_name phenomenal_name]]
    semantic_plan]]

[deftypefunk plan_mental_layer get semantic_plan_objects []
  [get semantic_plan_phenomenal_name_frame values]]

[deftypefunk plan_mental_layer get semantic_plans []
  [get this semantic_plan_objects]]

[deftypefunk plan_mental_layer execute lookup_semantic_plan_matches [name_expression]
  [let [[semantic_plan_matches nil]]
    [mapc [funk [semantic_plan_object]
		[let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
		  [let [[semantic_plan_object-name_pattern_match_pairs [get nonsemantic_plan name_pattern_match_pairs name_expression]]]
		    [mapc [funk [semantic_plan_object-name_pattern_match_pair]
				[let [[semantic_plan_match [frame semantic_plan_object semantic_plan_object
								  name_pattern         [car semantic_plan_object-name_pattern_match_pair]
								  variable_frame       [cdr semantic_plan_object-name_pattern_match_pair]]]]
				  [= semantic_plan_matches [cons semantic_plan_match semantic_plan_matches]]]]
			  semantic_plan_object-name_pattern_match_pairs]]]]
	  [get this semantic_plan_objects]]
    semantic_plan_matches]]

[deftypefunk plan_mental_layer get plan_by_name [plan_name]
  [let [[semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]]
    [let [[semantic_plans [have memoized_plans_by_name_ptypehash lookup semantic_plan_object-phenomenal_name]]]
      [if [null semantic_plans]
	  [let [[semantic_plan_matches [have this lookup_semantic_plan_matches plan_name]]]
	    [mapc [funk [semantic_plan_match]
			[terminal_format standard-terminal '\n' [get this name] ' nonsemantic_plan: semantic_plan_match = ' `semantic_plan_match]
			[let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
			      [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
			      [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
			  [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' match-variable_frame]
			  [if [null match-semantic_plan_object]
			      [error bug_name    `nonsemantic_plan-plan-no_such_plan
				     action_name semantic_plan_object-phenomenal_name]
			    [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
				   [new_nonsemantic_plan   [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
				   [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
			      [= semantic_plans [cons new_semantic_plan_object semantic_plans]]]]]]
		  semantic_plan_matches]]]
      [if semantic_plans
	  [let [[good_semantic_plans nil]]
	    [mapc [funk [semantic_plan]
			[if [not [get [get semantic_plan nonsemantic_plan] imagined_complete_failure]]
			    [= good_semantic_plans [cons semantic_plan good_semantic_plans]]]]
		  semantic_plans]
	    [have memoized_plans_by_name_ptypehash add semantic_plan_object-phenomenal_name good_semantic_plans]
	    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
	      [mapc [funk [good_semantic_plan]
			  [have result_multiple_possible_values add_value [new nonsemantic_plan_value good_semantic_plan]]]
		    good_semantic_plans]
	      result_multiple_possible_values]]
	[error bug_name    `could_not_find_matching_semantic_plans
	       is_plan_bug t
	       funkname    `plan
	       plan_name   plan_name]]]]]

