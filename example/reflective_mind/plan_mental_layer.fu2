'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'plan_mental_layer'

[deframe plan_mental_layer [mental_layer controllable_object] [object_knowledge_base_name
							       object_type_knowledge_base_name
							       object_type_counterfactual_knowledge_base_name
							       reflective_type_knowledge_base_name
							       resource_knowledge_base_name
							       trace_knowledge_base_names
							       [action_natural_language_symbol_ptypehash [new ptypehash]]
							       [semantic_plan_phenomenal_name_frame      [new frame]]
							       [knowledge_symbol_set_initialized_mutex   [new mutex]]
							       [knowledge_symbol_set_initialized         nil]
							       [knowledge_symbol_set                     [new set]]
							       [memoized_plans_by_name_ptypehash         [new ptypehash]]]
  [new [initial-number initial-name
		       initial-object_knowledge_base_name
		       initial-object_type_knowledge_base_name
		       initial-object_type_counterfactual_knowledge_base_name
		       initial-reflective_knowledge_base_name
		       initial-reflective_type_knowledge_base_name
		       initial-resource_knowledge_base_name
		       initial-trace_knowledge_base_names]
       [construct mental_layer initial-number initial-name]
       [construct controllable_object initial-reflective_knowledge_base_name]
       [= object_knowledge_base_name                     initial-object_knowledge_base_name]
       [= object_type_knowledge_base_name                initial-object_type_knowledge_base_name]
       [= object_type_counterfactual_knowledge_base_name initial-object_type_counterfactual_knowledge_base_name]
       [= reflective_type_knowledge_base_name            initial-reflective_type_knowledge_base_name]
       [= resource_knowledge_base_name                   initial-resource_knowledge_base_name]
       [= trace_knowledge_base_names                     initial-trace_knowledge_base_names]
       [parog [have this add_agency [new plan_mental_layer_object_type_agency
					 object_knowledge_base_name
					 object_type_knowledge_base_name
					 object_type_counterfactual_knowledge_base_name]]
	      [have this add_agency [new plan_mental_layer_plan_agency
					 reflective_knowledge_base_name
					 reflective_type_knowledge_base_name
					 resource_knowledge_base_name
					 trace_knowledge_base_names]]
	      [have this add_agency [new plan_mental_layer_execution_agency          resource_knowledge_base_name trace_knowledge_base_names]]
	      [have this add_agency [new plan_mental_layer_imagination_agency        resource_knowledge_base_name trace_knowledge_base_names]]
	      [have this add_agency [new plan_mental_layer_resource_knowledge_agency]]]]]

[deftypefunk plan_mental_layer execute create_knowledge []
  [type-have controllable_object this create_knowledge]
  [have [get this agency `object_type] create_knowledge]]

[deftypefunk plan_mental_layer execute connect_knowledge_reflection []
  [have [get this agency `plan]        connect_knowledge_reflection]
  [have [get this agency `object_type] connect_knowledge_reflection]]

[deftypefunk plan_mental_layer execute create_builtin_actions []
  [have [get this agency `imagination] create_builtin_actions]
  [have [get this agency `plan]        create_builtin_actions]]

[deftypefunk plan_mental_layer get object_type_knowledge_reflective_timer []
  [get [get this agency `object_type] object_type_knowledge_reflective_timer]]

[deftypefunk plan_mental_layer get knowledge_timer []
  [get [get this agency `object_type] knowledge_timer]]

[deftypefunk plan_mental_layer execute add_remember_token [remember_token]
  [have [get this agency `object_type] add_remember_token remember_token]]

[deftypefunk plan_mental_layer execute remove_remember_token [remember_token]
  [have [get this agency `object_type] remove_remember_token remember_token]]

[deftypefunk plan_mental_layer execute wait_until_time_represented [semantic_time]
  [have [get this agency `object_type] wait_until_time_represented semantic_time]]

[deftypefunk plan_mental_layer execute wait_until_after_time_represented [semantic_time]
  [have [get this agency `object_type] wait_until_after_time_represented semantic_time]]

[deftypefunk plan_mental_layer get type_knowledge_base []
  [get [get this agency `object_type] object_type_knowledge_base]]

[deftypefunk plan_mental_layer get counterfactual_knowledge_base []
  [get [get this agency `object_type] object_type_counterfactual_knowledge_base]]

[deftypefunk plan_mental_layer get semantic_planner []
  [get [get this agency `plan] semantic_planner]]

[deftypefunk plan_mental_layer execute add_semantic_object_recursive [semantic_object]
  [cond [[is-type `semantic_plan_operator_sequence    semantic_object] [prog [have [get [get this mind] semantic_knowledge_base reflective_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[past_operator   [get semantic_object past_operator]]
										   [future_operator [get semantic_object future_operator]]]
									       [have this add_semantic_object_recursive past_operator]
									       [have this add_semantic_object_recursive future_operator]]]]
	[[is-type `semantic_plan_operator_parallel    semantic_object] [prog [have [get [get this mind] semantic_knowledge_base reflective_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[plan_operator_set [semantic-lookup_set semantic_object plan_operator]]]
									       [mapc [funk [plan_operator]
											   [have this add_semantic_object_recursive plan_operator]]
										     [get plan_operator_set elements]]]]]
	[[is-type `semantic_plan_operator_activation  semantic_object] [prog [have [get [get this mind] semantic_knowledge_base reflective_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[counterfactual_transframe [get semantic_object counterfactual_transframe]]]
									       [have this add_semantic_object_recursive counterfactual_transframe]]]]
	[[is-type `semantic_plan_operator_suppression semantic_object] [prog [have [get [get this mind] semantic_knowledge_base reflective_knowledge_base_name] add_semantic_frame semantic_object]
									     ]]
	[[is-type `semantic_counterfactual_transframe semantic_object] [prog [have [get [get this mind] semantic_knowledge_base reflective_knowledge_base_name] add_semantic_frame semantic_object]
									     [let [[resource_activation_dependency [get semantic_object resource_activation_dependency]]]
									       [have this add_semantic_object_recursive resource_activation_dependency]]]]
	[[is-type `semantic_resource                  semantic_object] [prog [have [get [get this mind] semantic_knowledge_base reflective_knowledge_base_name] add_semantic_frame semantic_object]
									     ]]
	]]

[deftypefunk plan_mental_layer execute add_semantic_plan [semantic_plan]
  [terminal_format standard-terminal '\n' [type this] ': adding plan, "' [get [get [get semantic_plan nonsemantic_plan] unique_name] as-string] '."']
  [have [get [get this mind] semantic_knowledge_base reflective_knowledge_base_name] add_semantic_frame semantic_plan]
  [let [[start_plan_operator [get semantic_plan start_plan_operator]]]
    [have this add_semantic_object_recursive start_plan_operator]]
  [have semantic_plan_phenomenal_name_frame add [get semantic_plan phenomenal_name] semantic_plan]
  [have [get [get this mental_layer] agency `plan] create_plan_propositionalized_actions [get semantic_plan phenomenal_name]]]

[deftypefunk plan_mental_layer execute create_semantic_plan [name_expression name_patterns variable_definitions expression]
  [let [[plan [new nonsemantic_plan 
		   [get this mental_layer]
		   name_expression
		   name_patterns
		   variable_definitions
		   expression]]]
    [let [[semantic_plan_object [get plan semantic_plan_object]]]
      [have this add_semantic_plan semantic_plan_object]]]]

[deftypefunk plan_mental_layer execute lookup_semantic_plan [phenomenal_name]
  [have semantic_plan_phenomenal_name_frame lookup phenomenal_name]]

[deftypefunk plan_mental_layer get semantic_plan [phenomenal_name]
  [let [[semantic_plan [have this lookup_semantic_plan phenomenal_name]]]
    [if [null semantic_plan]
	[error bug_type             `plan_mental_layer-semantic_plan-not_found
	       plan_phenomenal_name phenomenal_name]]
    semantic_plan]]

[deftypefunk plan_mental_layer get semantic_plan_objects []
  [get semantic_plan_phenomenal_name_frame values]]

[deftypefunk plan_mental_layer get semantic_plans []
  [get this semantic_plan_objects]]

[deftypefunk plan_mental_layer execute lookup_semantic_plan_matches [name_expression]
  [let [[semantic_plan_matches nil]]
    [mapc [funk [semantic_plan_object]
		[let [[nonsemantic_plan [get semantic_plan_object nonsemantic_plan]]]
		  [let [[semantic_plan_object-name_pattern_match_pairs [get nonsemantic_plan name_pattern_match_pairs name_expression]]]
		    [mapc [funk [semantic_plan_object-name_pattern_match_pair]
				[let [[semantic_plan_match [frame semantic_plan_object semantic_plan_object
								  name_pattern         [car semantic_plan_object-name_pattern_match_pair]
								  variable_frame       [cdr semantic_plan_object-name_pattern_match_pair]]]]
				  [= semantic_plan_matches [cons semantic_plan_match semantic_plan_matches]]]]
			  semantic_plan_object-name_pattern_match_pairs]]]]
	  [get this semantic_plan_objects]]
    semantic_plan_matches]]

[deftypefunk plan_mental_layer get plan_by_name [plan_name]
  [let [[semantic_plan_object-phenomenal_name [nonsemantic_plan-unique_name_from_name_expression plan_name]]]
    [let [[semantic_plans [have memoized_plans_by_name_ptypehash lookup semantic_plan_object-phenomenal_name]]]
      [if [null semantic_plans]
	  [let [[semantic_plan_matches [have this lookup_semantic_plan_matches plan_name]]]
	    [mapc [funk [semantic_plan_match]
			[terminal_format standard-terminal '\n' [get this name] ' nonsemantic_plan: semantic_plan_match = ' `semantic_plan_match]
			[let [[match-semantic_plan_object [have semantic_plan_match lookup `semantic_plan_object]]
			      [match-variable_frame       [have semantic_plan_match lookup `variable_frame]]
			      [match-pattern_name         [have semantic_plan_match lookup `pattern_name]]]
			  [terminal_format standard-terminal '\nfound plan with variable frame! "' match-pattern_name '" ' match-variable_frame]
			  [if [null match-semantic_plan_object]
			      [error bug_name    `nonsemantic_plan-plan-no_such_plan
				     action_name semantic_plan_object-phenomenal_name]
			    [let* [[match-nonsemantic_plan [get match-semantic_plan_object nonsemantic_plan]]
				   [new_nonsemantic_plan   [get match-nonsemantic_plan new_copy_given_variable_frame match-variable_frame]]
				   [new_semantic_plan_object [get new_nonsemantic_plan semantic_plan_object]]]
			      [= semantic_plans [cons new_semantic_plan_object semantic_plans]]]]]]
		  semantic_plan_matches]]]
      [if semantic_plans
	  [let [[good_semantic_plans nil]]
	    [mapc [funk [semantic_plan]
			[if [not [get [get semantic_plan nonsemantic_plan] imagined_complete_failure]]
			    [= good_semantic_plans [cons semantic_plan good_semantic_plans]]]]
		  semantic_plans]
	    [have memoized_plans_by_name_ptypehash add semantic_plan_object-phenomenal_name good_semantic_plans]
	    [let [[result_multiple_possible_values [new multiple_possible_values nil]]]
	      [mapc [funk [good_semantic_plan]
			  [have result_multiple_possible_values add_value [new nonsemantic_plan_value good_semantic_plan]]]
		    good_semantic_plans]
	      result_multiple_possible_values]]
	[error bug_name    `could_not_find_matching_semantic_plans
	       is_plan_bug t
	       funkname    `plan
	       plan_name   plan_name]]]]]

[deftypefunk plan_mental_layer execute imagine_check_exists [semantic_partial_state]
  [let [[looking_for_event-phenomenal_name [get semantic_partial_state phenomenal_name]]]
    [terminal_format standard-terminal '\n' [type this] '-imagine_check_exists: checking if relationship exists ' looking_for_event-phenomenal_name '.']
    [let [[found_events nil]
	  [imagine_time cause-imagine_time]]
      [terminal_format standard-terminal '\n' [type this] '-imagine_check_exists: imagine_time = ' imagine_time]
      [let [[current_events [get [get this counterfactual_knowledge_base] events_containing_time imagine_time]]]
	[mapc [funk [current_event]
		    `[terminal_format standard-terminal '\n' [type this] '-imagine_check_exists: current_event: ' [get current_event phenomenal_name] '.']
		    [if [eq looking_for_event-phenomenal_name [get current_event phenomenal_name]]
			[prog [terminal_format standard-terminal '\n' [type this] '-imagine_check_exists: found relationship!']
			      [= found_events [cons current_event found_events]]]]]
	      current_events]]
      [let [[found_events-length [length found_events]]]
	[cond [[== found_events-length 0] [prog [terminal_format standard-terminal '\n' [type this] '-imagine_check_exists: did not find relationship.']
						nil]]
	      [[== found_events-length 1] [prog [terminal_format standard-terminal '\n' [type this] '-imagine_check_exists: found exactly one matching relationship:'
								 '\n  ' [car found_events]]
						[car found_events]]]
	      [t                          [prog [terminal_format standard-terminal '\n' [type this] '-imagine_check_exists: found multiple matching relationships...']
						[mapc [funk [found_event]
							    [terminal_format standard-terminal '\n' [type this] ' relationship: ' found_event]]
						      found_events]
						[new multiple_possible_values found_events]]]]]]]]

[deftypefunk plan_mental_layer execute evaluate_plan_expression [expression]
  [let* [[name_expression      [format nil 'evaluate unnamed ' [get this name] ' plan expression']]
	 [name_patterns        nil]
	 [argument_definitions nil]
	 [plan                 [new nonsemantic_plan this
				    name_expression
				    name_patterns
				    argument_definitions
				    expression]]]
    [let [[semantic_plan_object [get plan semantic_plan_object]]]
      [set semantic_plan_object plan_object_type [get this name]]
      [let [[variable_frame [new frame]]]
	[let [[result [have plan execute_as_thought variable_frame]]]
	  [if [is-type `bug result]
	      [let [[bug result]]
		[bug bug]]
	    result]]]]]]

[deftypefunk plan_mental_layer execute imagine_plan_expression [expression]
  [let* [[name_expression      'imagine unnamed plan expression']
	 [name_patterns        nil]
	 [argument_definitions nil]
	 [plan                 [new nonsemantic_plan this
				    name_expression
				    name_patterns
				    argument_definitions
				    expression]]]
    [let [[semantic_plan_object [get plan semantic_plan_object]]]
      [set semantic_plan_object plan_object_type [get this name]]
      [let [[variable_frame [new frame]]]
	[let [[result [have plan imagine_as_thought variable_frame]]]
	  [if [is-type `bug result]
	      [let [[bug result]]
		[bug bug]]
	    result]]]]]]

[deftypefunk plan_mental_layer execute assure_knowledge_symbols_initialized []
  [have knowledge_symbol_set_initialized_mutex lock]
  [if [not knowledge_symbol_set_initialized]
      [prog [mapc [funk [knowledge_symbol]
			[have knowledge_symbol_set add knowledge_symbol]]
		  [append [get [get this mind] all_perception_symbols]
			  `[property
			    relationship
			    relation
			    preposition
			    is-me
			    t]]]
	    [= knowledge_symbol_set_initialized t]]]
  [have knowledge_symbol_set_initialized_mutex unlock]]

[deftypefunk plan_mental_layer get all_knowledge_symbols []
  [have this assure_knowledge_symbols_initialized]
  [get knowledge_symbol_set elements]]

[deftypefunk plan_mental_layer get knowledge_symbol [value]
  [have this assure_knowledge_symbols_initialized]
  [let [[symbol [if [is-type `symbol value]
		    value
		  [get string as-symbol]]]]
    [if [get knowledge_symbol_set contains symbol]
	symbol
      [prog [terminal_format standard-terminal '\n' [get this type] '-get-knowledge_symbol failure: unknown symbol (' symbol ')']
	    [error bug_name             `plan_mental_layer-get-string_as_knowledge_symbol-no_such_knowledge_symbol
		   this                 this
		   string               string
		   symbol               symbol
		   knowledge_symbol_set knowledge_symbol_set]]]]]


