'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'reflective_layer'

[deframe reflective_layer [plan_mental_layer] []
  [new []
       [construct plan_mental_layer 3 `reflective
		  `deliberative1_knowledge
		  `deliberative1_type_knowledge
		  `deliberative1_type_counterfactual_knowledge
		  `deliberative2_knowledge
		  nil
		  nil]
       [parog [have this add_agency [new reflective_plan_bug_response_agency]]
	      [have this add_agency [new reflective_event_knowledge_agency]]
	      [have this add_agency [new reflective_credit_assignment_agency]]]]]

[deftypefunk reflective_layer get mental_layer_below []
  [get [get this mind] layer `deliberative]]

[deftypefunk reflective_layer execute create_knowledge []
  [have [get this agency `deliberative1_object_type]  create_knowledge]
  [have [get this agency `reflective_event_knowledge] create_knowledge]
  [have [get this agency `plan]                       create_knowledge]
  nil]

[deftypefunk reflective_layer execute connect_knowledge_reflection []
  [have [get this agency `deliberative1_object_type]      connect_knowledge_reflection]
  [have [get this agency `reflective_event_knowledge] connect_knowledge_reflection]
  [have [get this agency `plan]                       connect_knowledge_reflection]
  nil]

[deftypefunk reflective_layer execute create_builtin_actions []
  [have [get this agency `imagination] create_builtin_actions]
  [have [get this agency `plan]        create_builtin_actions]]

[deftypefunk reflective_layer get knowledge_timer []
  [get [get this agency `deliberative1_object_type] knowledge_timer]]

[deftypefunk reflective_layer execute add_remember_token [remember_token]
  [have [get this agency `deliberative1_object_type] add_remember_token remember_token]]

[deftypefunk reflective_layer execute remove_remember_token [remember_token]
  [have [get this agency `deliberative1_object_type] remove_remember_token remember_token]]

[deftypefunk reflective_layer execute wait_until_time_represented [semantic_time]
  [have [get this agency `deliberative1_object_type] wait_until_time_represented semantic_time]]

[deftypefunk reflective_layer execute wait_until_after_time_represented [semantic_time]
  [have [get this agency `deliberative1_object_type] wait_until_after_time_represented semantic_time]]

[deftypefunk reflective_layer execute lookup_action_below [natural_language_string]
  [have [get [get this mind] layer `deliberative] lookup_action natural_language_string]]

[deftypefunk reflective_layer get type_knowledge_base []
  [get [get this mind] semantic_knowledge_base `deliberative1_type_knowledge]]

[deftypefunk reflective_layer get counterfactual_knowledge_base []
  [get [get this mind] semantic_knowledge_base `deliberative1_type_counterfactual_knowledge]]

[deftypefunk reflective_layer get semantic_planner []
  [get [get this agency `plan] semantic_planner]]

[deftypefunk reflective_layer execute create_semantic_plan [name_expression name_patterns variable_definitions expression]
  [let [[plan [new nonsemantic_plan 
		   [get this mental_layer]
		   name_expression
		   name_patterns
		   variable_definitions
		   expression]]]
    [let [[semantic_plan_object [get plan semantic_plan_object]]]
      [set semantic_plan_object plan_object_type `reflective]
      [have this add_semantic_plan semantic_plan_object]]]]



[deftypefunk reflective_layer get physical_semantic_action [phenomenal_name]
  [get [get this agency `reflective_event_knowledge] physical_semantic_action phenomenal_name]]

[deftypefunk reflective_layer get deliberative1_semantic_action [phenomenal_name]
  [get [get this agency `reflective_event_knowledge] deliberative1_semantic_action phenomenal_name]]


[deftypefunk reflective_layer get deliberative1_type_knowledge_reflective_timer []
  [get [get this agency `deliberative1_object_type] deliberative1_type_knowledge_reflective_timer]]

[deftypefunk reflective_layer execute check_exists [semantic_partial_state]
  [let [[looking_for_event-phenomenal_name [get semantic_partial_state phenomenal_name]]
	[remember_token                    [new remember_token [new semantic_time [time]]]]]
    [terminal_format standard-terminal '\nreflective_layer-check_exists: checking if partial state exists: ' looking_for_event-phenomenal_name '.']
    [terminal_format standard-terminal '\nreflective_layer-check_exists: adding remember token.']
    [have this add_remember_token remember_token]
    [terminal_format standard-terminal '\nreflective_layer-check_exists: done adding remember token.']
    [let [[current_time [time]]]
      [terminal_format standard-terminal '\nreflective_layer-check_exists: waiting until ' [get current_time as-string] ' represented.']
      [have this wait_until_time_represented [new semantic_time current_time]]]
    [let [[found nil]]
      [let [[current_events [get [get this type_knowledge_base] events_containing_time [new semantic_time [time]]]]]
	[mapc [funk [current_event]
		    `[terminal_format standard-terminal '\nreflective_layer-check_exists: current_event, ' [get current_event phenomenal_name] '.']
		    [if [eq looking_for_event-phenomenal_name [get current_event phenomenal_name]]
			[prog [terminal_format standard-terminal '\nreflective_layer-check_exists: found relationship!']
			      [= found t]]]]
	      current_events]]
      [if [not found]
	  [terminal_format standard-terminal '\nreflective_layer-check_exists: did not find relationship.']
	[terminal_format standard-terminal '\nreflective_layer-check_exists: found relationship!']]
      [terminal_format standard-terminal '\nreflective_layer-check_exists: removing remember token.']
      [have this remove_remember_token remember_token]
      [terminal_format standard-terminal '\nreflective_layer-check_exists: done removing remember token.']
      found]]]

[deftypefunk reflective_layer execute imagine_check_exists [semantic_partial_state]
  [let [[looking_for_event-phenomenal_name [get semantic_partial_state phenomenal_name]]]
    [terminal_format standard-terminal '\n' [get this name] '-imagine_check_exists: imagining checking if partial state exists: ' looking_for_event-phenomenal_name '.']
    [let [[found_events nil]
	  [imagine_time cause-imagine_time]]
      [terminal_format standard-terminal '\n' [get this name] '-imagine_check_exists: imagine_time = ' imagine_time]
      [let [[current_events [get [get this counterfactual_knowledge_base] events_containing_time imagine_time]]]
	[mapc [funk [current_event]
		    `[terminal_format standard-terminal '\n' [get this name] '-imagine_check_exists: current_event, ' [get current_event phenomenal_name] '.']
		    [if [eq looking_for_event-phenomenal_name [get current_event phenomenal_name]]
			[prog [terminal_format standard-terminal '\nreflective_layer-imagine_check_exists: found relationship!']
			      [= found_events [cons current_event found_events]]]]]
	      current_events]]
      [let [[found_events-length [length found_events]]]
	[cond [[== found_events-length 0] [prog [terminal_format standard-terminal '\n' [get this name] '-imagine_check_exists: did not find relationship.']
						nil]]
	      [[== found_events-length 1] [prog [terminal_format standard-terminal '\n' [get this name] '-imagine_check_exists: found exactly one matching relationship:'
								 '\n  ' [car found_events]]
						[car found_events]]]
	      [t                          [prog [terminal_format standard-terminal '\n' [get this name] '-imagine_check_exists: found multiple matching relationships...']
						[mapc [funk [found_event]
							    [terminal_format standard-terminal '\n' [get this name] ' relationship: ' found_event]]
						      found_events]
						[new multiple_possible_values found_events]]]]]]]]

[deftypefunk reflective_layer execute wait_for [semantic_partial_state]
  [let [[looking_for_event-phenomenal_name [get semantic_partial_state phenomenal_name]]]
    [terminal_format standard-terminal '\nwaiting for relationship: looking for event, ' looking_for_event-phenomenal_name '.']
    [let [[done nil]]
      [while [not done]
	[let [[current_events [get [get this type_knowledge_base] events_containing_time [new semantic_time [time]]]]]
	  [mapc [funk [current_event]
		      `[terminal_format standard-terminal '\nwaiting for relationship: current_event, ' [get current_event phenomenal_name] '.']
		      [if [eq looking_for_event-phenomenal_name [get current_event phenomenal_name]]
			  [prog [terminal_format standard-terminal '\nwait_for_deliberative1_relationship: done waiting!']
				[= done t]]]]
		current_events]]
	[if [not done]
	    [let [[end_of_object_type_changes_trigger [get [get [get this mind] resource `reflective `object_type `translate_object_knowledge_to_object_type_knowledge] end_of_object_type_changes_trigger]]]
	      [wait-for-trigger end_of_object_type_changes_trigger]]]]]]]

[deftypefunk reflective_layer execute assert [semantic_partial_state]
  [let [[looking_for_event-phenomenal_name [get semantic_partial_state phenomenal_name]]]
    [terminal_format standard-terminal '\nassuring relationship exists: ' looking_for_event-phenomenal_name '.']
    [let [[found nil]]
      [let [[current_events [get [get this type_knowledge_base] events_containing_time [new semantic_time [time]]]]]
	[mapc [funk [current_event]
		    `[terminal_format standard-terminal '\nassuring relationship: current_event, ' [get current_event phenomenal_name] '.']
		    [if [eq looking_for_event-phenomenal_name [get current_event phenomenal_name]]
			[prog [terminal_format standard-terminal '\nassure_deliberative1_relationship: found relationship!']
			      [= found t]]]]
	      current_events]]
      [if [not found]
	  [prog [terminal_format standard-terminal '\nassure_deliberative1_relationship: did not find relationship.']
		[error bug_name    `assertion-failed
		       description `[assert ,semantic_partial_state]]]
	nil]]]]

[deftypefunk reflective_layer execute imagine_asserting [semantic_partial_state]
  [let [[looking_for_event-phenomenal_name [get semantic_partial_state phenomenal_name]]]
    [terminal_format standard-terminal '\nimagining assuring relationship exists: ' looking_for_event-phenomenal_name '.']
    [let [[semantic_planner [get [get [get this mind] agency `reflective `plan] semantic_planner]]]
      [let [[found        nil]
	    [imagine_time cause-imagine_time]]
	[let [[current_events [get [get this counterfactual_knowledge_base] events_containing_time imagine_time]]]
	  [mapc [funk [current_event]
		      `[terminal_format standard-terminal '\nimagine assuring relationship: current_event, ' [get current_event phenomenal_name] '.']
		      [if [eq looking_for_event-phenomenal_name [get current_event phenomenal_name]]
			  [prog [terminal_format standard-terminal '\nimagine_assuring_deliberative1_relationship: found relationship!']
				[= found t]]]]
		current_events]]
	[if [not found]
	    [prog [terminal_format standard-terminal '\nimagine_assuring_deliberative1_relationship: did not find relationship.']
		  [error bug_name    `assertion-failed
			 description `[imagine_asserting ,semantic_partial_state]]]
	  nil]]]]]

[deftypefunk reflective_layer execute evaluate_plan_expression [expression]
  [let* [[name_expression      'evaluate unnamed plan expression']
	 [name_patterns        nil]
	 [argument_definitions nil]
	 [plan                 [new nonsemantic_plan [get this mental_layer]
				    name_expression
				    name_patterns
				    argument_definitions
				    expression]]]
    [let [[semantic_plan_object [get plan semantic_plan_object]]]
      [set semantic_plan_object plan_object_type `physical]
      [let [[variable_frame [new frame]]]
	[let [[result [have plan execute_as_thought variable_frame]]]
	  [if [is-type `bug result]
	      [let [[bug result]]
		[bug bug]]
	    result]]]]]]

[deftypefunk reflective_layer execute imagine_plan_expression [expression]
  [let* [[name_expression      'imagine unnamed plan expression']
	 [name_patterns        nil]
	 [argument_definitions nil]
	 [plan                 [new nonsemantic_plan [get this mental_layer]
				    name_expression
				    name_patterns
				    argument_definitions
				    expression]]]
    [let [[semantic_plan_object [get plan semantic_plan_object]]]
      [set semantic_plan_object plan_object_type `physical]
      [let [[variable_frame [new frame]]]
	[let [[result [have plan imagine_as_thought variable_frame]]]
	  [if [is-type `bug result]
	      [let [[bug result]]
		[bug bug]]
	    result]]]]]]

[deftypefunk reflective_layer execute assure_knowledge_symbols_initialized []
  [have knowledge_symbol_set_initialized_mutex lock]
  [if [not knowledge_symbol_set_initialized]
      [prog [mapc [funk [knowledge_symbol]
			[have knowledge_symbol_set add knowledge_symbol]]
		  [append [get [get this mind] all_perception_symbols]
			  `[property
			    relationship
			    relation
			    preposition
			    is-me
			    t]]]
	    [= knowledge_symbol_set_initialized t]]]
  [have knowledge_symbol_set_initialized_mutex unlock]]

[deftypefunk reflective_layer get all_knowledge_symbols []
  [have this assure_knowledge_symbols_initialized]
  [get knowledge_symbol_set elements]]

[deftypefunk reflective_layer get knowledge_symbol [value]
  [have this assure_knowledge_symbols_initialized]
  [let [[symbol [if [is-type `symbol value]
		    value
		  [get string as-symbol]]]]
    [if [get knowledge_symbol_set contains symbol]
	symbol
      [prog [terminal_format standard-terminal '\n' [get this type] '-get-knowledge_symbol failure: unknown symbol (' symbol ')']
	    [error bug_name             `deliberative_layer-get-string_as_knowledge_symbol-no_such_knowledge_symbol
		   string               string
		   symbol               symbol
		   knowledge_symbol_set knowledge_symbol_set]]]]]

