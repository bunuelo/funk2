'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'



'reflective_plan_object_type_goal_agency'

[deframe reflective_plan_object_type_goal_agency [agency] []
  [new []
       [construct agency `plan_object_type_goal]
       [have this add_resource [new translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource]]
       ]]

[deftypefunk reflective_plan_object_type_goal_agency execute create_knowledge []
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `type_copy_of_deliberative1_knowledge        [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `deliberative1_type_knowledge                [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `deliberative1_goal_knowledge                [get [get this mind] semantic_realm]]]
  [have [get this mind] add_semantic_knowledge_base [new semantic_event_knowledge_base `deliberative1_counterfactual_type_knowledge [get [get this mind] semantic_realm]]]
  ]

[deftypefunk reflective_plan_object_type_goal_agency execute connect_knowledge_reflection []
  [have [get this mind] create_knowledge_event_stream_iterator `deliberative1_knowledge `deliberative1_knowledge->deliberative1_type_knowledge]
  ]

[deftypefunk reflective_plan_object_type_goal_agency get deliberative1_type_knowledge_reflective_timer []
  [get [get this resource `translate_deliberative1_knowledge_to_deliberative1_type_knowledge] deliberative1_type_knowledge_reflective_timer]]

[deftypefunk reflective_plan_object_type_goal_agency execute create_deliberative1_type_relationship_goal [source_plan_object_type key_type key target_plan_object_type]
  ]

[deftypefunk reflective_plan_object_type_goal_agency execute create_deliberative1_type_property_relationship_goal [source_type
														   source_type_property
														   source_type_property_value
														   key_type
														   key
														   target_type
														   target_type_property
														   target_type_property_value]
  [let [[resource [get this resource `translate_deliberative1_knowledge_to_deliberative1_type_knowledge]]]
    [let [[goal [new deliberative1_type_property_relation_goal
		     [get this mind]
		     source_type
		     source_type_property
		     source_type_property_value
		     key_type
		     key
		     target_type
		     target_type_property
		     target_type_property_value]]]
      [have resource add_goal goal]
      [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
		       'agency, ' name ', adding deliberative1 goal "' [get goal as-declarative_string] '."']
      ]]]



'translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource'

[deframe translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource [reflective_resource] [[semantic_reflective_object_type_event_mutex   [new mutex]]
													   [semantic_reflective_object_copy_mutex         [new mutex]]
													   [goals                                         nil]
													   [deliberative1_type_knowledge_reflective_timer [new reflective_timer [new semantic_time `before]]]]
  [new []
       [construct reflective_resource `translate_deliberative1_knowledge_to_deliberative1_type_knowledge
		  [funk []
			[have this execute_resource_raw_funk]
			]]
       [= vital t]
       nil]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource execute add_goal [goal]
  `[terminal_format standard-terminal '\nreflective_layer: adding plan goal, "' [get goal as-string] '."']
  [= goals [cons goal goals]]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource execute add_type_to_goal_states [event_time
															 semantic_reflective_object_type_event_source
															 key_type
															 key
															 semantic_reflective_object_type_event_target]
  [mapc [funk [goal]
	      [have goal add_type_event
		    event_time
		    semantic_reflective_object_type_event_source
		    key_type
		    key
		    semantic_reflective_object_type_event_target]]
	goals]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource execute remove_type_from_goal_states [event_time
															      semantic_reflective_object_type_event_source
															      key_type
															      key
															      semantic_reflective_object_type_event_target]
  [mapc [funk [goal]
	      [have goal remove_type_event
		    event_time
		    semantic_reflective_object_type_event_source
		    key_type
		    key
		    semantic_reflective_object_type_event_target]]
	goals]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource get semantic_reflective_object_copy [phenomenal_name reflective_object_type]
  [let [[semantic_reflective_object nil]]
    [have semantic_reflective_object_type_event_mutex lock]
    [let [[copy_phenomenal_name [get [format nil 'plan_type_copy_of_' phenomenal_name] as-symbol]]]
      [= semantic_reflective_object [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame copy_phenomenal_name]]
      [if [null semantic_reflective_object]
	  [prog [= semantic_reflective_object [new semantic_reflective_object [get [get this mind] semantic_realm]]]
		[set semantic_reflective_object phenomenal_name  phenomenal_name]
		[set semantic_reflective_object reflective_object_type reflective_object_type]
		[have [get [get this mind] semantic_knowledge_base `type_copy_of_deliberative1_knowledge] add_semantic_frame semantic_reflective_object]
		[have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame copy_phenomenal_name semantic_reflective_object]
		]]
      [have semantic_reflective_object_type_event_mutex unlock]
      semantic_reflective_object]]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource get semantic_reflective_object_type_event [phenomenal_name]
  [let [[semantic_reflective_object_type_event nil]]
    [have semantic_reflective_object_copy_mutex lock]
    [= semantic_reflective_object_type_event [have [get [get this mind] semantic_realm] lookup_phenomenon_semantic_frame phenomenal_name]]
    [if [null semantic_reflective_object_type_event]
	[prog [= semantic_reflective_object_type_event [new semantic_reflective_object_type_event [get [get this mind] semantic_realm]
							    [object_type_event-phenomenal_name phenomenal_name]
							    phenomenal_name]]
	      [have [get [get this mind] semantic_knowledge_base `deliberative1_type_knowledge] add_semantic_frame semantic_reflective_object_type_event]
	      [have [get [get this mind] semantic_realm] add_phenomenon_semantic_frame phenomenal_name semantic_reflective_object_type_event]
	      ]]
    [have semantic_reflective_object_copy_mutex unlock]
    semantic_reflective_object_type_event]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource get semantic_reflective_object_type_event_with_property_type [phenomenal_name property_key property property_value]
  [let [[object_type_with_propety_phenomenal_name [semantic_object_property_type_event-phenomenal_name phenomenal_name property_key property property_value]]]
    [get this semantic_reflective_object_type_event object_type_with_propety_phenomenal_name]]]

[defunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource-edge_is_type_property [source key_type key target]
  [and [is-type `semantic_reflective_object source]
       [not [and [eq `property key_type] [eq `plan_object_type key]]]
       [or [null target] [is-type `symbol target]]]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource get all_semantic_reflective_object_type_events [semantic_reflective_object]
  [let [[semantic_reflective_object_type_events nil]]
    [= semantic_reflective_object_type_events [cons [get this semantic_reflective_object_type_event [get semantic_reflective_object reflective_object_type]]
					    semantic_reflective_object_type_events]]
    [have semantic_reflective_object map_type_key_values
	  [funk [slot_type slot_key slot_value]
		[if [translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource-edge_is_type_property semantic_reflective_object slot_type slot_key slot_value]
		    [= semantic_reflective_object_type_events [cons [get this semantic_reflective_object_type_event_with_property_type
								 [get semantic_reflective_object reflective_object_type]
								 slot_type
								 slot_key
								 slot_value]
							    semantic_reflective_object_type_events]]]]]
    semantic_reflective_object_type_events]]

[defunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource-type_relation-phenomenal_name [source_type_event-phenomenal_name key_type key target_type_event-phenomenal_name]
  [get [string-concat [get source_type_event-phenomenal_name as-string]
		      '_'
		      [get key_type as-string]
		      '_'
		      [get key as-string]
		      '_'
		      [get target_type_event-phenomenal_name as-string]
		      '_plan_object_type_relation']
       as-symbol]]

[defunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource-type_property_relation-phenomenal_name [source_phenomenal_name
														 source_property_key
														 source_property
														 source_property_value
														 key_type
														 key
														 target_phenomenal_name
														 target_property_key
														 target_property
														 target_property_value]
  
  [semantic_object_relation_type_event-phenomenal_name [semantic_object_property_type_event-phenomenal_name source_phenomenal_name
													    source_property_key
													    source_property
													    source_property_value]
						       key_type
						       key
						       [semantic_object_property_type_event-phenomenal_name target_phenomenal_name
													    target_property_key
													    target_property
													    target_property_value]]]


[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource execute add_type_relation [event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]
  [if debug [terminal_format standard-terminal '\nadd_type_relation ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' [get semantic_reflective_object_type_event_target phenomenal_name]]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[relation_set [have semantic_reflective_object_type_event_source lookup_set compound_key [get semantic_reflective_object_type_event_target phenomenal_name]]]
	  [relation     nil]]
      [if [or [null relation_set] [get relation_set is_empty]]
	  [let [[relation-phenomenal_name   [translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource-type_relation-phenomenal_name [get semantic_reflective_object_type_event_source phenomenal_name]
																	    key_type
																	    key
																	    [get semantic_reflective_object_type_event_target phenomenal_name]]]
		[relation-meta_relationship [have [get [get this mind] semantic_realm] lookup_or_create_meta_relationship
						  semantic_reflective_object_type_event_source
						  key_type
						  key
						  semantic_reflective_object_type_event_target]]]
	    [= relation [new semantic_reflective_object_type_relation_event [get [get this mind] semantic_realm]
			     relation-phenomenal_name
			     relation-meta_relationship
			     semantic_reflective_object_type_event_target]]
	    [set relation absolute_start_time [new semantic_time event_time]]
	    [have [get [get this mind] semantic_knowledge_base `deliberative1_type_knowledge] add_semantic_frame relation]
	    [have semantic_reflective_object_type_event_source add compound_key [get semantic_reflective_object_type_event_target phenomenal_name] relation]
	    [have this add_type_to_goal_states event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]]
	[prog [= relation [get relation_set an_arbitrary_element]]
	      [set relation count [+ [get relation count] 1]]]]]]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource execute remove_type_relation [event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]
  [if debug [terminal_format standard-terminal '\nremove_type_relation ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' key_type ' ' key ' ' [get semantic_reflective_object_type_event_target phenomenal_name]]]
  [let [[compound_key [get [format nil [get key_type as-string] '_' [get key as-string]] as-symbol]]]
    [let [[relation_set [have semantic_reflective_object_type_event_source lookup_set compound_key [get semantic_reflective_object_type_event_target phenomenal_name]]]
	  [relation     nil]]
      [if [or [null relation_set] [get relation_set is_empty]]
	  [prog [terminal_format standard-terminal
				 '\nwarning: got remove ' [get semantic_reflective_object_type_event_source phenomenal_name] ' ' compound_key ' ' [get semantic_reflective_object_type_event_target phenomenal_name] ' relation, but no relation found.']
		]
	[prog [= relation [get relation_set an_arbitrary_element]]
	      [let [[relation-count [get relation count]]]
		[if [> relation-count 1]
		    [set relation count [- relation-count 1]]
		  [prog [have this remove_type_from_goal_states event_time semantic_reflective_object_type_event_source key_type key semantic_reflective_object_type_event_target]
			[have semantic_reflective_object_type_event_source remove compound_key [get semantic_reflective_object_type_event_target phenomenal_name] relation]
			`[have [get [get this mind] semantic_knowledge_base `deliberative1_type_knowledge] remove_semantic_frame relation]
			[set relation absolute_end_time [new semantic_time event_time]]
			]]]]]]]]

[deftypefunk translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource execute execute_resource_raw_funk []
  [let [[deliberative1_knowledge_iterator [get [get this mind] knowledge_event_stream_iterator `deliberative1_knowledge->deliberative1_type_knowledge]]]
    [while t
      [let [[event [have deliberative1_knowledge_iterator wait_for_current]]]
	[if [not [null event]]
	    [prog [if debug `[terminal_format standard-terminal '\n  translate plan->plan_type event: ' event]]
		  [let [[event_type [get event event_type]]]
		    [cond [[and [is-type `semantic_frame_event event]
				[eq event_type `add]]                          [let [[event-time           [get event time]]
										     [event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [set deliberative1_type_knowledge_reflective_timer current_time [new semantic_time event-time]]
										 [cond [[and [eq event-key_type `property] [eq event-key `reflective_object_type]]
											[prog 'create semantic_reflective_object_type_event.'
											      [get this semantic_reflective_object_type_event event-value]
											      [have event-semantic_frame map_type_key_values
												    [funk [slot_type slot_key slot_value]
													  [if [is-type `symbol slot_value]
													      [get this semantic_reflective_object_type_event_with_property_type event-value slot_type slot_key slot_value]]]]
											      ]]
										       [[is-type `semantic_object event-semantic_frame]
											[prog [let [[event-semantic_frame-copy              [get this semantic_reflective_object_copy [get event-semantic_frame phenomenal_name] [type event-semantic_frame] [if [is-type `semantic_plan_object event-semantic_frame]
																															   [get event-semantic_frame nonsemantic_plan]
																															 nil]]]
												    [event-value-copy                       [if [is-type `semantic_object event-value]
																		[get this semantic_reflective_object_copy [get event-value phenomenal_name] [type event-value] [if [is-type `semantic_plan_object event-value]
																													     [get event-value nonsemantic_plan]
																													   nil]]
																	      event-value]]]
												[if debug [terminal_format standard-terminal
															   '\nadding plan type ' [get event-semantic_frame-copy phenomenal_name]
															   ' '                       event-key_type
															   ' '                       event-key
															   ' '                       [if [is-type `semantic_reflective_object event-value-copy]
																			 [get event-value-copy phenomenal_name]
																		       event-value-copy]]]
												[have event-semantic_frame-copy add event-key_type event-key event-value-copy]
												'should use copy after this point'
												
												[cond [[translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource-edge_is_type_property event-semantic_frame-copy event-key_type event-key event-value-copy]
												       [let [[event-semantic_reflective_object_type_event [get this semantic_reflective_object_type_event_with_property_type
																			 [get event-semantic_frame-copy reflective_object_type]
																			 event-key_type
																			 event-key
																			 event-value-copy]]]
													 
													 [have event-semantic_frame-copy map_type_key_values
													       [funk [slot_type slot_key slot_value]
														     [if [is-type `semantic_reflective_object slot_value]
															 [mapc [funk [forward_semantic_reflective_object_type_event]
																     [have this add_type_relation event-time event-semantic_reflective_object_type_event slot_type slot_key forward_semantic_reflective_object_type_event]]
															       [get this all_semantic_reflective_object_type_events slot_value]]]]]
													 
													 [have event-semantic_frame-copy map_reverse_type_key_values
													       [funk [slot_type slot_key slot_value]
														     [if [is-type `semantic_reflective_object slot_value]
															 [mapc [funk [backward_semantic_reflective_object_type_event]
																     [have this add_type_relation event-time backward_semantic_reflective_object_type_event slot_type slot_key event-semantic_reflective_object_type_event]]
															       [get this all_semantic_reflective_object_type_events slot_value]]]]]
													 
													 ]]
												      [[and [eq event-key_type `preposition] [is-type `semantic_reflective_object event-value-copy]]
												       [let []
													 [mapc [funk [event-semantic_reflective_object_type_event]
														     [mapc [funk [event-value-semantic_reflective_object_type_event]
																 [have this add_type_relation event-time event-semantic_reflective_object_type_event event-key_type event-key event-value-semantic_reflective_object_type_event]]
															   [get this all_semantic_reflective_object_type_events event-value-copy]]]
													       [get this all_semantic_reflective_object_type_events event-semantic_frame-copy]]
													 ]]
												      ]
												]]]]
										 ]]
			  [[and [is-type `semantic_frame_event event]
				[eq event_type `remove]]                       [let [[event-time           [get event time]]
										     [event-semantic_frame [get event semantic_frame]]
										     [event-key_type       [get event key_type]]
										     [event-key            [get event key]]
										     [event-value          [get event value]]]
										 [cond [[and [eq event-key_type `property] [eq event-key `reflective_object_type]]
											[prog ]]
										       [[is-type `semantic_object event-semantic_frame]
											[prog [let [[event-semantic_frame-copy [get this semantic_reflective_object_copy [get event-semantic_frame phenomenal_name] [type event-semantic_frame] [if [is-type `semantic_plan_object event-semantic_frame]
																													      [get event-semantic_frame nonsemantic_plan]
																													    nil]]]
												    [event-value-copy          [if [is-type `semantic_object event-value]
																   [get this semantic_reflective_object_copy [get event-value phenomenal_name] [type event-value] [if [is-type `semantic_plan_object event-value]
																												[get event-value nonsemantic_plan]
																											      nil]]
																 event-value]]]
												'should use copy after this point'
												
												[cond [[translate_deliberative1_knowledge_to_deliberative1_type_knowledge_resource-edge_is_type_property event-semantic_frame-copy event-key_type event-key event-value-copy]
												       [let [[event-semantic_reflective_object_type_event [get this semantic_reflective_object_type_event_with_property_type
																			 [get event-semantic_frame-copy reflective_object_type]
																			 event-key_type
																			 event-key
																			 event-value-copy]]]
													 
													 [have event-semantic_frame-copy map_type_key_values
													       [funk [slot_type slot_key slot_value]
														     [if [is-type `semantic_reflective_object slot_value]
															 [mapc [funk [forward_semantic_reflective_object_type_event]
																     [have this remove_type_relation event-time event-semantic_reflective_object_type_event slot_type slot_key forward_semantic_reflective_object_type_event]]
															       [get this all_semantic_reflective_object_type_events slot_value]]]]]
													 
													 [have event-semantic_frame-copy map_reverse_type_key_values
													       [funk [slot_type slot_key slot_value]
														     [if [is-type `semantic_reflective_object slot_value]
															 [mapc [funk [backward_semantic_reflective_object_type_event]
																     [have this remove_type_relation event-time backward_semantic_reflective_object_type_event slot_type slot_key event-semantic_reflective_object_type_event]]
															       [get this all_semantic_reflective_object_type_events slot_value]]]]]
													 
													 ]]
												      [[and [eq event-key_type `preposition] [is-type `semantic_reflective_object event-value-copy]]
												       [let []
													 [mapc [funk [event-semantic_reflective_object_type_event]
														     [mapc [funk [event-value-semantic_reflective_object_type_event]
																 [have this remove_type_relation event-time event-semantic_reflective_object_type_event event-key_type event-key event-value-semantic_reflective_object_type_event]]
															   [get this all_semantic_reflective_object_type_events event-value-copy]]]
													       [get this all_semantic_reflective_object_type_events event-semantic_frame-copy]]
													 ]]
												      ]
												
												'remove from event-semantic_frame-copy'
												[if debug
												    [terminal_format standard-terminal
														     '\nremoving plan type ' [get event-semantic_frame-copy phenomenal_name]
														     ' '                         event-key_type
														     ' '                         event-key
														     ' '                         [if [is-type `semantic_reflective_object event-value-copy]
																		     [get event-value-copy phenomenal_name]
																		   event-value-copy]]]
												[have event-semantic_frame-copy remove event-key_type event-key event-value-copy]
												]]]]
										 ]]
			  [[and [is-type `semantic_knowledge_base_event event]
				[eq event_type `end_of_plan_changes]]          [prog [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
												      'end_of_plan_changes found: added end_of_plan_type_changes to deliberative1_type_knowledge trace events.']
										     [have [get [get this mind] semantic_knowledge_base `deliberative1_type_knowledge] add_trace_event [new semantic_knowledge_base_event [time] `end_of_plan_type_changes nil]]
										     nil]]
			  ]]]]
	[have deliberative1_knowledge_iterator increment]]]]]



