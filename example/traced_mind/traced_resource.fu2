'Copyright (c) 2007-2012 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.'


'action_transframe_hypothesis_space_feature'

[defunk action_transframe_hypothesis_space_feature-phenomenal_name [meta_relationship]
  [let [[source [get meta_relationship source]]
	[target [get meta_relationship target]]]
    [let [[source_phenomenal_name [if [is-type `semantic_object source]
				      [get source phenomenal_name]
				    [get [get source as-string] as-symbol]]]
	  [key_type                    [get meta_relationship key_type]]
	  [key                         [get meta_relationship key]]
	  [target_phenomenal_name [if [is-type `semantic_object target]
				      [get target phenomenal_name]
				    [get [get target as-string] as-symbol]]]]
      [format nil source_phenomenal_name '_' key_type '_' key '_' target_phenomenal_name]]]]

[deframe action_transframe_hypothesis_space_feature [frame] [meta_relationship]
  [new [initial-meta_relationship]
       [= meta_relationship initial-meta_relationship]
       nil]]

[deftypefunk action_transframe_hypothesis_space_feature get phenomenal_name []
  [action_transframe_hypothesis_space_feature-phenomenal_name meta_relationship]]


'action_transframe_hypothesis_space_change_feature'

[defunk action_transframe_hypothesis_space_change_feature-phenomenal_name [change_type meta_relationship]
  [format nil change_type '_' [action_transframe_hypothesis_space_feature-phenomenal_name meta_relationship]]]

[deframe action_transframe_hypothesis_space_change_feature [frame] [change_type
								    meta_relationship]
  [new [initial-change_type
	initial-meta_relationship]
       [= change_type       initial-change_type]
       [= meta_relationship initial-meta_relationship]
       nil]]

[deftypefunk action_transframe_hypothesis_space_change_feature get phenomenal_name []
  [action_transframe_hypothesis_space_change_feature-phenomenal_name change_type meta_relationship]]


'action_transframe_hypothesis_space'

[deframe action_transframe_hypothesis_space [frame] [change_feature
						     [concept_version_space [new concept_version_space]]]
  [new [initial-change_feature]
       [= change_feature initial-change_feature]
       nil]]



'traced_resource'

[deframe traced_resource [resource] [simulate_knowledge_base_names
				     [feature_phenomenal_name_ptypehash                      [new ptypehash]]
				     [change_feature_phenomenal_name_ptypehash               [new ptypehash]]
				     [precondition_hypothesis_space_change_feature_ptypehash [new ptypehash]]]
  [new [initial-name initial-active_funk initial-simulate_knowledge_base_names]
       [let [[wrapped_active_funk [get this wrapped_active_funk initial-active_funk]]]
	 [construct resource initial-name wrapped_active_funk]
	 
	 [= simulate_knowledge_base_names initial-simulate_knowledge_base_names]
	 
	 ]]]

[deftypefunk traced_resource execute begin_wrapped_active_funk []
  [let [[target [get this resource_semantic_frame]]]
    [set target active t]]]

[deftypefunk traced_resource execute finish_wrapped_active_funk []
  [let [[target [get this resource_semantic_frame]]]
    [set target active nil]
    nil]]

[deftypefunk traced_resource get wrapped_active_funk [active_funk]
  [let [[active_funk-args [get active_funk args]]]
    [eval `[let [[this_traced_resource ,this]]
	     [funk-new_with_name ,[get [format nil [get active_funk name] '-traced'] as-symbol] ,active_funk-args
				 [have this_traced_resource begin_wrapped_active_funk]
				 [let [[result [apply ,active_funk [conslist @active_funk-args]]]]
				   [have this_traced_resource finish_wrapped_active_funk]
				   result]]]]]]]

[deftypefunk traced_resource get resource_semantic_frame []
  [let [[resource_semantic_frame [type-get resource this resource_semantic_frame]]]
    [let [[reflective_knowledge [get [get this mind] semantic_knowledge_base `reflective_knowledge]]]
      [if [not [get reflective_knowledge contains_semantic_frame resource_semantic_frame]]
	  [have reflective_knowledge add_semantic_frame resource_semantic_frame]]]
    resource_semantic_frame]]

[deftypefunk traced_resource execute activate [:rest args]
  [let [[agent  [get [if [cause-lookup cause-resource] cause-resource this] resource_semantic_frame]]
	[target [get this                                                   resource_semantic_frame]]]
    [semantic-add agent activating target]
    [type-have-apply resource this activate args]
    [semantic-remove agent activating target]]]

[deftypefunk traced_resource execute wait_to_activate [:rest args]
  [let [[agent  [get [if [cause-lookup cause-resource] cause-resource this] resource_semantic_frame]]
	[target [get this                                                   resource_semantic_frame]]]
    [semantic-add agent waiting_to_activate target]
    [type-have-apply resource this wait_to_activate args]
    [semantic-remove agent waiting_to_activate target]]]

[deftypefunk traced_resource execute wait_to_call [:rest args]
  [let [[agent  [get [if [cause-lookup cause-resource] cause-resource this] resource_semantic_frame]]
	[target [get this                                                   resource_semantic_frame]]]
    [semantic-add agent waiting_to_call target]
    [type-have-apply resource this wait_to_call args]
    [semantic-remove agent waiting_to_call target]]]

[deftypefunk traced_resource execute call [:rest args]
  [let [[agent  [get [if [cause-lookup cause-resource] cause-resource this] resource_semantic_frame]]
	[target [get this                                                   resource_semantic_frame]]]
    [semantic-add agent calling target]
    [type-have-apply resource this call args]
    [semantic-remove agent calling target]]]

[deftypefunk traced_resource execute finish []
  [let [[agent  [get [if [cause-lookup cause-resource] cause-resource this] resource_semantic_frame]]
	[target [get this                                                   resource_semantic_frame]]]
    [semantic-add agent waiting_for_to_finish target]
    [type-have resource this finish]
    [semantic-remove agent waiting_for_to_finish target]]]

[deftypefunk traced_resource get feature [meta_relationship]
  [let [[feature-phenomenal_name [action_transframe_hypothesis_space_feature-phenomenal_name meta_relationship]]]
    [let [[feature [have feature_phenomenal_name_ptypehash lookup feature-phenomenal_name]]]
      [if [null feature]
	  [prog [= feature [new action_transframe_hypothesis_space_feature meta_relationship]]
		[have feature_phenomenal_name_ptypehash add feature-phenomenal_name feature]]]
      feature]]]

[deftypefunk traced_resource get change_feature [change_type change_meta_relationship]
  [let [[change-phenomenal_name [action_transframe_hypothesis_space_change_feature-phenomenal_name change_type change_meta_relationship]]]
    [let [[change_feature [have change_feature_phenomenal_name_ptypehash lookup change-phenomenal_name]]]
      [if [null change_feature]
	  [prog [= change_feature [new action_transframe_hypothesis_space_change_feature change_type change_meta_relationship]]
		[have change_feature_phenomenal_name_ptypehash add change-phenomenal_name change_feature]]]
      change_feature]]]

[deftypefunk traced_resource get precondition_hypothesis_space [change_feature]
  [let [[precondition_hypothesis_space [have precondition_hypothesis_space_change_feature_ptypehash lookup change_feature]]]
    [if [null precondition_hypothesis_space]
	[prog [= precondition_hypothesis_space [new action_transframe_hypothesis_space change_feature]]
	      [have precondition_hypothesis_space_change_feature_ptypehash add change_feature precondition_hypothesis_space]]]
    precondition_hypothesis_space]]

[deftypefunk traced_resource execute learn_precondition_hypothesis_space [knowledge_base start_time end_time]
  [let [[event_preconditions [get knowledge_base events_containing_time start_time]]
	[event_transframe    [get knowledge_base event_transframe       start_time end_time]]]
    
    [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
		     [get [get this layer] name] ' resource, ' name ', '
		     'precondition count: ' [length event_preconditions] '.']
    
    [let [[concept_version_space_example [new concept_version_space_example t]]
	  [positive_feature_set          [new set]]]
      [mapc [funk [event_precondition]
		  [cond [[or [is-type `semantic_reflective_object_type_property_event event_precondition]
			     [is-type `semantic_reflective_object_type_relation_event event_precondition]] [let [[meta_relationship [get event_precondition meta_relationship]]]
													     [let [[feature [get this feature meta_relationship]]]
													       [have positive_feature_set add feature]]]]
			[t                                                                                 [prog `[terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
																   [get [get this layer] name] ' resource, ' name ', '
																   'precondition event: ' event_precondition '.']
														 ]]
			]]
	    event_preconditions]
      
      [mapc [funk [feature]
		  [let [[positive [get positive_feature_set contains feature]]]
		    [have concept_version_space_example add_variable_value feature positive]]]
	    [get feature_phenomenal_name_ptypehash values]]]
    
    [mapc [funk [change]
		[let [[change_type  [get change change_type]]
		      [change_event [get change change_event]]]
		  [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
				   [get [get this layer] name] ' resource, ' name ', '
				   'transframe_change: ' change_type ' - ' change_event '.']
		  [cond [[is-type `semantic_reflective_object_type_relation_event change_event] [let [[meta_relationship [get change_event meta_relationship]]]
												  [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
														   [get [get this layer] name] ' resource, ' name ', '
														   'meta_relationship: ' change_type ' - ' meta_relationship '.']
												  [let [[change_feature [get this change_feature change_type meta_relationship]]]
												    [let [[precondition_hypothesis_space [get this precondition_hypothesis_space change_feature]]]
												      [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
														       [get [get this layer] name] ' resource, ' name ', '
														       'precondition_hypothesis_space: ' precondition_hypothesis_space '.']
												      
												      ]]]]
			
			[t                                                                      [prog [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
														       [get [get this layer] name] ' resource, ' name ', '
														       'change event: ' change_type ' - ' change_event '.']
												      ]]
			]]]
	  [let [[element_set [semantic-lookup_set event_transframe change]]]
	    [if element_set
		[get element_set elements]
	      nil]]]]]

[deftypefunk traced_resource execute know_of_completed_action_sequence [action_sequence]
  [let [[transframe_start_time [get action_sequence absolute_start_time]]
	[transframe_end_time   [get action_sequence absolute_end_time]]]
    [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
		     'resource, ' name ', execution finish has reached reflective knowledge layer, so starting fiber to learn transframe when the time is appropriate.']
    [fiber [funk []
		 
		 [mapc [funk [simulate_knowledge_base_name]
			     [cond [[eq simulate_knowledge_base_name `physical_type_knowledge]      [prog [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
															   'resource, ' name ', waiting for physical type knowledge stream to reach ' [get [get transframe_end_time value] date_and_time_string] '.']
													  [have [get [get this mind] physical_type_knowledge_reflective_timer] wait_until_after transframe_end_time]
													  ]]
				   [[eq simulate_knowledge_base_name `deliberative1_type_knowledge] [prog [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
															   'resource, ' name ', waiting for plan type knowledge stream to reach ' [get [get transframe_end_time value] date_and_time_string] '.']
													  [have [get [get this mind] deliberative1_type_knowledge_reflective_timer] wait_until_after transframe_end_time]
													  ]]
				   ]]
		       simulate_knowledge_base_names]
		 
		 'Handle learning of transframe here.'
		 [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
				  'resource, ' name ', execution finish has occurred in reflective reflective knowledge time and simulate knowledge-base times have also caught up.'
				  '\n  All information is ready for learning transframe for resource.']
		 
		 [cond [[or [eq [get [get this layer] name] `builtin_reactive]
			    [eq [get [get this layer] name] `learned_reactive]] [let [[physical_type_knowledge_base [get [get this mind] semantic_knowledge_base `physical_type_knowledge]]]
										  
										  [have this learn_precondition_hypothesis_space physical_type_knowledge_base transframe_start_time transframe_end_time]
										  
										  'do not need this anymore.'
										  `[let [[semantic_action [get [get this mind] physical_semantic_action [get [get this resource_semantic_frame] phenomenal_name]]]]
										     [semantic-add action_sequence transframe    event_transframe]
										     [semantic-add semantic_action example_event action_sequence]
										     [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
												      'resource, ' name ', learned physical_type_knowledge transframe.']]
										  
										  ]]
		       [[eq [get [get this layer] name] `deliberative]          [let [[deliberative1_type_knowledge_base [get [get this mind] semantic_knowledge_base `deliberative1_type_knowledge]]]
										  
										  [have this learn_precondition_hypothesis_space deliberative1_type_knowledge_base transframe_start_time transframe_end_time]
										  
										  'do not need this anymore.'
										  `[let [[semantic_action [get [get this mind] deliberative1_semantic_action [get [get this resource_semantic_frame] phenomenal_name]]]]
										     [semantic-add action_sequence transframe    event_transframe]
										     [semantic-add semantic_action example_event action_sequence]
										     [terminal_format standard-terminal '\n' [get [time] date_and_time_string] ': '
												      'resource, ' name ', learned deliberative1_type_knowledge transframe.']]
										  
										  ]]
		       [[eq [get [get this layer] name] `reflective]            [prog]]
		       [t                                                       [terminal_format standard-terminal '\ntraced_resource warning: layer unrecognized, ' [get [get this layer] name] '.']]
		       ]]
	   []]
    
    ]]
