' 
 Copyright (c) 2007-2008 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.
'

[primfunk:wrong_argument_number_error__set `wrong_argument_number_error]

[primfunk:load 'fu2/primfunks.fu2']

[globalize stdin-stream  [stream 0]]
[globalize stdout-stream [stream 1]]
[globalize stderr-stream [stream 2]]

[exp-print '\nDone compiling primfunks.fu2']

[define -current_env_name- `global-environment]

[globalize-funk funk-unlabeled [make-metro -trace_all_compiles- `funk-unlabeled `[name args :rest body]
					   `[[define demetroed    [exps-demetropolize_full body]]
					     [define compiled_bcs [unsafe:array-elt [make-funk -trace_all_compiles- name args
											       demetroed
											       body
											       nil
											       nil]
									  4]]
					     [define is_funktional [unsafe:array-elt [make-funk -trace_all_compiles- name args
												demetroed
												body
												nil
												nil]
									  10]]
					     `[make-funk ,-trace_all_compiles- [quote ,name] [quote ,args]
							  [quote ,demetroed]
							  [quote ,body]
							  [quote ,compiled_bcs]
							  [quote ,is_funktional]]]
					    nil
					    nil]]

[globalize-funk metro [make-metro -trace_all_compiles- `metro `[name args :rest body]
				  `[[define demetroed    [exps-demetropolize_full body]]
				    [define compiled_bcs [unsafe:array-elt [make-funk -trace_all_compiles- name args
										      demetroed
										      body
										      nil
										      nil]
								 4]]
				    [define is_funktional [unsafe:array-elt [make-funk -trace_all_compiles- name args
										       demetroed
										       body
										       nil
										       nil]
								 10]]
				    `[make-metro ,-trace_all_compiles- [quote ,name] [quote ,args]
						  [quote ,demetroed]
						  [quote ,body]
						  [quote ,compiled_bcs]
						  [quote ,is_funktional]]]
				   nil
				   nil]]

[globalize-funk defmetro
		[metro `defmetro [name args :rest body]
		       [exp-format stdout '\n'] [exp-format stdout `[defmetro ,name ,args]]
		       `[globalize-funk ,name [metro ,name ,args
						      @body]]]]

[defmetro prog [:rest body]
  `[funk-apply [funk-unlabeled `prog []
			       @body] []]]

[defmetro apply [proc args]
  [define debug-apply nil]
  [if debug-apply
      `[let [[proc ,proc]
	     [args [list @args]]]
	 [if proc
	     [funk-apply proc args]
	   [error `run-time 'apply error: proc is nil.']]]
    `[funk-apply ,proc ,args]]]

[defmetro funk [args :rest body]
  `[funk-unlabeled `funk ,args
		    @body]]

[exp-format stdout '\ndefining defunk\n']

[defmetro defunk [name args :rest body]
  [exp-format stdout '\n'] [exp-format stdout `[defunk ,name ,args]]
  `[globalize-funk ,name
		    [funk-unlabeled ,name ,args
				     @body]]]

[exp-format stdout '\ndone defining defunk\n']
[exp-format stdout '\ndefining eval\n']



[defunk eval [exp]
  [funk-apply [make-funk -trace_all_compiles- `eval []
			 [cons exp nil]
			 [cons exp nil]
			 nil
			 nil]
	      nil]]

[exp-format stdout '\ndone defining eval\n']
[exp-format stdout '\ndefining or\n']

[defmetro or [:rest conds]
  [if [null conds]
      nil
    `[if ,[unsafe:cons-car conds]
	 t
       ,[funk-apply &or [unsafe:cons-cdr conds]]]]]

[exp-format stdout '\ndone defining or\n']

[defmetro and [:rest conds]
  [if [null conds]
      `t
    `[if [null ,[unsafe:cons-car conds]]
	 nil
       ,[funk-apply &and [unsafe:cons-cdr conds]]]]]

[defunk error [type value]
  [print [exception `error [cons type [cons value nil]]]]]

'Now we have defunk, basic logic (and, or), and errors (almost! :-) [exceptions are defined below])!  We can define "safe" type-checked primitive accessors and mutators:'

[load 'fu2/primobjects.fu2']

'primitive accessors and mututators completely defined at this point.'

[defmetro chunk-write_8bit  [x y z] `[chunk-write_8bit_integer  ,x ,y [coerce-to-int ,z]]]
[defmetro chunk-write_16bit [x y z] `[chunk-write_16bit_integer ,x ,y [coerce-to-int ,z]]]
[defmetro chunk-write_32bit [x y z] `[chunk-write_32bit_integer ,x ,y [coerce-to-int ,z]]]

[defmetro car     [x]   `[cons-car     ,x]]
[defmetro car-set [x y] `[cons-car-set ,x ,y]]
[defmetro cdr     [x]   `[cons-cdr     ,x]]
[defmetro cdr-set [x y] `[cons-cdr-set ,x ,y]]

[defunk list [:rest seq]
  [if [null seq]
      nil
    [cons [car seq]
	  [apply &list
		 [cdr seq]]]]]

[defmetro label [name args :rest body]
  `[define-funk ,name
     [funk-unlabeled `label ,args
		      @body]]]

[defunk mapc [proc seq]
  [if [null seq]
      nil
    [prog [define mapc-result [apply proc [cons [car seq] nil]]]
	  [if [exception? mapc-result]
	      mapc-result
	    [mapc proc [cdr seq]]]]]]

[defunk parseq [proc seq]
  [if [null seq]
      nil
    [cons [thread proc [cons [car seq] nil]]
	  [parseq proc [cdr seq]]]]]

[defunk mapcar [proc seq]
  [if [null seq]
      nil
    [prog [define result [apply proc [cons [car seq] nil]]]
	  [define cons_result [cons result nil]]
	  [define iter   cons_result]
	  [mapc [funk [elt]
		      [define new_cons [cons [apply proc [cons elt nil]] nil]]
		      [cdr-set iter new_cons]
		      [set iter [cdr iter]]]
		[cdr seq]]
	  cons_result]]]

[defunk wrong_argument_number_error [:rest args] [error `run-time `[wrong-argument-number ,[cons `<funkable> [mapcar &identity args]]]]]
[wrong_argument_number_error-set [funk-body_bytecodes &wrong_argument_number_error]]

[defmetro cadr [seq]
  `[car [cdr ,seq]]]

[defmetro caddr [seq]
  `[car [cdr [cdr ,seq]]]]

[defmetro cadddr [seq]
  `[car [cdr [cdr [cdr ,seq]]]]]

[defmetro cddr [seq]
  `[cdr [cdr ,seq]]]

[defunk first [seq]
  [car seq]]

[defunk second [seq]
  [car [cdr seq]]]

[defunk third [seq]
  [car [cdr [cdr seq]]]]

[defunk fourth [seq]
  [car [cdr [cdr [cdr seq]]]]]

[defmetro let [varpairs :rest body]
  [define let-vars [mapcar [funk [varpair] [car varpair]] varpairs]]
  `[apply [funk-unlabeled `let ,let-vars
			   @body]
	  [list @[mapcar [funk [varpair] [car [cdr varpair]]] varpairs]]]]

[defmetro parlet [varpairs :rest body]
  `[let ,[mapcar [funk [varpair]
		       [let [[var       [first varpair]]
			     [value_exp [second varpair]]]
			 `[,var [thread [funk [] ,value_exp] []]]]]
		 varpairs]
     [define-funk parlet-wait-loop
       [funk []
	     [if [and @[mapcar [funk [varpair]
				     [let [[var [first varpair]]]
				       `[thread-complete? ,var]]]
			       varpairs]]
		 []
	       [prog [yield]
		     [parlet-wait-loop]]]]]
     [parlet-wait-loop]
     [let ,[mapcar [funk [varpair]
			 [let [[var       [first varpair]]
			       [value_exp [second varpair]]]
			   `[,var [thread-value ,var]]]]
		   varpairs]
       @body]]]

[defunk join [:rest threads]
  [define-funk threads-wait-loop
    [funk []
	  [define-funk threads-scan-loop
	    [funk [thread_iter]
		  [if [null thread_iter]
		      t
		    [let [[thread [car thread_iter]]]
		      [if [null [thread-complete? thread]]
			  nil
			[threads-scan-loop [cdr thread_iter]]]]]]]
	  [if [threads-scan-loop threads]
	      nil
	    [prog [yield]
		  [threads-wait-loop]]]]]
  [threads-wait-loop]]

[defmetro parog [:rest codes]
  'run commands in parallel'
  `[let [[parog-threads [list @[mapcar [funk [code]
					     `[thread [funk [] ,code] []]]
				       codes]]]]
     [apply &join parog-threads]]]

[defunk parc [proc seq]
  'run mapc commands in parallel'
  [let [[parc-threads [mapcar [funk [exp]
				    [thread proc [cons exp nil]]]
			      seq]]]
    [apply &join parc-threads]]]

[defunk parcar [proc seq]
  'run mapcar commands in parallel'
  [let [[parcar-threads [mapcar [funk [exp]
				      [thread proc [cons exp nil]]]
				seq]]]
    [apply &join parcar-threads]
    [mapcar [funk [x] [thread-value x]] parcar-threads]]]

[defmetro cond [:rest clauses]
  [if [null clauses]
      nil
    [let [[clause [car clauses]]]
      `[if ,[car clause]
	   [prog @[cdr clause]]
	 ,[apply &cond [cdr clauses]]]]]]

[defunk elt-1d-seq [seq index]
  [cond [[null seq]  [error `run-time `list-index-too-big]]
	[[integer-equal_sign index 0] [car seq]]
	[t                            [elt-1d-seq [cdr seq] [- index 1]]]]]

[defunk elt-1d [collection index]
  [cond [[cons?  collection] [elt-1d-seq collection index]]
	[[array? collection] [array-elt  collection index]]
	[t                   [error `run-time `unknown-collection-type]]]]

[defunk elt [collection :rest indices]
  [let [[rest_indices [cdr indices]]]
    [if [null rest_indices]
	[elt-1d collection [car indices]]
      [apply &elt [cons `[elt collection [car indices]] rest_indices]]]]]

[defunk elt-1d-seq-set [seq index value]
  [cond [[null seq]                   [error `run-time `list-index-too-big]]
	[[integer-equal_sign index 0] [car-set seq value]]
	[t                            [elt-1d-seq-set [cdr seq] [- index 1] value]]]]

[defunk elt-1d-set [collection index value]
  [cond [[cons?  collection] [elt-1d-seq-set collection index value]]
	[[array? collection] [array-elt-set  collection index value]]
	[t                   [error `run-time `unknown-collection-type]]]]

[defunk elt-set [collection indices value]
  [if [cons? indices]
      [if [null [cdr indices]]
	  [elt-1d-set collection [car indices] value]
	[elt-set [elt collection [car indices]] [cdr indices] value]]
    [elt-1d-set collection indices value]]]

[defmetro dotimes [var-max_index :rest body]
  [let [[var       [car  var-max_index]]
	[max_index [cadr var-max_index]]]
    `[let [[,var      0]
	   [max_index ,max_index]]
       [define-funk dotimes-loop
	 [funk []
	       [prog @body]
	       [set ,var [integer-add ,var 1]]
	       [if [integer-less_than ,var max_index]
		   [dotimes-loop]]]]
       [if [integer-less_than ,var max_index]
	   [dotimes-loop]]]]]

[defunk range [min max]
  [if [integer-less_than min max]
      [cons min [range [integer-add min 1] max]]]]

[defmetro partimes [var-max_index :rest body]
  [let [[var       [car  var-max_index]]
	[max_index [cadr var-max_index]]]
    `[let [[partimes-proc [funk [,var] @body]]
	   [max_index ,max_index]]
       [let [[partimes-seq [range 0 max_index]]]
	 [apply &join [parseq partimes-proc partimes-seq]]]]]]

[defunk list-set_cdr [seq value]
  [if [null seq] [error `run-time `[[funk list-set_cdr] [desc [null seq]] [funk-args ,seq ,value]]]]
  [let [[cdr_seq [cdr seq]]]
    [if cdr_seq
	[list-set_cdr cdr_seq value]
      [prog [cdr-set seq value]
	    seq]]]]

[defunk list-copy [seq]
  [mapcar &identity seq]]

[defunk append [first_seq :rest rest_seqs]
  [if [null first_seq]
      [apply &append rest_seqs]
    [let [[first_seq_copy [list-copy first_seq]]]
      [if [null rest_seqs]
	  first_seq_copy
	[prog [list-set_cdr first_seq_copy [apply &append rest_seqs]]
	      first_seq_copy]]]]]

[defunk format [stream :rest exps]
  [mapc [funk [exp] [exp-format stream exp]] exps]]

[defunk format-html [stream :rest exps]
  [mapc [funk [exp] [exp-format-html stream exp]] exps]]

[defunk fwrite_html [stream :rest exps]
  [mapc [funk [exp] [exp-fwrite_html stream exp]] exps]]

[defunk print-html [exp] [format-html stdout '\n'] [fwrite_html stdout exp]]

[defmetro time [:rest codes]
  'This doesn\'t really work because macros are not fully expanded at compile-time.'
  `[let [[start-time [system-time]]]
     [let [[time-result [prog @codes]]]
       [let [[end-time [system-time]]]
	 [format stdout 'time: '] [format stdout [system-time-subtract end-time start-time]] [format stdout '\n']]
       time-result]]]

[defmetro while [cond :rest body]
  `[prog [define-funk while-loop
	   [funk-unlabeled `while []
			   [if ,cond
			       [prog [prog @body]
				     [while-loop]]]]]
	 [while-loop]]]

[defmetro funkall [funk :rest args]
  `[apply ,funk [list @args]]]

[defunk find [exp seq key test]
  [if [null seq]
      nil
    [let [[car [car seq]]]
      [let [[car-key [funkall key car]]]
	[if [funkall test exp car-key]
	    car
	  [find exp [cdr seq] key test]]]]]]

[defunk thread-find_last_trace_env [thread]
  [find `trace_env [thread-trace thread] [funk [x] [car x]] &eq]]

[defunk array-new [:rest lengths]
  [if [null lengths]
      []
    [let [[cdr    [cdr lengths]]
	  [length [car lengths]]]
      [let [[a    [array-new_1d length]]]
	[if cdr [dotimes [i length] [array-elt-set a i [apply &array-new cdr]]]]
	a]]]]

[defunk hashtable-new [bin_num_power] [hashtable bin_num_power [array-new [<< 1 bin_num_power]]]]

[defmetro put [value place]
  [let [[dplace [demetropolize_full place]]]
    [cond [[symbol? dplace] `[set ,dplace ,value]]
	  [[cons?   dplace] [let [[car [car dplace]]]
			      [cond [[eq car   `safe:cons-car]                     `[safe:cons-car-set               ,[cadr dplace] ,value]]
				    [[eq car `unsafe:cons-car]                   `[unsafe:cons-car-set               ,[cadr dplace] ,value]]
				    [[eq car   `safe:cons-cdr]                     `[safe:cons-cdr-set               ,[cadr dplace] ,value]]
				    [[eq car `unsafe:cons-cdr]                   `[unsafe:cons-cdr-set               ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:cfunk-args]                   `[safe:cfunk-args-set             ,[cadr dplace] ,value]]
				    [[eq car `unsafe:cfunk-args]                 `[unsafe:cfunk-args-set             ,[cadr dplace] ,value]]
				    [[eq car   `safe:cfunk-cfunkptr]               `[safe:cfunk-cfunkptr-set         ,[cadr dplace] ,value]]
				    [[eq car `unsafe:cfunk-cfunkptr]             `[unsafe:cfunk-cfunkptr-set         ,[cadr dplace] ,value]]
				    [[eq car   `safe:cfunk-env]                    `[safe:cfunk-env-set              ,[cadr dplace] ,value]]
				    [[eq car `unsafe:cfunk-env]                  `[unsafe:cfunk-env-set              ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:metrocfunk-args]              `[safe:metrocfunk-args-set        ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metrocfunk-args]            `[unsafe:metrocfunk-args-set        ,[cadr dplace] ,value]]
				    [[eq car   `safe:metrocfunk-cfunkptr]          `[safe:metrocfunk-cfunkptr-set    ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metrocfunk-cfunkptr]        `[unsafe:metrocfunk-cfunkptr-set    ,[cadr dplace] ,value]]
				    [[eq car   `safe:metrocfunk-env]               `[safe:metrocfunk-env-set         ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metrocfunk-env]             `[unsafe:metrocfunk-env-set         ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:funk-body_bytecodes]          `[safe:funk-body_bytecodes-set    ,[cadr dplace] ,value]]
				    [[eq car `unsafe:funk-body_bytecodes]        `[unsafe:funk-body_bytecodes-set    ,[cadr dplace] ,value]]
				    [[eq car   `safe:funk-args]                    `[safe:funk-args-set              ,[cadr dplace] ,value]]
				    [[eq car `unsafe:funk-args]                  `[unsafe:funk-args-set              ,[cadr dplace] ,value]]
				    [[eq car   `safe:funk-body]                    `[safe:funk-body-set              ,[cadr dplace] ,value]]
				    [[eq car `unsafe:funk-body]                  `[unsafe:funk-body-set              ,[cadr dplace] ,value]]
				    [[eq car   `safe:funk-env]                     `[safe:funk-env-set               ,[cadr dplace] ,value]]
				    [[eq car `unsafe:funk-env]                   `[unsafe:funk-env-set               ,[cadr dplace] ,value]]
				    [[eq car   `safe:funk-machine_code]            `[safe:funk-machine_code-set      ,[cadr dplace] ,value]]
				    [[eq car `unsafe:funk-machine_code]          `[unsafe:funk-machine_code-set      ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:metro-body_bytecodes]         `[safe:metro-body_bytecodes-set   ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metro-body_bytecodes]       `[unsafe:metro-body_bytecodes-set   ,[cadr dplace] ,value]]
				    [[eq car   `safe:metro-args]                   `[safe:metro-args-set             ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metro-args]                 `[unsafe:metro-args-set             ,[cadr dplace] ,value]]
				    [[eq car   `safe:metro-body]                   `[safe:metro-body-set             ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metro-body]                 `[unsafe:metro-body-set             ,[cadr dplace] ,value]]
				    [[eq car   `safe:metro-env]                    `[safe:metro-env-set              ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metro-env]                  `[unsafe:metro-env-set              ,[cadr dplace] ,value]]
				    [[eq car   `safe:metro-machine_code]           `[safe:metro-machine_code-set     ,[cadr dplace] ,value]]
				    [[eq car `unsafe:metro-machine_code]         `[unsafe:metro-machine_code-set     ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:exception-tag]                `[safe:exception-tag-set          ,[cadr dplace] ,value]]
				    [[eq car `unsafe:exception-tag]              `[unsafe:exception-tag-set          ,[cadr dplace] ,value]]
				    [[eq car   `safe:exception-value]              `[safe:exception-value-set        ,[cadr dplace] ,value]]
				    [[eq car `unsafe:exception-value]            `[unsafe:exception-value-set        ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:bytecode-command]             `[safe:bytecode-command-set       ,[cadr dplace] ,value]]
				    [[eq car `unsafe:bytecode-command]           `[unsafe:bytecode-command-set       ,[cadr dplace] ,value]]
				    [[eq car   `safe:bytecode-arg0]                `[safe:bytecode-arg0-set          ,[cadr dplace] ,value]]
				    [[eq car `unsafe:bytecode-arg0]              `[unsafe:bytecode-arg0-set          ,[cadr dplace] ,value]]
				    [[eq car   `safe:bytecode-arg1]                `[safe:bytecode-arg1-set          ,[cadr dplace] ,value]]
				    [[eq car `unsafe:bytecode-arg1]              `[unsafe:bytecode-arg1-set          ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:thread-program_counter]       `[safe:thread-program_counter-set ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-program_counter]     `[unsafe:thread-program_counter-set ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-stack]                 `[safe:thread-stack-set           ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-stack]               `[unsafe:thread-stack-set           ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-iter]                  `[safe:thread-iter-set            ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-iter]                `[unsafe:thread-iter-set            ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-env]                   `[safe:thread-env-set             ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-env]                 `[unsafe:thread-env-set             ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-args]                  `[safe:thread-args-set            ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-args]                `[unsafe:thread-args-set            ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-return]                `[safe:thread-return-set          ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-return]              `[unsafe:thread-return-set          ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-value]                 `[safe:thread-value-set           ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-value]               `[unsafe:thread-value-set           ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-trace]                 `[safe:thread-trace-set           ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-trace]               `[unsafe:thread-trace-set           ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-critics]               `[safe:thread-critics-set         ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-critics]             `[unsafe:thread-critics-set         ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-context]               `[safe:thread-context-set         ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-context]             `[unsafe:thread-context-set         ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-keep_undead]           `[safe:thread-keep_undead-set     ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-keep_undead]         `[unsafe:thread-keep_undead-set     ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-parent_thread]         `[safe:thread-parent_thread-set   ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-parent_thread]       `[unsafe:thread-parent_thread-set   ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-parent_env]            `[safe:thread-parent_env-set      ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-parent_env]          `[unsafe:thread-parent_env-set      ,[cadr dplace] ,value]]
				    [[eq car   `safe:thread-execute_mutex]         `[safe:thread-execute_mutex-set   ,[cadr dplace] ,value]]
				    [[eq car `unsafe:thread-execute_mutex]       `[unsafe:thread-execute_mutex-set   ,[cadr dplace] ,value]]
				    
				    [[eq car   `safe:array-elt]                    `[safe:array-elt-set              ,[cadr dplace] ,[caddr dplace] ,value]]
				    [[eq car `unsafe:array-elt]                  `[unsafe:array-elt-set              ,[cadr dplace] ,[caddr dplace] ,value]]
				    
				    [[eq car              `elt]                               `[elt-set              ,[cadr dplace] ,[caddr dplace] ,value]]
				    
				    [t [error `compile-time 'unrecognized accessor to convert to mutator']]]]]
	  [t [error `compile-time 'unrecognized type of demetropolized place.']]]]]

[defmetro push [element place]
  `[let [[element_value ,element]]
     [put [cons element_value ,place] ,place]]]

[defunk type [exp]
  [if [null exp]
      `nil
    [let [[ptype_raw [ptype-raw exp]]]
      [cond [[integer-equal_sign ptype_raw 0]  `free_memory]
	    [[integer-equal_sign ptype_raw 1]  `newly_allocated]
	    [[integer-equal_sign ptype_raw 2]  `integer]
	    [[integer-equal_sign ptype_raw 3]  `double]
	    [[integer-equal_sign ptype_raw 4]  `float]
	    [[integer-equal_sign ptype_raw 5]  `pointer]
	    [[integer-equal_sign ptype_raw 6]  `char]
	    [[integer-equal_sign ptype_raw 7]  `string]
	    [[integer-equal_sign ptype_raw 8]  `symbol]
	    [[integer-equal_sign ptype_raw 9]  `cons]
	    [[integer-equal_sign ptype_raw 10] `array]
	    [[integer-equal_sign ptype_raw 11] `chunk]
	    [[integer-equal_sign ptype_raw 12] `cfunk]
	    [[integer-equal_sign ptype_raw 13] `ptype_metrocfunk]
	    [[integer-equal_sign ptype_raw 14] `ptype_funk]
	    [[integer-equal_sign ptype_raw 15] `ptype_metro]
	    [[integer-equal_sign ptype_raw 16] `ptype_exception]
	    [[integer-equal_sign ptype_raw 17] `ptype_bytecode]
	    [[integer-equal_sign ptype_raw 18] `ptype_thread]
	    [t                                 [error `unknown-type exp]]]]]]

'coerce: attempts to detect and optimize for quoted type conversions at compile-time.'
[defmetro coerce [exp type]
  [if [and [cons? type]
	   [eq [car type] `quote]
	   [cons? [cdr type]]
	   [symbol? [cadr type]]]
      [let [[quoted_type [cadr type]]]
	[cond [[eq quoted_type `integer] `[let [[exp ,exp]]
					    [cond [[integer? exp]                    exp]
						  [[double?  exp] [double-to_integer exp]]
						  [[float?   exp] [float-to_integer  exp]]
						  [t [error `cannot-coerce-type-to-integer [type exp]]]]]]
	      [[eq quoted_type `double]  `[let [[exp ,exp]]
					    [cond [[integer? exp] [integer-to_double exp]]
						  [[double?  exp]                    exp]
						  [[float?   exp] [float-to_double   exp]]
						  [t [error `cannot-coerce-type-to-integer [type exp]]]]]]
	      [[eq quoted_type `float]   `[let [[exp ,exp]]
					    [cond [[integer? exp] [integer-to_float  exp]]
						  [[double?  exp] [double-to_float   exp]]
						  [[float?   exp]                    exp]
						  [t [error `cannot-coerce-type-to-integer [type exp]]]]]]
	      [t                         [error `cannot-coerce-to-type type]]]]
    `[let [[exp  ,exp]
	   [type ,type]]
       [cond [[eq type `integer] [cond [[integer? exp]                    exp]
				       [[double?  exp] [double-to_integer exp]]
				       [[float?   exp] [float-to_integer  exp]]
				       [t [error `cannot-coerce-type-to-integer [type exp]]]]]
	     [[eq type `double]  [cond [[integer? exp] [integer-to_double exp]]
				       [[double?  exp]                    exp]
				       [[float?   exp] [float-to_double   exp]]
				       [t [error `cannot-coerce-type-to-integer [type exp]]]]]
	     [[eq type `float]   [cond [[integer? exp] [integer-to_float  exp]]
				       [[double?  exp] [double-to_float   exp]]
				       [[float?   exp]                    exp]
				       [t [error `cannot-coerce-type-to-integer [type exp]]]]]
	     [t                  [error `cannot-coerce-to-type type]]]]]]

[defmetro trace-on [:rest body]
  `[let [[-trace_all_compiles- t]]
     @body]]

[defmetro trace-off [:rest body]
  `[let [[-trace_all_compiles- nil]]
     @body]]

[defmetro with-critic [critic :rest body]
  `[let [[this-thread [this-thread]]]
     [let [[old-critics [thread-critics this-thread]]]
       [thread-critics-set this-thread [cons ,critic [thread-critics this-thread]]]
       @body]
     [thread-critics-set this-thread old-critics]]]

[defunk critic_funk-backtrace [thread]
  [format stdout '\nCritical Exception Handling']
  [mapc [funk [x] [if [cons? x] [let [[car [car x]]]
				  [if [eq car `trace_env]
				      [format stdout '\ntrace_env: ' [cadr x]]]]]]
	[thread-trace thread]]]

[defmetro with-backtrace [:rest body]
  `[with-critic &critic_funk-backtrace
		@body]]

[defunk print [x]
  [format stdout '\n']
  [exp-print x]]

[defunk demetropolize [x]
  [let [[demetro_pair [demetropolize_once x]]]
    [let [[did_something [car demetro_pair]]
	  [retval        [cdr demetro_pair]]]
      [if did_something
	  [demetropolize retval]
	retval]]]]

[defunk demetropolize1 [x]
  [cdr [demetropolize_once x]]]

[defmetro mutexprog [mutex :rest body]
  `[let [[mutexprog-mutex ,mutex]]
     [mutex-lock   mutexprog-mutex]
     [prog @body]
     [mutex-unlock mutexprog-mutex]]]

[defmetro defmutexfunk [mutex name args :rest body]
  `[defunk ,name ,args [mutexprog ,mutex @body]]]

[defmetro defunks-mutex [mutex :rest funkdefs] 
  `[let [[defunks_mutex-mutex ,mutex]]
     @[mapcar [funk [funkdef]
		    `[defmutexfunk defunks_mutex-mutex @funkdef]]]]]

[defmetro rest [exp]
  `[cdr ,exp]]

[defunk remove [element sequence]
  [let [[new_sequence [cons nil nil]]]
    [let [[new_sequence_iter new_sequence]]
      [mapc [funk [sequence_element]
		  [if [not [eq element sequence_element]]
		      [let [[new_cons [cons sequence_element nil]]]
			[put new_cons [cdr new_sequence_iter]]
			[set new_sequence_iter new_cons]]]]
	    sequence]
      [cdr new_sequence]]]]

[defmetro let* [var_value_pairs :rest body]
  [if [null var_value_pairs]
      `[prog @body]
    [let [[var_value_pair [car var_value_pairs]]]
      [let [[var   [first  var_value_pair]]
	    [value [second var_value_pair]]]
	`[let [[,var ,value]]
	   [let* ,[cdr var_value_pairs]
	     @body]]]]]]

[defunk list? [exp]
  [if [null exp]
      t
    [if [cons? exp]
	[list? [cdr exp]]
      nil]]]

[defunk brief [exp]
  [if exp [cond [[funk? exp] `[funk ,[funk-name exp] ,[funk-args exp]]]
		[[list? exp]  [mapc [funk [arg]
					  [brief arg]]
				    exp]]
		[t                 `<>]]]]

[defunk memblock-set_init_render_xyz   [x y z]        [if [and [float? x] [float? y] [float? z]] [unsafe:memblock-set_init_render_xyz x y z] [error `type-error [list `memblock-set_init_render_xyz x y z]]]]
[defunk memblock-set_init_render_on    [render_on]    [if [integer? render_on] [unsafe:memblock-set_init_render_on render_on] [error `type-error [list `memblock-set_init_render_on render_on]]]]
[defunk memblock-set_init_render_noise [render_noise] [if [float? render_noise] [unsafe:memblock-set_init_render_noise render_noise] [error `type-error [list `memblock-set_init_render_noise render_noise]]]]

'redefining error in a better way.'
[defunk error [type value]
  [let [[except [exception `error [cons type [cons value nil]]]]]
    [print `[error ,except]]
    `[print `[this-thread: ,[this-thread]]]
     except]]

`[format stdout '\ncompiling thought_process.fu2']
`[load 'fu2/thought_process.fu2']

[format stdout '\ncompiling bootstrap-reader.fu2']
[load 'fu2/bootstrap-reader.fu2']

[format stdout '\ncompiling repl.fu2']
[load 'fu2/repl.fu2']

[format stdout '\ndone compiling bootstrap-repl.fu2']

[primfunk:memory_image__save 'img/bootstrap-repl.img']

[quit]
