[globalize -funk2-bootstrap-copyright- ' 
 Copyright (c) 2007-2008 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.
']

[primfunk:exp__format stdout '\n']
[primfunk:exp__format stdout [primfunk:ptype__cause scheduler:global_scheduler]]
[primfunk:exp__format stdout '\n']

[primfunk:ansi__stream__foreground stdout 15]
[primfunk:exp__format stdout '

  /----------------------------------------\\
  |                                        |
  | ']
[primfunk:ansi__stream__foreground stdout 9]
[primfunk:exp__format stdout 'funk2 img']
[primfunk:ansi__stream__foreground stdout 15]
[primfunk:exp__format stdout '/']
[primfunk:ansi__stream__foreground stdout 9]
[primfunk:exp__format stdout 'bootstrap']
[primfunk:ansi__stream__foreground stdout 15]
[primfunk:exp__format stdout '.']
[primfunk:ansi__stream__foreground stdout 9]
[primfunk:exp__format stdout 'img compiling now']
[primfunk:ansi__stream__foreground stdout 15]
[primfunk:exp__format stdout '.']
[primfunk:ansi__stream__foreground stdout 15]
[primfunk:exp__format stdout ' |
  |                                        |
  \\----------------------------------------/

']
[primfunk:ansi__stream__reset stdout]

[primfunk:wrong_argument_number_error__set `wrong_argument_number_error]

[primfunk:exp__format stdout '\n']
[primfunk:exp__format stdout [primfunk:ptype__cause scheduler:global_scheduler]]
[primfunk:exp__format stdout '\n']


[primfunk:load 'fu2/primfunks.fu2']
[primfunk:load 'fu2/primfunks-array.fu2']
[primfunk:load 'fu2/primfunks-apropos.fu2']
[primfunk:load 'fu2/primfunks-child_handler.fu2']
[primfunk:load 'fu2/primfunks-errno.fu2']
[primfunk:load 'fu2/primfunks-fcntl.fu2']
[primfunk:load 'fu2/primfunks-frame.fu2']
[primfunk:load 'fu2/primfunks-ioctl.fu2']
[primfunk:load 'fu2/primfunks-locale.fu2']
[primfunk:load 'fu2/primfunks-management_thread.fu2']
[primfunk:load 'fu2/primfunks-object.fu2']
[primfunk:load 'fu2/primfunks-primobject_type.fu2']
[primfunk:load 'fu2/primfunks-primobject_type_handler.fu2']
[primfunk:load 'fu2/primfunks-primobjects.fu2']
[primfunk:load 'fu2/primfunks-search.fu2']
[primfunk:load 'fu2/primfunks-serialize.fu2']
[primfunk:load 'fu2/primfunks-socket.fu2']
[primfunk:load 'fu2/primfunks-sort.fu2']
[primfunk:load 'fu2/primfunks-string.fu2']
[primfunk:load 'fu2/primfunks-text_buffer.fu2']
[primfunk:load 'fu2/primfunks-trace.fu2']
[primfunk:load 'fu2/primfunks-reader.fu2']
[primfunk:load 'fu2/primfunks-garbage_collector.fu2']
[primfunk:load 'fu2/primfunks-glwindow.fu2']
[primfunk:load 'fu2/primfunks-physical_objects.fu2']
[primfunk:load 'fu2/primfunks-object_lattice.fu2']
[primfunk:load 'fu2/primfunks-arithmetic.fu2']

[globalize stdin-stream  [file_stream-new 0]]
[globalize stdout-stream [file_stream-new 1]]
[globalize stderr-stream [file_stream-new 2]]

[define -current_env_name- `global-environment]

[globalize-funk funk-unlabeled [make-metro `funk-unlabeled `[name args :rest body]
					   `[[define demetroed    [exps-demetropolize_full body]]
					     [define compiled_funk [make-funk name args
									      demetroed
									      body
									      nil
									      nil
									      nil]]
					     [define compiled_bcs  [primfunk:array__elt compiled_funk  4]]
					     [define is_funktional [primfunk:array__elt compiled_funk 10]]
					     `[make-funk [quote ,name] [quote ,args]
							  [quote ,demetroed]
							  [quote ,body]
							  [quote ,compiled_bcs]
							  ,is_funktional
							  nil]]
					    nil
					    nil
					    nil
					    nil]]

[globalize-funk metro [make-metro `metro `[name args :rest body]
				  `[[define demetroed    [exps-demetropolize_full body]]
				    [define compiled_funk [make-funk name args
								     demetroed
								     body
								     nil
								     nil
								     nil]]
				    [define compiled_bcs  [primfunk:array__elt compiled_funk  4]]
				    [define is_funktional [primfunk:array__elt compiled_funk 10]]
				    `[make-metro [quote ,name] [quote ,args]
						 [quote ,demetroed]
						 [quote ,body]
						 [quote ,compiled_bcs]
						 ,is_funktional
						 nil]]
				   nil
				   nil
				   nil
				   nil]]

[globalize-funk defmetro
		[metro `defmetro [name args :rest body]
		       [exp-format stdout '\n'] [exp-format stdout `[defmetro ,name ,args]]
		       `[globalize-funk ,name [metro ,name ,args
						      @body]]]]

[globalize-funk defmetro-local
		[metro `defmetro-local [name args :rest body]
			[exp-format stdout '\n'] [exp-format stdout `[defmetro-local ,name ,args]]
			`[define-funk ,name [metro ,name ,args
						    @body]]]]

[defmetro prog [:rest body]
  `[funk-apply [funk-unlabeled prog []
			       @body] []]]

[defmetro apply [proc args]
  [define debug-apply nil]
  [if debug-apply
      `[let [[proc ,proc]
	     [args [conslist @args]]]
	 [if proc
	     [funk-apply proc args]
	   [error `run-time 'apply error: proc is nil.']]]
    `[funk-apply ,proc ,args]]]

[defmetro funk [args :rest body]
  `[funk-unlabeled funk ,args
		   @body]]

`[exp-format stdout '\ndefining defunk\n']

[defmetro defunk [name args :rest body]
  [exp-format stdout '\n'] [exp-format stdout `[defunk ,name ,args]]
  `[globalize-funk ,name
		    [funk-unlabeled ,name ,args
				     @body]]]

[defmetro defunk-local [name args :rest body]
  [exp-format stdout '\n'] [exp-format stdout `[defunk-local ,name ,args]]
  `[define-funk ,name
     [funk-unlabeled ,name ,args
		      @body]]]

`[exp-format stdout '\ndone defining defunk\n']
`[exp-format stdout '\ndefining eval\n']


[defunk eval [exp]
  [funk-apply [make-funk `eval []
			 [cons exp nil]
			 [cons exp nil]
			 nil
			 nil
			 nil]
	      nil]]

`[exp-format stdout '\ndone defining eval\n']
`[exp-format stdout '\ndefining or\n']

[defmetro or [:rest conds]
  [if [null conds]
      nil
    `[if ,[first conds]
	 `t
       ,[funk-apply &or [next conds]]]]]

`[exp-format stdout '\ndone defining or\n']

[defmetro and [:rest conds]
  [if [null conds]
      ``t
    `[if [null ,[first conds]]
	 nil
       ,[funk-apply &and [next conds]]]]]

[defunk error [type value]
  [new larva 63]]

'Now we have defunk, basic logic (and, or), and errors (almost! :-) [exceptions are defined below])!  We can define "safe" type-checked primitive accessors and mutators:'

`[primfunk:load 'fu2/primobjects.fu2']

'primitive accessors and mututators completely defined at this point.'

[defmetro chunk-write_8bit  [x y z] `[chunk-write_8bit_integer  ,x ,y [coerce-to-int ,z]]]
[defmetro chunk-write_16bit [x y z] `[chunk-write_16bit_integer ,x ,y [coerce-to-int ,z]]]
[defmetro chunk-write_32bit [x y z] `[chunk-write_32bit_integer ,x ,y [coerce-to-int ,z]]]

[defmetro car     [x]   `[first     ,x]]
[defmetro car-set [x y] `[first-set ,x ,y]]
[defmetro cdr     [x]   `[next      ,x]]
[defmetro cdr-set [x y] `[next-set  ,x ,y]]
[defmetro cir     [x]   `[prev      ,x]]
[defmetro cir-set [x y] `[prev-set  ,x ,y]]

[defunk conslist [:rest seq]
  [if [null seq]
      nil
    [cons [car seq]
	  [apply &conslist
		 [cdr seq]]]]]

[defmetro label [name args :rest body]
  `[define-funk ,name
     [funk-unlabeled label ,args
		     @body]]]

[defunk mapc [proc seq]
  [while seq
    [apply proc [cons [car seq] nil]]
    [mutate seq [cdr seq]]]]

[defunk parseq [proc seq]
  [if [null seq]
      nil
    [cons [fiber proc [cons [car seq] nil]]
	  [parseq proc [cdr seq]]]]]

[defunk mapcar [proc seq]
  [if [null seq]
      nil
    [prog [define result [apply proc [cons [car seq] nil]]]
	  [define cons_result [cons result nil]]
	  [define iter   cons_result]
	  [mapc [funk [elt]
		      [define new_cons [cons [apply proc [cons elt nil]] nil]]
		      [cdr-set iter new_cons]
		      [mutate iter [cdr iter]]]
		[cdr seq]]
	  cons_result]]]

[defunk filter [cond_proc seq]
  [if [null seq]
      nil
    [prog [define exp    [car seq]]
	  [define result [apply cond_proc [cons exp nil]]]
	  [if result
	      [cons result [filter cond_proc [cdr seq]]]
	    [filter cond_proc [cdr seq]]]]]]

[defmetro object_type-type-funk    [name slot_type_name slot_name] `[primobject_type-lookup_slot_type_funk [lookup_type ,name] ,slot_type_name ,slot_name]]
[defmetro object_type-get-funk     [name slot_name]                `[object_type-type-funk                              ,name  `get            ,slot_name]]
[defmetro object_type-set-funk     [name slot_name]                `[object_type-type-funk                              ,name  `set            ,slot_name]]
[defmetro object_type-execute-funk [name slot_name]                `[object_type-type-funk                              ,name  `execute        ,slot_name]]

[defmetro object-get-funk [this slot_name]
  `[object-slot-type_funk ,this `get slot_name]]

[defunk object-get [this slot_name :rest args]
  [apply [object-get-funk this slot_name] [cons this args]]]

[defmetro object-set-funk [this slot_name]
  `[object-slot-type_funk ,this `set slot_name]]

[defunk object-set [this slot_name :rest args]
  [apply [object-set-funk this slot_name] [cons this args]]]

[defmetro object-execute-funk [this slot_name]
  `[object-slot-type_funk ,this `execute ,slot_name]]

[defunk object-execute [this slot_name :rest args]
  [apply [object-execute-funk this slot_name] args]]

[defmetro object_type-new-funk [name]
  `[primobject_type-lookup_slot_type_funk [lookup_type ,name] `execute `new]]

[defunk object_type-new [name :rest args]
  [apply [object_type-new-funk name] args]]

[defmetro new [type_name :rest args]
  `[object_type-new [quote ,type_name] @args]]

[defmetro get [exp slot_name :rest args]
  `[object-get ,exp [quote ,slot_name] @args]]

[defmetro set [exp slot_name :rest value_args]
  `[object-set ,exp [quote ,slot_name] @value_args]]

[defmetro execute [exp slot_name :rest args]
  `[object-execute ,exp [quote ,slot_name] @args]]

[globalize-funk type &object-type]

[globalize-funk cons &primfunk:cons__new]
[defmetro car [x] `[object-get ,x `car]]
[defmetro cdr [x] `[object-get ,x `cdr]]

[defunk is-type [type_name exp]
  [apply [primobject_type-lookup_slot_type_funk [lookup_type type_name] `execute `is_type] [cons exp nil]]]

[defunk wrong_argument_number_error [:rest args] [error `run-time `[wrong-argument-number ,[cons `<funkable> [mapcar &identity args]]]]]
[wrong_argument_number_error-set [object-get &wrong_argument_number_error `body_bytecodes]]

[defunk slots [exp]
  [primobject_type-type_funk-slot_names [lookup_type [type exp]] `get]]

[defmetro cadr [seq]
  `[car [cdr ,seq]]]

[defmetro caddr [seq]
  `[car [cdr [cdr ,seq]]]]

[defmetro cadddr [seq]
  `[car [cdr [cdr [cdr ,seq]]]]]

[defmetro cddr [seq]
  `[cdr [cdr ,seq]]]

[defunk first [seq]
  [car seq]]

[defunk second [seq]
  [car [cdr seq]]]

[defunk third [seq]
  [car [cdr [cdr seq]]]]

[defunk fourth [seq]
  [car [cdr [cdr [cdr seq]]]]]

[defmetro let [varpairs :rest body]
  [define let-vars [mapcar [funk [varpair] [car varpair]] varpairs]]
  `[apply [funk-unlabeled let ,let-vars
			  @body]
	  [conslist @[mapcar [funk [varpair] [car [cdr varpair]]] varpairs]]]]

[defmetro parlet [varpairs :rest body]
  `[let ,[mapcar [funk [varpair]
		       [let [[var       [first varpair]]
			     [value_exp [second varpair]]]
			 `[,var [fiber [funk [] ,value_exp] []]]]]
		 varpairs]
     [define-funk parlet-wait-loop
       [funk []
	     [if [and @[mapcar [funk [varpair]
				     [let [[var [first varpair]]]
				       `[fiber-complete? ,var]]]
			       varpairs]]
		 []
	       [prog [yield]
		     [parlet-wait-loop]]]]]
     [parlet-wait-loop]
     [let ,[mapcar [funk [varpair]
			 [let [[var       [first varpair]]
			       [value_exp [second varpair]]]
			   `[,var [fiber-value ,var]]]]
		   varpairs]
       @body]]]

[defunk join [:rest fibers]
  [define-funk fibers-wait-loop
    [funk []
	  [define-funk fibers-scan-loop
	    [funk [fiber_iter]
		  [if [null fiber_iter]
		      t
		    [let [[fiber [car fiber_iter]]]
		      [if [null [get fiber is_complete]]
			  nil
			[fibers-scan-loop [cdr fiber_iter]]]]]]]
	  [if [fibers-scan-loop fibers]
	      nil
	    [prog [yield]
		  [fibers-wait-loop]]]]]
  [fibers-wait-loop]]

[defunk sleep_for_nanoseconds [nanoseconds]
  [sleep_for_nanoseconds_without_yield nanoseconds]
  [yield]]

[defunk nanosleep [nanoseconds]
  [sleep_for_nanoseconds nanoseconds]]

[defunk microsleep [microseconds]
  [nanosleep [integer-multiply 1000 microseconds]]]

[defunk millisleep [milliseconds]
  [microsleep [integer-multiply 1000 milliseconds]]]

[defunk sleep [seconds]
  [millisleep [integer-multiply 1000 seconds]]]

[defmetro parog [:rest codes]
  'run commands in parallel'
  `[let [[parog-fibers [conslist @[mapcar [funk [code]
						`[fiber [funk [] ,code] []]]
					  codes]]]]
     [apply &join parog-fibers]]]

[defunk parc [proc seq]
  'run mapc commands in parallel'
  [let [[parc-fibers [mapcar [funk [exp]
				    [fiber proc [cons exp nil]]]
			      seq]]]
    [apply &join parc-fibers]]]

[defunk parcar [proc seq]
  'run mapcar commands in parallel'
  [let [[parcar-fibers [mapcar [funk [exp]
				      [fiber proc [cons exp nil]]]
				seq]]]
    [apply &join parcar-fibers]
    [mapcar [funk [x] [get x value]] parcar-fibers]]]

[defmetro cond [:rest clauses]
  [if [null clauses]
      nil
    [let [[clause [car clauses]]]
      `[if ,[car clause]
	   [prog @[cdr clause]]
	 ,[apply &cond [cdr clauses]]]]]]

[defunk elt-1d-seq [seq index]
  [cond [[null seq]                   [error `run-time `conslist-index-too-big]]
	[[integer-equal_sign index 0] [car seq]]
	[t                            [elt-1d-seq [cdr seq] [integer-subtract index 1]]]]]

[defunk elt-1d [collection index]
  [cond [[is-type `cons  collection] [elt-1d-seq collection index]]
	[[is-type `array collection] [array-elt  collection index]]
	[t                           [error `run-time `unknown-collection-type]]]]

[defunk elt [collection :rest indices]
  [let [[rest_indices [cdr indices]]]
    [if [null rest_indices]
	[elt-1d collection [car indices]]
      [funkall &elt [elt-1d collection [car indices]] rest_indices]]]]

[defunk elt-1d-seq-set [seq index value]
  [cond [[null seq]                   [error `run-time `conslist-index-too-big]]
	[[integer-equal_sign index 0] [car-set seq value]]
	[t                            [elt-1d-seq-set [cdr seq] [integer-subtract index 1] value]]]]

[defunk elt-1d-set [collection index value]
  [cond [[is-type `cons  collection] [elt-1d-seq-set collection index value]]
	[[is-type `array collection] [array-elt-set  collection index value]]
	[t                           [error `run-time `unknown-collection-type]]]]

[defunk elt-set [collection indices value]
  [if [is-type `cons indices]
      [if [null [cdr indices]]
	  [elt-1d-set collection [car indices] value]
	[elt-set [elt collection [car indices]] [cdr indices] value]]
    [elt-1d-set collection indices value]]]

`[defmetro dotimes [var-max_index :rest body]
   [let [[var       [car  var-max_index]]
	 [max_index [cadr var-max_index]]]
     `[let [[,var      0]
	    [max_index ,max_index]]
	[define-funk dotimes-loop
	  [funk []
		[prog @body]
		[mutate ,var [integer-add ,var 1]]
		[if [integer-less_than ,var max_index]
		    [dotimes-loop]]]]
	[if [integer-less_than ,var max_index]
	    [dotimes-loop]]]]]

[defmetro dotimes [var-max_index :rest body]
  [let [[var       [car  var-max_index]]
	[max_index [cadr var-max_index]]]
    `[let [[,var      0]
	   [max_index ,max_index]]
       [while [integer-less_than ,var max_index]
	 [prog @body]
	 [mutate ,var [integer-add ,var 1]]]]]]

[defunk range [min max]
  [if [integer-less_than min max]
      [cons min [range [integer-add min 1] max]]]]

[defmetro partimes [var-max_index :rest body]
  [let [[var       [car  var-max_index]]
	[max_index [cadr var-max_index]]]
    `[let [[partimes-proc [funk [,var] @body]]
	   [max_index ,max_index]]
       [let [[partimes-seq [range 0 max_index]]]
	 [apply &join [parseq partimes-proc partimes-seq]]]]]]

[defunk conslist-set_cdr [seq value]
  [if [null seq] [error `run-time `[[funk conslist-set_cdr] [desc [null seq]] [funk-args ,seq ,value]]]]
  [let [[cdr_seq [cdr seq]]]
    [if cdr_seq
	[conslist-set_cdr cdr_seq value]
      [prog [cdr-set seq value]
	    seq]]]]

[defunk conslist-copy [seq]
  [mapcar &identity seq]]

[defunk append [first_seq :rest rest_seqs]
  [if [null first_seq]
      [apply &append rest_seqs]
    [let [[first_seq_copy [conslist-copy first_seq]]]
      [if [null rest_seqs]
	  first_seq_copy
	[prog [conslist-set_cdr first_seq_copy [apply &append rest_seqs]]
	      first_seq_copy]]]]]

[defunk merge [:rest sets]
  [if [null sets]
      nil
    [apply &append sets]]]

[defunk format [stream :rest exps]
  [if [null stream]
      [apply &string-format exps]
    [mapc [funk [exp] [exp-format stream exp]] exps]]]

[defunk format-html [stream :rest exps]
  [mapc [funk [exp] [exp-format-html stream exp]] exps]]

[defunk fwrite_html [stream :rest exps]
  [mapc [funk [exp] [exp-fwrite_html stream exp]] exps]]

[defunk print-html [exp] [format-html stdout '\n'] [fwrite_html stdout exp]]

`[defmetro while [cond :rest body]
   `[prog [define-funk while-loop
	    [funk-unlabeled while []
			    [if ,cond
				[prog [prog @body]
				      [while-loop]]]]]
	  [while-loop]]]

[defmetro funkall [funk :rest args]
  `[apply ,funk [conslist @args]]]

[defunk find [exp seq key test]
  [if [null seq]
      nil
    [let [[car [car seq]]]
      [let [[car-key [funkall key car]]]
	[if [funkall test exp car-key]
	    car
	  [find exp [cdr seq] key test]]]]]]

[defunk fiber-find_last_trace_env [fiber]
  [find `trace_env [fiber-trace fiber] [funk [x] [car x]] &eq]]

[defunk array-new [:rest lengths]
  [if [null lengths]
      []
    [let [[cdr    [cdr lengths]]
	  [length [car lengths]]]
      [let [[a    [array-new_1d length]]]
	[if cdr [dotimes [i length] [array-elt-set a i [apply &array-new cdr]]]]
	a]]]]

[defunk hashtable-new [bin_num_power] [hashtable bin_num_power [array-new [integer-bitshift_left 1 bin_num_power]]]]

[defunk print [x]
  [format stdout '\n']
  [exp-print x]]

[defunk demetropolize [x]
  [let [[demetro_pair [demetropolize_once x]]]
    [let [[did_something [car demetro_pair]]
	  [retval        [cdr demetro_pair]]]
      [if did_something
	  [demetropolize retval]
	retval]]]]

[defunk demetropolize1 [x]
  [cdr [demetropolize_once x]]]

[defmetro mutexprog [mutex :rest body]
  `[let [[mutexprog-mutex ,mutex]]
     [mutex-lock   mutexprog-mutex]
     [prog @body]
     [mutex-unlock mutexprog-mutex]]]

[defmetro defmutexfunk [mutex name args :rest body]
  `[defunk ,name ,args [mutexprog ,mutex @body]]]

[defmetro defunks-mutex [mutex :rest funkdefs] 
  `[let [[defunks_mutex-mutex ,mutex]]
     @[mapcar [funk [funkdef]
		    `[defmutexfunk defunks_mutex-mutex @funkdef]]]]]

[defmetro rest [exp]
  `[cdr ,exp]]

[defunk remove [element sequence]
  [let [[new_sequence [cons nil nil]]]
    [let [[new_sequence_iter new_sequence]]
      [mapc [funk [sequence_element]
		  [if [not [eq element sequence_element]]
		      [let [[new_cons [cons sequence_element nil]]]
			[cons-cdr-set new_sequence_iter new_cons]
			[mutate new_sequence_iter new_cons]]]]
	    sequence]
      [cdr new_sequence]]]]

[defmetro let* [var_value_pairs :rest body]
  [if [null var_value_pairs]
      `[prog @body]
    [let [[var_value_pair [car var_value_pairs]]]
      [let [[var   [first  var_value_pair]]
	    [value [second var_value_pair]]]
	`[let [[,var ,value]]
	   [let* ,[cdr var_value_pairs]
	     @body]]]]]]

[defunk is_conslist [exp]
  [if [null exp]
      t
    [if [is-type `cons exp]
	[is_conslist [cdr exp]]
      nil]]]

[defmetro bytecode_trace [exp]
  `[let [[this-cause [this-cause]]]
     [cause-bytecode_tracing_on-set this-cause t]
     ,exp
     [cause-bytecode_tracing_on-set this-cause nil]
     [let [[event_buffer_first [cause-event_buffer_first this-cause]]]
       [cause-event_buffer_first-set this-cause nil]
       [cause-event_buffer_last-set  this-cause nil]
       event_buffer_first]]]

[defunk maparray [map_proc exp]
  [let [[length [simple_length exp]]]
    [let [[new_array [array-new length]]]
      [dotimes [i length]
	[array-elt-set new_array i [funkall map_proc [cons [array-elt exp i] nil]]]]
      new_array]]]

[defmetro list [:rest elements] `[new list @elements]]

[defmetro length [x] `[get ,x length]]

[defmetro = [var value] `[mutate ,var ,value]]

[defunk exit [value]
  [management_thread-add_exit_command value]
  [while t
    [yield]]]

[defunk quit []
  [exit 0]]

[defunk save_memory_image [filename]
  [let [[uid          [management_thread-add_save_memory_image_command filename]]
	[done         nil]
	[result_place [new place nil]]]
    [while [not [management_thread-check_command_uid_finished uid result_place]]
      [yield]]
    [get result_place thing]]]

[defunk load_memory_image [filename]
  [let [[uid          [management_thread-add_load_memory_image_command filename]]
	[done         nil]
	[result_place [new place nil]]]
    [while [not [management_thread-check_command_uid_finished uid result_place]]
      [yield]]
    [get result_place thing]]]


[primfunk:load 'fu2/repl.fu2']

[format stdout '\n'
	'funk2: done compiling fu2/bootstrap-repl.fu2.' '\n'
	'funk2: saving half-baked memory_image to img/bootstrap-repl.img.' '\n']

`[primfunk:memory_image__save 'img/bootstrap-repl.img']


'
  These management commands don\'t actually execute until this file reaches EOF.
'
[management_thread-add_save_memory_image_command 'img/bootstrap-repl.img']
[management_thread-add_exit_command 0]

