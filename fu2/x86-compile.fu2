' 
 Copyright (c) 2007-2008 Bo Morgan.
 All rights reserved.
 
 Author: Bo Morgan
 
 Permission to use, copy, modify and distribute this software and its
 documentation is hereby granted, provided that both the copyright
 notice and this permission notice appear in all copies of the
 software, derivative works or modified versions, and any portions
 thereof, and that both notices appear in supporting documentation.
 
 BO MORGAN ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.
 BO MORGAN DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 
 Bo Morgan requests users of this software to return to bo@mit.edu any
 improvements or extensions that they make and grant Bo Morgan the
 rights to redistribute these changes.
'


[load 'fu2/x86-compile-machine_code.fu2']

'funk virtual machine (fvm) compile funktions'

'80483b4:	55                   	push   %ebp'
'80483b5:	89 e5                	mov    %esp,%ebp'
'80483b7:	83 ec 10             	sub    $0x10,%esp'
'80483ba:	8b 45 08             	mov    0x8(%ebp),%eax'
'80483bd:	89 44 24 0c          	mov    %eax,0xc(%esp)'
'80483c1:	8b 45 0c             	mov    0xc(%ebp),%eax'
'80483c4:	89 44 24 08          	mov    %eax,0x8(%esp)'
'80483c8:	8b 45 10             	mov    0x10(%ebp),%eax'
'80483cb:	89 44 24 04          	mov    %eax,0x4(%esp)'
'80483cf:	8b 45 14             	mov    0x14(%ebp),%eax'
'80483d2:	89 04 24             	mov    %eax,(%esp)'
'80483d5:	e8 da ff ff ff       	call   80483b4 <test1>'
'80483da:	c9                   	leave  '
'80483db:	c3                   	ret    '


'80483e1:	55                   	push   %ebp'
'80483e2:	89 e5                	mov    %esp,%ebp'
'80483e4:	83 ec 10             	sub    $0x10,%esp'

'80483e7:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)'
'80483ee:	e8 e9 ff ff ff       	call   80483dc <test3>'

'80483f3:	8b 45 14             	mov    0x14(%ebp),%eax'
'80483f6:	89 44 24 0c          	mov    %eax,0xc(%esp)'
'80483fa:	8b 45 10             	mov    0x10(%ebp),%eax'
'80483fd:	89 44 24 08          	mov    %eax,0x8(%esp)'
'8048401:	8b 45 0c             	mov    0xc(%ebp),%eax'
'8048404:	89 44 24 04          	mov    %eax,0x4(%esp)'
'8048408:	8b 45 08             	mov    0x8(%ebp),%eax'
'804840b:	89 04 24             	mov    %eax,(%esp)'
'804840e:	e8 a1 ff ff ff       	call   80483b4 <test1>'

'8048413:	8b 45 08             	mov    0x8(%ebp),%eax'
'8048416:	89 44 24 0c          	mov    %eax,0xc(%esp)'
'804841a:	8b 45 0c             	mov    0xc(%ebp),%eax'
'804841d:	89 44 24 08          	mov    %eax,0x8(%esp)'
'8048421:	8b 45 10             	mov    0x10(%ebp),%eax'
'8048424:	89 44 24 04          	mov    %eax,0x4(%esp)'
'8048428:	8b 45 14             	mov    0x14(%ebp),%eax'
'804842b:	89 04 24             	mov    %eax,(%esp)'
'804842e:	e8 81 ff ff ff       	call   80483b4 <test1>'

'8048433:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)'
'804843a:	e8 9d ff ff ff       	call   80483dc <test3>'

'804843f:	8b 45 14             	mov    0x14(%ebp),%eax'
'8048442:	89 44 24 0c          	mov    %eax,0xc(%esp)'
'8048446:	8b 45 10             	mov    0x10(%ebp),%eax'
'8048449:	89 44 24 08          	mov    %eax,0x8(%esp)'
'804844d:	8b 45 0c             	mov    0xc(%ebp),%eax'
'8048450:	89 44 24 04          	mov    %eax,0x4(%esp)'
'8048454:	8b 45 08             	mov    0x8(%ebp),%eax'
'8048457:	89 04 24             	mov    %eax,(%esp)'
'804845a:	e8 55 ff ff ff       	call   80483b4 <test1>'

'804845f:	b8 0d 00 00 00       	mov    $0xd,%eax'

'8048464:	c9                   	leave  '
'8048465:	c3                   	ret    '

[defunk call_raw_c_funktion-x86_compile [chunk index cfunk_ptr :rest args]
  [let [[args-len  [length args]]
	[arg-index 0]]
    [set             index [x86_sub_8bit_from_esp-x86_compile chunk index [* 4 args-len]]]
    [mapc [funk [arg]
		[set index [x86_mov_arg_to_arg-x86_compile    chunk index arg  `eax]]
		[set index [x86_mov_arg_to_arg-x86_compile    chunk index `eax [x86_arg-rel_to_reg `esp [* arg-index 4]]]]
		[set arg-index [+ arg-index 1]]]
	  args]
    [let [[after_call_index [x86_call_relative-x86_compile    nil   index nil]]]
      [set           index [x86_call_relative-x86_compile     chunk index [if chunk [- cfunk_ptr [+ [chunk-bytes chunk] after_call_index]] nil]]]]
    [set             index [x86_sub_8bit_from_esp-x86_compile chunk index [- [* 4 args-len]]]]
    index]]

[defmetro cfunk-x86_compile [chunk index :rest compile_body]
  `[let [[chunk   ,chunk]
	 [index   ,index]
	 [context [x86_arg-rel_to_reg `ebp  8]]
	 [thread  [x86_arg-rel_to_reg `ebp 12]]
	 [env     [x86_arg-rel_to_reg `ebp 16]]
	 [args    [x86_arg-rel_to_reg `ebp 20]]]
     [set index [x86_push_arg-x86_compile       chunk index `ebp]]
     [set index [x86_mov_arg_to_arg-x86_compile chunk index `esp `ebp]]
     [prog @compile_body]
     [set index [x86_leave-x86_compile          chunk index]]
     [set index [x86_ret-x86_compile            chunk index]]]]

[defunk call_cfunk-x86_compile [chunk index cfunk_ptr context thread env args]
  [call_raw_c_funktion-x86_compile chunk index cfunk_ptr context thread env args]]

[defunk cfunk-call_cfunk-x86_compile [chunk index cfunk_ptr]
  [cfunk-x86_compile chunk index
		     [call_cfunk-x86_compile chunk index cfunk_ptr context thread env args]]]

`[defunk call_cfunk-x86_compile-backup [chunk index cfunk_ptr]
   [set index [x86_push_arg-x86_compile          chunk index `ebp]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index `esp `ebp]]
   [set index [x86_sub_8bit_from_esp-x86_compile chunk index 16]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index [x86_arg-rel_to_reg `ebp  8] `eax]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index `eax                         [x86_arg-rel_to_reg `esp  0]]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index [x86_arg-rel_to_reg `ebp 12] `eax]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index `eax                         [x86_arg-rel_to_reg `esp  4]]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index [x86_arg-rel_to_reg `ebp 16] `eax]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index `eax                         [x86_arg-rel_to_reg `esp  8]]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index [x86_arg-rel_to_reg `ebp 20] `eax]]
   [set index [x86_mov_arg_to_arg-x86_compile    chunk index `eax                         [x86_arg-rel_to_reg `esp 12]]]
   [let [[after_call_index [x86_call_relative-x86_compile nil index nil]]]
     [set index [x86_call_relative-x86_compile   chunk index [if chunk [- cfunk_ptr [+ [chunk-bytes chunk] after_call_index]] nil]]]]
   [set index [x86_leave-x86_compile             chunk index]]
   [set index [x86_ret-x86_compile               chunk index]]
   index]

`[seaside
  [globalize fvm-x86_register_map `[[seaside:pc-reg         eip]
				    [seaside:stack-reg      esp]
				    [seaside:temp-stack-reg ebp]
				    [seaside:value-reg      eax]
				    [seaside:thread-reg     eax]
				    ]]
  
  [defunk fvm_reg-to-x86_reg [fvm_reg]
    [second [let [[map [find fvm_reg fvm-x86_register_map &car &eq]]]
	      [if map map [error 'could not find mapping.']]]]]
  
  [defunk x86_reg-to-fvm_reg [x86_reg]
    [car [let [[map [find x86_reg fvm-x86_register_map &second &eq]]]
	   [if map map [error 'could not find mapping.']]]]]
  
  [defunk fvm_push_reg-x86_compile [chunk index reg]
    [let [[x86_reg [fvm_reg-to-x86_reg reg]]]
      [x86_push_reg-x86_compile chunk index x86_reg]]]
  
  [defunk fvm_pop_reg-x86_compile [chunk index reg]
    [let [[x86_reg [fvm_reg-to-x86_reg reg]]]
      [x86_pop_reg-x86_compile chunk index x86_reg]]]
  
  [defunk fvm_copy_reg_to_reg-x86_compile [chunk index src_reg dst_reg]
    [let [[x86_src_reg [fvm_reg-to-x86_reg src_reg]]
	  [x86_dst_reg [fvm_reg-to-x86_reg dst_reg]]]
      [x86_mov_reg_to_reg-x86_compile chunk index x86_src_reg x86_dst_reg]]]
  
  '80483b4:	55                   	push   %ebp'
  '80483b5:	89 e5                	mov    %esp,%ebp'
  '80483b7:	83 ec 10             	sub    $0x10,%esp'
  '80483ba:	8b 45 08             	mov    0x8(%ebp),%eax'
  '80483bd:	89 44 24 0c          	mov    %eax,0xc(%esp)'
  '80483c1:	8b 45 0c             	mov    0xc(%ebp),%eax'
  '80483c4:	89 44 24 08          	mov    %eax,0x8(%esp)'
  '80483c8:	8b 45 10             	mov    0x10(%ebp),%eax'
  '80483cb:	89 44 24 04          	mov    %eax,0x4(%esp)'
  '80483cf:	8b 45 14             	mov    0x14(%ebp),%eax'
  '80483d2:	89 04 24             	mov    %eax,(%esp)'
  '80483d5:	e8 da ff ff ff       	call   80483b4 <test1>'
  '80483da:	c9                   	leave  '
  '80483db:	c3                   	ret    '
  
  [defunk cfunk-x86_compile [chunk index body_compile_proc]
    [set index [x86_push_ebp-x86_compile         chunk index]]
    [set index [x86_mov_reg_to_reg-x86_compile   chunk index `esp `ebp]]
    [set index [x86_mov_const_to_eax-x86_compile chunk index 0]]
    [set index [apply body_compile_proc [list    chunk index]]]
    [set index [x86_leave-x86_compile            chunk index]]
    [set index [x86_ret-x86_compile              chunk index]]
    index]
  
  
  
  `test-cfunk-chunk
   [defunk chunk-new_cfunk []
     [let [[body_compile_proc [funk [chunk index]
				    index]]]
       [let [[this [chunk [cfunk-x86_compile nil 0 body_compile_proc]]]]
	 [cfunk-x86_compile this 0 body_compile_proc]
	 this]]]
   ]

'f2__thread__bytecode__push(             thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__pop(              thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__copy(             thread, f2bytecode__arg0(bytecode), f2bytecode__arg1(bytecode));}'
'f2__thread__bytecode__swap(             thread, f2bytecode__arg0(bytecode), f2bytecode__arg1(bytecode));}'
'f2__thread__bytecode__cons(             thread);}'
'f2__thread__bytecode__set_car(          thread);}'
'f2__thread__bytecode__funk(             thread);}'
'f2__thread__bytecode__jump_funk(        thread);}'
'f2__thread__bytecode__set(              thread, f2bytecode__arg0(bytecode), f2bytecode__arg1(bytecode));}'
'f2__thread__bytecode__lookup_funkvar(   thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__set_cdr(          thread);}'
'f2__thread__bytecode__lookup_var(       thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__define_var(       thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__else_jump(        thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__car(              thread);}'
'f2__thread__bytecode__cdr(              thread);}'
'f2__thread__bytecode__define_funkvar(   thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__set_var(          thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__set_funkvar(      thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__globalize_var(    thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__globalize_funkvar(thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__jump(             thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__debug(            thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__trace(            thread, f2bytecode__arg0(bytecode));}'
'f2__thread__bytecode__compile(          thread, f2bytecode__arg0(bytecode), f2bytecode__arg1(bytecode));}'
'f2__thread__bytecode__newenv(           thread);}'

[globalize -x86_compile-thread_reg- `ebx]

'void f2__thread__bytecode__pop(              f2ptr thread, f2ptr reg)'                                  [defunk bytecode-pop-x86_compile               [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:pop-machine_code_ptr               -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__push(             f2ptr thread, f2ptr reg)'                                  [defunk bytecode-push-x86_compile              [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:push-machine_code_ptr              -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__copy(             f2ptr thread, f2ptr src_reg, f2ptr dest_reg)'              [defunk bytecode-copy-x86_compile              [chunk index arg0 arg1] [call_raw_c_funktion-x86_compile chunk index bytecode:copy-machine_code_ptr              -x86_compile-thread_reg- arg0 arg1]]
'void f2__thread__bytecode__swap(             f2ptr thread, f2ptr reg0, f2ptr reg1)'                     [defunk bytecode-swap-x86_compile              [chunk index arg0 arg1] [call_raw_c_funktion-x86_compile chunk index bytecode:swap-machine_code_ptr              -x86_compile-thread_reg- arg0 arg1]]
'void f2__thread__bytecode__cons(             f2ptr thread)'                                             [defunk bytecode-cons-x86_compile              [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:cons-machine_code_ptr              -x86_compile-thread_reg-]]
'void f2__thread__bytecode__set_car(          f2ptr thread)'                                             [defunk bytecode-set_car-x86_compile           [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:set_car-machine_code_ptr           -x86_compile-thread_reg-]]
'void f2__thread__bytecode__set(              f2ptr thread, f2ptr reg, f2ptr exp)'                       [defunk bytecode-set-x86_compile               [chunk index arg0 arg1] [call_raw_c_funktion-x86_compile chunk index bytecode:set-machine_code_ptr               -x86_compile-thread_reg- arg0 arg1]]
'void f2__thread__bytecode__trace(            f2ptr thread, f2ptr value)'                                [defunk bytecode-trace-x86_compile             [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:trace-machine_code_ptr             -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__set_cdr(          f2ptr thread)'                                             [defunk bytecode-set_cdr-x86_compile           [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:set_cdr-machine_code_ptr           -x86_compile-thread_reg-]]
'void f2__thread__bytecode__jump_funk(        f2ptr thread)'                                             [defunk bytecode-jump_funk-x86_compile         [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:jump_funk-machine_code_ptr         -x86_compile-thread_reg-]]
'void f2__thread__bytecode__funk(             f2ptr thread)'                                             [defunk bytecode-funk-x86_compile              [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:funk-machine_code_ptr              -x86_compile-thread_reg-]]
'void f2__thread__bytecode__lookup_funkvar(   f2ptr thread, f2ptr funkvar)'                              [defunk bytecode-lookup_funkvar-x86_compile    [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:lookup_funkvar-machine_code_ptr    -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__lookup_var(       f2ptr thread, f2ptr var)'                                  [defunk bytecode-lookup_var-x86_compile        [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:lookup_var-machine_code_ptr        -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__define_var(       f2ptr thread, f2ptr var)'                                  [defunk bytecode-define_var-x86_compile        [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:define_var-machine_code_ptr        -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__else_jump(        f2ptr thread, f2ptr new_program_counter)'                  [defunk bytecode-else_jump-x86_compile         [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:else_jump-machine_code_ptr         -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__car(              f2ptr thread)'                                             [defunk bytecode-car-x86_compile               [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:car-machine_code_ptr               -x86_compile-thread_reg-]]
'void f2__thread__bytecode__cdr(              f2ptr thread)'                                             [defunk bytecode-cdr-x86_compile               [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:cdr-machine_code_ptr               -x86_compile-thread_reg-]]
'void f2__thread__bytecode__jump(             f2ptr thread, f2ptr new_program_counter)'                  [defunk bytecode-jump-x86_compile              [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:jump-machine_code_ptr              -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__globalize_funkvar(f2ptr thread, f2ptr funkvar)'                              [defunk bytecode-globalize_funkvar-x86_compile [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:globalize_funkvar-machine_code_ptr -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__set_var(          f2ptr thread, f2ptr var)'                                  [defunk bytecode-set_var-x86_compile           [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:set_var-machine_code_ptr           -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__globalize_var(    f2ptr thread, f2ptr var)'                                  [defunk bytecode-globalize_var-x86_compile     [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:globalize_var-machine_code_ptr     -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__yield(            f2ptr thread)'                                             [defunk bytecode-yield-x86_compile             [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:yield-machine_code_ptr             -x86_compile-thread_reg-]]
'void f2__thread__bytecode__define_funkvar(   f2ptr thread, f2ptr funkvar)'                              [defunk bytecode-define_funkvar-x86_compile    [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:define_funkvar-machine_code_ptr    -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__set_funkvar(      f2ptr thread, f2ptr funkvar)'                              [defunk bytecode-set_funkvar-x86_compile       [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:set_funkvar-machine_code_ptr       -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__debug(            f2ptr thread, f2ptr value)'                                [defunk bytecode-debug-x86_compile             [chunk index arg0]      [call_raw_c_funktion-x86_compile chunk index bytecode:debug-machine_code_ptr             -x86_compile-thread_reg- arg0]]
'void f2__thread__bytecode__compile(          f2ptr thread, f2ptr tracewrap, f2ptr protect_environment)' [defunk bytecode-compile-x86_compile           [chunk index arg0 arg1] [call_raw_c_funktion-x86_compile chunk index bytecode:compile-machine_code_ptr           -x86_compile-thread_reg- arg0 arg1]]
'void f2__thread__bytecode__newenv(           f2ptr thread)'                                             [defunk bytecode-newenv-x86_compile            [chunk index]           [call_raw_c_funktion-x86_compile chunk index bytecode:newenv-machine_code_ptr            -x86_compile-thread_reg-]]

[defunk bytecode-x86_compile [chunk index bytecode]
  [if [not [integer?  index]]    [error `machine_code_compile-time [list `bytecode-x86_compile 'index var is not of type integer']]]
  [if [not [bytecode? bytecode]] [error `machine_code_compile-time [list `bytecode-x86_compile 'bytecode var is not of type bytecode']]]
  [let [[command [bytecode-command bytecode]]]
    [cond [[eq command `bytecode:pop]               [set index [bytecode-pop-x86_compile               chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:push]              [set index [bytecode-push-x86_compile              chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:copy]              [set index [bytecode-copy-x86_compile              chunk index [pointer [bytecode-arg0 bytecode]] [pointer [bytecode-arg1 bytecode]]]]]
	  [[eq command `bytecode:swap]              [set index [bytecode-swap-x86_compile              chunk index [pointer [bytecode-arg0 bytecode]] [pointer [bytecode-arg1 bytecode]]]]]
	  [[eq command `bytecode:cons]              [set index [bytecode-cons-x86_compile              chunk index]]]
	  [[eq command `bytecode:set-car]           [set index [bytecode-set_car-x86_compile           chunk index]]]
	  [[eq command `bytecode:set]               [set index [bytecode-set-x86_compile               chunk index [pointer [bytecode-arg0 bytecode]] [pointer [bytecode-arg1 bytecode]]]]]
	  [[eq command `bytecode:trace]             [set index [bytecode-trace-x86_compile             chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:set-cdr]           [set index [bytecode-set_cdr-x86_compile           chunk index]]]
	  [[eq command `bytecode:jump-funk]         [set index [bytecode-jump_funk-x86_compile         chunk index]]]
	  [[eq command `bytecode:funk]              [set index [bytecode-funk-x86_compile              chunk index]]]
	  [[eq command `bytecode:lookup-funkvar]    [set index [bytecode-lookup_funkvar-x86_compile    chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:lookup-var]        [set index [bytecode-lookup_var-x86_compile        chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:define-var]        [set index [bytecode-define_var-x86_compile        chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:else-jump]         [set index [bytecode-else_jump-x86_compile         chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:car]               [set index [bytecode-car-x86_compile               chunk index]]]
	  [[eq command `bytecode:nop]               nil]
	  [[eq command `bytecode:cdr]               [set index [bytecode-cdr-x86_compile               chunk index]]]
	  [[eq command `bytecode:jump]              [set index [bytecode-jump-x86_compile              chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:globalize-funkvar] [set index [bytecode-globalize_funkvar-x86_compile chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:set-var]           [set index [bytecode-set_var-x86_compile           chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:globalize-var]     [set index [bytecode-globalize_var-x86_compile     chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:yield]             [set index [bytecode-yield-x86_compile             chunk index]]]
	  [[eq command `bytecode:define-funkvar]    [set index [bytecode-define_funkvar-x86_compile    chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:set-funkvar]       [set index [bytecode-set_funkvar-x86_compile       chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:debug]             [set index [bytecode-debug-x86_compile             chunk index [pointer [bytecode-arg0 bytecode]]]]]
	  [[eq command `bytecode:compile]           [set index [bytecode-compile-x86_compile           chunk index [pointer [bytecode-arg0 bytecode]] [pointer [bytecode-arg1 bytecode]]]]]
	  [[eq command `bytecode:newenv]            [set index [bytecode-newenv-x86_compile            chunk index]]]
	  [t                                        [error `machine_code_compile-time 'unknown bytecode command']]]]
  index]

[defunk bytecodes-x86_compile [chunk index bytecodes]
  [mapc [funk [bytecode]
	      [set index [bytecode-x86_compile chunk index bytecode]]]
	bytecodes]
  index]

[defunk funk-x86_compile [chunk index funk]
  [let [[bytecodes [funk-body_bytecodes funk]]]
    [cfunk-x86_compile chunk index
		       [set index [x86_mov_arg_to_arg-x86_compile  chunk index thread -x86_compile-thread_reg-]]
		       [set index [bytecodes-x86_compile           chunk index bytecodes]]
		       index]]]

[defunk funk-compile [funk]
  [let [[len [funk-x86_compile nil 0 funk]]]
    [let [[chunk [chunk len]]]
      [funk-x86_compile chunk 0 funk]
      chunk]]]


'// define args in funk environment'
'iter = f2__set_list_cdr(context, iter, f2__compile__copy_args_to_iter(context, tracewrap));'
'f2ptr var_iter = f2funk__args(funk);'
'while (var_iter) {'
'  '
'  f2ptr var = raw__car(nil, var_iter);'
'  f2ptr cdr = raw__cdr(nil, var_iter);'
		     '  if (var == __and_rest__symbol) {'
'    '
'    iter = f2__set_list_cdr(context, iter, f2__compile__copy_iter_to_value(context, tracewrap));'
'    iter = f2__set_list_cdr(context, iter, f2__compile__define_var(context, tracewrap, raw__car(nil, cdr)));'
'    var_iter = nil;'
'    '
'  } else {'
		     '    '
'    iter = f2__set_list_cdr(context, iter, f2__compile__copy_iter_to_value(context, tracewrap));'
'    iter = f2__set_list_cdr(context, iter, f2__compile__else_jump(context, tracewrap, __wrong_argument_number__bcs));'
'    '
'    iter = f2__set_list_cdr(context, iter, f2__compile__car(context, tracewrap));'
'    iter = f2__set_list_cdr(context, iter, f2__compile__define_var(context, tracewrap, var));'
'    '
'    if (cdr) {'
'      iter = f2__set_list_cdr(context, iter, f2__compile__cdr(context, tracewrap));'
'      iter = f2__set_list_cdr(context, iter, f2__compile__copy_value_to_iter(context, tracewrap));'
'    }'
'    '
'    var_iter = cdr;'
'  }'
'}'

'f2ptr f2__compile__tracewrap(f2ptr context, bool tracewrap, f2ptr value, f2ptr bcs) {return bcs_valid(f2cons__new(context, f2bytecode__new(context, __bytecode__trace__symbol, value, nil), bcs));}'
[defunk compile-tracewrap [chunk index value] [bytecode-x86_compile chunk index [bytecode `bytecode:trace value nil]]]

'f2ptr f2__tracewrap__bcs(f2ptr context, bool tracewrap, f2ptr bcs)                  {return bcs_valid(tracewrap ? f2cons__new(context, f2bytecode__new(context, __bytecode__trace__symbol, bcs,   nil), bcs) : bcs);}'
[defunk tracewrap-bytecode-x86_compile [chunk index tracewrap bytecode]
  [if tracewrap [set index [compile-tracewrap chunk index [list chunk index bytecode]]]]
  [bytecode-x86_compile chunk index bytecode]]

'f2ptr f2__compile__funk_bc(f2ptr context, bool tracewrap)                                               {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__funk__symbol, nil,  nil),  nil)));}'
'f2ptr f2__compile__jump_funk(f2ptr context, bool tracewrap)                                             {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__jump_funk__symbol, nil,  nil),  nil)));}'
'f2ptr f2__compile__cons(f2ptr context, bool tracewrap)                                                  {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__cons__symbol, nil,  nil),  nil)));}'
'f2ptr f2__compile__car(f2ptr context, bool tracewrap)                                                   {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__car__symbol, nil,  nil),  nil)));}'
'f2ptr f2__compile__cdr(f2ptr context, bool tracewrap)                                                   {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__cdr__symbol, nil,  nil),  nil)));}'
'f2ptr f2__compile__set_car(f2ptr context, bool tracewrap)                                               {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__set_car__symbol, nil,  nil),  nil)));}'
'f2ptr f2__compile__set_cdr(f2ptr context, bool tracewrap)                                               {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__set_cdr__symbol, nil,  nil),  nil)));}'
'f2ptr f2__compile__set(f2ptr context, bool tracewrap, f2ptr reg, f2ptr exp)                             {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__set__symbol,  reg,  exp),  nil)));}'
'f2ptr f2__compile__swap(f2ptr context, bool tracewrap, f2ptr reg0, f2ptr reg1)                          {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__swap__symbol, reg0, reg1), nil)));}'
'f2ptr f2__compile__push(f2ptr context, bool tracewrap, f2ptr reg)                                       {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__push__symbol, reg, nil),  nil)));}'
'f2ptr f2__compile__pop(f2ptr context, bool tracewrap, f2ptr reg)                                        {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__pop__symbol,  reg, nil), nil)));}'
'f2ptr f2__compile__copy(f2ptr context, bool tracewrap, f2ptr reg0, f2ptr reg1)                          {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__copy__symbol, reg0, reg1), nil)));}'
'f2ptr f2__compile__lookup_var(f2ptr context, bool tracewrap, f2ptr exp)                                 {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__lookup_var__symbol, exp, nil), nil)));}'
'f2ptr f2__compile__lookup_funkvar(f2ptr context, bool tracewrap, f2ptr exp)                             {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__lookup_funkvar__symbol, exp, nil), nil)));}'
'f2ptr f2__compile__define_funkvar(f2ptr context, bool tracewrap, f2ptr var)                             {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__define_funkvar__symbol, var, nil), nil)));}'
'f2ptr f2__compile__define_var(f2ptr context, bool tracewrap, f2ptr var)                                 {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__define_var__symbol, var, nil), nil)));}'
'f2ptr f2__compile__set_funkvar(f2ptr context, bool tracewrap, f2ptr var)                                {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__set_funkvar__symbol, var, nil), nil)));}'
'f2ptr f2__compile__set_var(f2ptr context, bool tracewrap, f2ptr var)                                    {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__set_var__symbol, var, nil), nil)));}'
'f2ptr f2__compile__globalize_funkvar(f2ptr context, bool tracewrap, f2ptr var)                          {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__globalize_funkvar__symbol, var, nil), nil)));}'
'f2ptr f2__compile__globalize_var(f2ptr context, bool tracewrap, f2ptr var)                              {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__globalize_var__symbol, var, nil), nil)));}'
'f2ptr f2__compile__jump(f2ptr context, bool tracewrap, f2ptr new_pc)                                    {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__jump__symbol, new_pc, nil), nil)));}'
'f2ptr f2__compile__else_jump(f2ptr context, bool tracewrap, f2ptr new_pc)                               {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__else_jump__symbol, new_pc, nil), nil)));}'
'f2ptr f2__compile__nop(f2ptr context, bool tracewrap)                                                   {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__nop__symbol, nil, nil), nil)));}'
'f2ptr f2__compile__debug(f2ptr context, bool tracewrap, f2ptr value)                                    {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__debug__symbol, value, nil), nil)));}'
'f2ptr f2__compile__trace(f2ptr context, bool tracewrap, f2ptr value)                                    {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__trace__symbol, value, nil), nil)));}'
'f2ptr f2__compile__compile(f2ptr context, bool tracewrap, f2ptr protect_environment, f2ptr tw_compiled) {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__compile__symbol, tw_compiled, protect_environment), nil)));}'
'f2ptr f2__compile__yield(f2ptr context, bool tracewrap)                                                 {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__yield__symbol, nil, nil), nil)));}'
'f2ptr f2__compile__newenv(f2ptr context, bool tracewrap)                                                {return bcs_valid(f2__tracewrap__bcs(context, tracewrap, f2cons__new(context, f2bytecode__new(context, __bytecode__newenv__symbol, nil, nil), nil)));}'

[defunk jump_funk-x86_compile         [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:funk              nil    nil]]]
[defunk funk_bc-x86_compile           [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:jump-funk         nil    nil]]]
[defunk cons-x86_compile              [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:cons              nil    nil]]]
[defunk car-x86_compile               [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:car               nil    nil]]]
[defunk cdr-x86_compile               [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:cdr               nil    nil]]]
[defunk set_car-x86_compile           [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:set-car           nil    nil]]]
[defunk set_cdr-x86_compile           [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:set-cdr           nil    nil]]]
[defunk set-x86_compile               [chunk index tracewrap reg exp]    [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:set-cdr           reg    exp]]]
[defunk swap-x86_compile              [chunk index tracewrap reg0 reg1]  [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:swap              reg0   reg1]]]
[defunk push-x86_compile              [chunk index tracewrap reg]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:push              reg    nil]]]
[defunk pop-x86_compile               [chunk index tracewrap reg]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:pop               reg    nil]]]
[defunk copy-x86_compile              [chunk index tracewrap reg0 reg1]  [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:copy              reg0   reg1]]]
[defunk lookup_var-x86_compile        [chunk index tracewrap exp]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:lookup-var        exp    nil]]]
[defunk lookup_funkvar-x86_compile    [chunk index tracewrap exp]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:lookup-funkvar    exp    nil]]]
[defunk define_funkvar-x86_compile    [chunk index tracewrap var]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:define-funkvar    var    nil]]]
[defunk define_var-x86_compile        [chunk index tracewrap var]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:define-var        var    nil]]]
[defunk set_funkvar-x86_compile       [chunk index tracewrap var]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:set-funkvar       var    nil]]]
[defunk set_var-x86_compile           [chunk index tracewrap var]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:set-var           var    nil]]]
[defunk globalize_funkvar-x86_compile [chunk index tracewrap var]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:globalize-funkvar var    nil]]]
[defunk globalize_var-x86_compile     [chunk index tracewrap var]        [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:globalize-var     var    nil]]]
[defunk jump-x86_compile              [chunk index tracewrap new_pc]     [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:jump              new_pc nil]]]
[defunk else_jump-x86_compile         [chunk index tracewrap new_pc]     [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:else-jump         new_pc nil]]]
[defunk debug-x86_compile             [chunk index tracewrap value]      [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:debug             value  nil]]]
[defunk trace-x86_compile             [chunk index tracewrap value]      [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:trace             value  nil]]]
[defunk compile-x86_compile           [chunk index tracewrap prot trace] [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:compile           prot   trace]]]
[defunk yield-x86_compile             [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:yield             nil    nil]]]
[defunk newenv-x86_compile            [chunk index tracewrap]            [tracewrap-bytecode-x86_compile chunk index tracewrap [bytecode `bytecode:newenv            nil    nil]]]



'f2ptr f2__compile__set_value(f2ptr context, bool tracewrap, f2ptr exp)                                  {return bcs_valid(f2__compile__set(  context, tracewrap, __thread__value_reg__symbol, exp));}'
'f2ptr f2__compile__set_iter(f2ptr context, bool tracewrap, f2ptr exp)                                   {return bcs_valid(f2__compile__set(  context, tracewrap, __thread__iter_reg__symbol, exp));}'
'f2ptr f2__compile__set_args(f2ptr context, bool tracewrap, f2ptr exp)                                   {return bcs_valid(f2__compile__set(  context, tracewrap, __thread__args_reg__symbol, exp));}'
'f2ptr f2__compile__set_env(f2ptr context, bool tracewrap, f2ptr exp)                                    {return bcs_valid(f2__compile__set(  context, tracewrap, __thread__env_reg__symbol, exp));}'
'f2ptr f2__compile__swap_value_and_iter(f2ptr context, bool tracewrap)                                   {return bcs_valid(f2__compile__swap( context, tracewrap, __thread__value_reg__symbol, __thread__iter_reg__symbol));}'
'f2ptr f2__compile__swap_value_and_args(f2ptr context, bool tracewrap)                                   {return bcs_valid(f2__compile__swap( context, tracewrap, __thread__value_reg__symbol, __thread__args_reg__symbol));}'
'f2ptr f2__compile__push_value(f2ptr context, bool tracewrap)                                            {return bcs_valid(f2__compile__push( context, tracewrap, __thread__value_reg__symbol));}'
'f2ptr f2__compile__push_iter(f2ptr context, bool tracewrap)                                             {return bcs_valid(f2__compile__push( context, tracewrap, __thread__iter_reg__symbol));}'
'f2ptr f2__compile__push_args(f2ptr context, bool tracewrap)                                             {return bcs_valid(f2__compile__push( context, tracewrap, __thread__args_reg__symbol));}'
'f2ptr f2__compile__push_env(f2ptr context, bool tracewrap)                                              {return bcs_valid(f2__compile__push( context, tracewrap, __thread__env_reg__symbol));}'
'f2ptr f2__compile__push_return(f2ptr context, bool tracewrap)                                           {return bcs_valid(f2__compile__push( context, tracewrap, __thread__return_reg__symbol));}'
'f2ptr f2__compile__pop_value(f2ptr context, bool tracewrap)                                             {return bcs_valid(f2__compile__pop(  context, tracewrap, __thread__value_reg__symbol));}'
'f2ptr f2__compile__pop_iter(f2ptr context, bool tracewrap)                                              {return bcs_valid(f2__compile__pop(  context, tracewrap, __thread__iter_reg__symbol));}'
'f2ptr f2__compile__pop_args(f2ptr context, bool tracewrap)                                              {return bcs_valid(f2__compile__pop(  context, tracewrap, __thread__args_reg__symbol));}'
'f2ptr f2__compile__pop_env(f2ptr context, bool tracewrap)                                               {return bcs_valid(f2__compile__pop(  context, tracewrap, __thread__env_reg__symbol));}'
'f2ptr f2__compile__pop_return(f2ptr context, bool tracewrap)                                            {return bcs_valid(f2__compile__pop(  context, tracewrap, __thread__return_reg__symbol));}'
'f2ptr f2__compile__pop_nil(f2ptr context, bool tracewrap)                                               {return bcs_valid(f2__compile__pop(  context, tracewrap, nil));}'
'f2ptr f2__compile__copy_value_to_args(f2ptr context, bool tracewrap)                                    {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__value_reg__symbol, __thread__args_reg__symbol));}'
'f2ptr f2__compile__copy_value_to_iter(f2ptr context, bool tracewrap)                                    {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__value_reg__symbol, __thread__iter_reg__symbol));}'
'f2ptr f2__compile__copy_iter_to_value(f2ptr context, bool tracewrap)                                    {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__iter_reg__symbol, __thread__value_reg__symbol));}'
'f2ptr f2__compile__copy_iter_to_args(f2ptr context, bool tracewrap)                                     {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__iter_reg__symbol, __thread__args_reg__symbol));}'
'f2ptr f2__compile__copy_args_to_value(f2ptr context, bool tracewrap)                                    {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__args_reg__symbol, __thread__value_reg__symbol));}'
'f2ptr f2__compile__copy_args_to_iter(f2ptr context, bool tracewrap)                                     {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__args_reg__symbol, __thread__iter_reg__symbol));}'
'f2ptr f2__compile__copy_pc_to_return(f2ptr context, bool tracewrap)                                     {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__program_counter_reg__symbol, __thread__return_reg__symbol));}'
'f2ptr f2__compile__copy_return_to_pc(f2ptr context, bool tracewrap)                                     {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__return_reg__symbol, __thread__program_counter_reg__symbol));}'
'f2ptr f2__compile__return(f2ptr context, bool tracewrap)                                                {return bcs_valid(f2__compile__copy( context, tracewrap, __thread__return_reg__symbol, __thread__program_counter_reg__symbol));}'

[defunk set-value-x86_compile           [chunk index tracewrap exp]       [set-x86_compile  chunk index tracewrap `thread:value-reg exp]]
[defunk set-iter-x86_compile            [chunk index tracewrap exp]       [set-x86_compile  chunk index tracewrap `thread:iter-reg  exp]]
[defunk set-args-x86_compile            [chunk index tracewrap exp]       [set-x86_compile  chunk index tracewrap `thread:args-reg  exp]]
[defunk set-env-x86_compile             [chunk index tracewrap exp]       [set-x86_compile  chunk index tracewrap `thread:env-reg   exp]]
[defunk swap-value_and_iter-x86_compile [chunk index tracewrap]           [swap-x86_compile chunk index tracewrap `thread:value-reg `thread:iter-reg]]
[defunk swap-value_and_args-x86_compile [chunk index tracewrap]           [swap-x86_compile chunk index tracewrap `thread:value-reg `thread:args-reg]]
[defunk push-value-x86_compile          [chunk index tracewrap]           [push-x86_compile chunk index tracewrap `thread:value-reg]]
[defunk push-iter-x86_compile           [chunk index tracewrap]           [push-x86_compile chunk index tracewrap `thread:iter-reg]]
[defunk push-args-x86_compile           [chunk index tracewrap]           [push-x86_compile chunk index tracewrap `thread:args-reg]]
[defunk push-env-x86_compile            [chunk index tracewrap]           [push-x86_compile chunk index tracewrap `thread:env-reg]]
[defunk push-return-x86_compile         [chunk index tracewrap]           [push-x86_compile chunk index tracewrap `thread:return-reg]]
[defunk pop-value-x86_compile           [chunk index tracewrap]           [pop-x86_compile  chunk index tracewrap `thread:value-reg]]
[defunk pop-iter-x86_compile            [chunk index tracewrap]           [pop-x86_compile  chunk index tracewrap `thread:iter-reg]]
[defunk pop-args-x86_compile            [chunk index tracewrap]           [pop-x86_compile  chunk index tracewrap `thread:args-reg]]
[defunk pop-env-x86_compile             [chunk index tracewrap]           [pop-x86_compile  chunk index tracewrap `thread:env-reg]]
[defunk pop-return-x86_compile          [chunk index tracewrap]           [pop-x86_compile  chunk index tracewrap `thread:return-reg]]
[defunk pop-nil-x86_compile             [chunk index tracewrap]           [pop-x86_compile  chunk index tracewrap nil]]
[defunk copy-value_to_args-x86_compile  [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:value-reg           `thread:args-reg]]
[defunk copy-value_to_iter-x86_compile  [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:value-reg           `thread:iter-reg]]
[defunk copy-iter_to_value-x86_compile  [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:iter-reg            `thread:value-reg]]
[defunk copy-iter_to_args-x86_compile   [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:iter-reg            `thread:args-reg]]
[defunk copy-args_to_value-x86_compile  [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:args-reg            `thread:value-reg]]
[defunk copy-args_to_iter-x86_compile   [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:args-reg            `thread:iter-reg]]
[defunk copy-pc_to_return-x86_compile   [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:program-counter-reg `thread:return-reg]]
[defunk copy-return_to_pc-x86_compile   [chunk index tracewrap]           [copy-x86_compile chunk index tracewrap `thread:return-reg          `thread:program-counter-reg]]
[defunk copy-return-x86_compile         [chunk index tracewrap]           [copy-return_to_pc-x86_compile chunk index tracewrap]]


[defunk cfunk-call_raw_c_funktion-compile [tracewrap cfunk_ptr :rest user_args]
  [print 'test 0']
  [define-funk compile_helper
    [funk [chunk index]
	  [cfunk-x86_compile chunk index
			     [print 'debug 1']
			     [print user_args]
			     [let [[user_args-len  [length user_args]]
				   [user_args-index 0]]
			       [if [> user_args-len 0]
				   [prog
				    [print 'debug 2']
				    [set                     index [x86_sub_8bit_from_esp-x86_compile chunk index [* 4 user_args-len]]]
				    [print 'debug 3']
				    [set                     index [copy-args_to_iter-x86_compile chunk index tracewrap]]
				    [print 'debug 4']
				    [let [[iter user_args]]
				      [define-funk loop
					[funk []
					      [print 'debug 5']
					      [let [[var [car iter]]
						    [cdr [cdr iter]]]
						[print 'debug 6']
						[set               index [copy-iter_to_value-x86_compile               chunk index tracewrap]]
						[print 'debug 7']
						[set               index [else_jump-x86_compile                        chunk index tracewrap [funk-body_bytecodes &wrong_argument_number_error]]]
						
						[print 'debug 8']
						[set               index [car-x86_compile                              chunk index tracewrap]]
						[print 'debug 9']
						
						[set               index [call_cfunk-x86_compile                       chunk index [cfunk-cfunk_ptr &unsafe:thread-value] #x0 -x86_compile-thread_reg- #x0 #x0]]
						[print 'debug 10']
						
						[set               index [x86_mov_arg_to_arg-x86_compile    chunk index `eax [x86_arg-rel_to_reg `esp [* user_args-index 4]]]]
						[print 'debug 11']
						[set user_args-index [+ user_args-index 1]]
						
						[print 'debug 12']
						[if cdr [prog [set index [cdr-x86_compile                chunk index tracewrap]]
							      [print 'debug 13']
							      [set index [copy-value_to_iter-x86_compile chunk index tracewrap]]]]
						
						[print 'debug 14']
						[set iter cdr]
						[if iter [loop]]]]]
				      [if iter [loop]]]]]
			       
			       [print 'debug 15']
			       [let [[after_call_index        [x86_call_relative-x86_compile     nil   index nil]]]
				 [print 'debug 16']
				 [set                   index [x86_call_relative-x86_compile     chunk index [if chunk [- cfunk_ptr [+ [chunk-bytes chunk] after_call_index]] nil]]]]
			       [print 'debug 17']
			       [set                     index [x86_sub_8bit_from_esp-x86_compile chunk index [- [* 4 user_args-len]]]]
			       [print 'debug 18']
			       
			       index]]]]
  
  [print 'test 1']

  [let [[chunk-len [compile_helper nil 0]]]
    [print 'test 2']
    [let [[cfunk_chunk [chunk chunk-len]]]
      [print 'test 3']
      [compile_helper cfunk_chunk 0]
      [print 'test 4']
      cfunk_chunk]]]


